<!DOCTYPE html>
<html>



<head>
  <meta charset="utf-8">
  
  <title>hibernate入门 | Zale Zone</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="hibernate基础语义
1.Configuration
Configuration类负责管理Hibernate的配置信息。Hibernate运行时需要获取一些底层实现的基本信息。这些属性可以在Hibernate配置文件（hibernate.cfg.xml或hibernate.properties）中加以设定。">
<meta property="og:type" content="article">
<meta property="og:title" content="hibernate入门">
<meta property="og:url" content="http://zalezone.cn/2015/04/26/hibernate/">
<meta property="og:site_name" content="Zale Zone">
<meta property="og:description" content="hibernate基础语义
1.Configuration
Configuration类负责管理Hibernate的配置信息。Hibernate运行时需要获取一些底层实现的基本信息。这些属性可以在Hibernate配置文件（hibernate.cfg.xml或hibernate.properties）中加以设定。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hibernate入门">
<meta name="twitter:description" content="hibernate基础语义
1.Configuration
Configuration类负责管理Hibernate的配置信息。Hibernate运行时需要获取一些底层实现的基本信息。这些属性可以在Hibernate配置文件（hibernate.cfg.xml或hibernate.properties）中加以设定。">

  
    <link rel="alternative" href="/atom.xml" title="Zale Zone" type="application/atom+xml">
  
  
    <link rel="icon" href="/z.png">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->


  <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F5775b426920e4c5be15841fdaf67886f' type='text/javascript'%3E%3C/script%3E"));
</script>







<style type="text/css">
@font-face {
  font-family: 'Source Code Pro';
  font-style: normal;
  font-weight: 400;
  src: local('Source Code Pro'), local('SourceCodePro-Regular'), url(/font/SourceCodePro-Regular.ttf) format('ttf');
}
</style>

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zale Zone</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">不愿冒险的人，通常只能选择别人剩下的东西</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">存档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://zalezone.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-hibernate" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/26/hibernate/" class="article-date">
  <time datetime="2015-04-26T11:07:00.000Z" itemprop="datePublished">4月 26 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>


<div class="rdbWrapper" style="float:left;position:relative;bottom:6px;" data-version="1" data-orientation="0" data-show-email="0" data-show-print="0" data-show-send-to-kindle="1" data-show-read-later="0" data-show-read-now="0"></div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      hibernate入门 <span style='color:#999;font:12px "Helvetica Neue",Helvetica,Arial,sans-serif;'><span class="ds-thread-count" data-thread-key="hibernate" data-count-type="comments"></span>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
          

<!-- toc -->

	<div id="toc" class="toc-article">
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#hibernate基础语义"><span class="toc-number">1.</span> <span class="toc-text">hibernate基础语义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Configuration"><span class="toc-number">1.1.</span> <span class="toc-text">1.Configuration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SessionFactory"><span class="toc-number">1.2.</span> <span class="toc-text">2.SessionFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Session"><span class="toc-number">1.3.</span> <span class="toc-text">3.Session</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础配置"><span class="toc-number">2.</span> <span class="toc-text">基础配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SessionFactory配置"><span class="toc-number">2.1.</span> <span class="toc-text">1.SessionFactory配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务管理"><span class="toc-number">3.</span> <span class="toc-text">事务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-使用JDBC的事务处理机制"><span class="toc-number">3.1.</span> <span class="toc-text">1.使用JDBC的事务处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-使用JTA"><span class="toc-number">3.2.</span> <span class="toc-text">2.使用JTA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate_O/R_映射"><span class="toc-number">4.</span> <span class="toc-text">Hibernate O/R 映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Hibernate基本数据类型"><span class="toc-number">4.1.</span> <span class="toc-text">1.Hibernate基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-实体映射"><span class="toc-number">4.2.</span> <span class="toc-text">2.实体映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1实体映射基础"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1实体映射基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2高级映射技术"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2高级映射技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据关联"><span class="toc-number">5.</span> <span class="toc-text">数据关联</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-一对一关联"><span class="toc-number">5.1.</span> <span class="toc-text">1.一对一关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-一对多关联"><span class="toc-number">5.2.</span> <span class="toc-text">2.一对多关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-多对多关联"><span class="toc-number">5.3.</span> <span class="toc-text">3.多对多关联</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate数据检索"><span class="toc-number">6.</span> <span class="toc-text">Hibernate数据检索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Criteria_Query"><span class="toc-number">6.1.</span> <span class="toc-text">1.Criteria Query</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Criteria查询表达式"><span class="toc-number">6.1.1.</span> <span class="toc-text">Criteria查询表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#示例查询"><span class="toc-number">6.1.2.</span> <span class="toc-text">示例查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合查询"><span class="toc-number">6.2.</span> <span class="toc-text">复合查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DetachedCriteria"><span class="toc-number">6.3.</span> <span class="toc-text">2.DetachedCriteria</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Criteria高级特性"><span class="toc-number">6.3.1.</span> <span class="toc-text">Criteria高级特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Criteria综述"><span class="toc-number">6.3.2.</span> <span class="toc-text">Criteria综述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Hibernate_Query_Language（HQL）"><span class="toc-number">6.4.</span> <span class="toc-text">3.Hibernate Query Language（HQL）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HQL实用技术"><span class="toc-number">7.</span> <span class="toc-text">HQL实用技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-实体查询"><span class="toc-number">7.1.</span> <span class="toc-text">1.实体查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-属性查询"><span class="toc-number">7.2.</span> <span class="toc-text">2.属性查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-实体更新与删除"><span class="toc-number">7.3.</span> <span class="toc-text">3.实体更新与删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-分组与排序"><span class="toc-number">7.4.</span> <span class="toc-text">4.分组与排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-参数绑定"><span class="toc-number">7.5.</span> <span class="toc-text">5.参数绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-引用查询"><span class="toc-number">7.6.</span> <span class="toc-text">6.引用查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-联合查询"><span class="toc-number">7.7.</span> <span class="toc-text">7.联合查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-子查询"><span class="toc-number">7.8.</span> <span class="toc-text">8.子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-数据加载方式"><span class="toc-number">7.9.</span> <span class="toc-text">9.数据加载方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-SQL查询"><span class="toc-number">8.</span> <span class="toc-text">10.SQL查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-自定义持久化实现"><span class="toc-number">9.</span> <span class="toc-text">11.自定义持久化实现</span></a></li></ol>
	</div>

<h2 id="hibernate基础语义">hibernate基础语义</h2>
<h3 id="1-Configuration">1.Configuration</h3>
<p>Configuration类负责管理Hibernate的配置信息。Hibernate运行时需要获取一些底层实现的基本信息。这些属性可以在Hibernate配置文件（hibernate.cfg.xml或hibernate.properties）中加以设定。</p>
<a id="more"></a>

<p>当调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Configuration config = <span class="keyword">new</span> Configuration().configure();</div></pre></td></tr></table></figure>

<p>时，会自动在当前的CLASSPATH中寻找hibernate.cfg.xml文件并加载到内存中。</p>
<p>Configuraton类一般只有在获取SessionFactory时需要涉及，当SessionFactory实例创建之后，由于配置信息已经绑定在返回的SessionFactory中了，所以一般无需在对其进行操作了。</p>
<h3 id="2-SessionFactory">2.SessionFactory</h3>
<p>SessionFactory负责创建Session实例。可以通过Configuration实例构建SessionFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Configuration config = <span class="keyword">new</span> Configuration().configure();</div><div class="line">SessionFactory sessionFactory = config,buildSessionFactory();</div></pre></td></tr></table></figure>

<p>SessionFactory实例一旦构造完毕，就被赋予特定的配置信息，之后config的变更将不会影响到已经创建的SessionFactory实例。如果需要改动的话就需要重新建一个SessionFactory的实例。如果要访问多个数据库，那么针对每个数据库，应该分别为其创建对应的SessionFactory实例。</p>
<p>SessionFactory中保存了对应当前数据库配置的所有映射关系，同时也负责维护当前的二级数据缓存和Statement Pool。由此可见，SessiongFactory的创建过程非常复杂，代价高昂。因此在系统设计中要考虑到SessionFactory的重用策略。</p>
<p>SessionFactory采用了线程安全的设计，可由多个线程并发调用，大多情况下，一个应用中针对一个数据库共享一个SessionFactory实例即可。</p>
<h3 id="3-Session">3.Session</h3>
<p>Session是hibernate持久化操作的基础。这里的session相当于JDBC中的Connection。</p>
<p>Session提供了众多持久化方法，可以透明的完成对象的CURD。</p>
<p>Session的设计是非线程安全的，一个Session只能由一个线程使用，多个线程使用一个Session将导致难以预知的错误。</p>
<p>Session由SessionFactory创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Configuration config = <span class="keyword">new</span> Configuration().configure();</div><div class="line">SessionFactory sessionFactory = config,buildSessionFactory();</div><div class="line">Session session =sessionFactory.openSession();</div></pre></td></tr></table></figure>

<p>接下来就可以使用session的方法完成持久层操作了。</p>
<ul>
<li>Save</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//新增用户记录</span></div><div class="line">TUser user = <span class="keyword">new</span> TUser();</div><div class="line">user.setName(<span class="string">"test"</span>);</div><div class="line">session.save(user);</div></pre></td></tr></table></figure>

<ul>
<li>Get</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取id=1的记录</span></div><div class="line">TUser user = (TUser)session.get(TUser.class,<span class="keyword">new</span> Integer(<span class="number">1</span>));</div></pre></td></tr></table></figure>

<ul>
<li>delete</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先取出，再删除</span></div><div class="line">TUser user = (TUser)session.get(TUser.class,<span class="keyword">new</span> Integer(<span class="number">1</span>));</div><div class="line">session.delete(user);</div><div class="line"></div><div class="line"><span class="comment">//通过Query接口进行基于HQL的删除操作</span></div><div class="line">String hql =<span class="string">"delete TUser where id =1"</span></div><div class="line">Query query = session.createQuery(hql);</div><div class="line">query.executeUpdate();</div></pre></td></tr></table></figure>

<ul>
<li>查询</li>
</ul>
<p>1.通过Query接口进行数据查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">String hql = <span class="string">"from TUser user where user.name like ?"</span>;</div><div class="line">Query query =session.createQuery(hql);</div><div class="line">query.setParameter(<span class="number">0</span>,<span class="string">"Cartier"</span>);</div><div class="line"></div><div class="line">List list = query.list();</div><div class="line"></div><div class="line">Iterator it = list.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext()){</div><div class="line">    TUser user = (TUser)it.next();</div><div class="line">    System.out.println(user.getName);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>2.通过Criteria接口进行数据查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Criteria criteria = session.createCriteria(TUser.class);</div><div class="line">criteria.add(Expression.eq(<span class="string">"name"</span>,<span class="string">"Cartier"</span>));</div><div class="line"></div><div class="line">List list = criteria.list();</div><div class="line"></div><div class="line">Iterator it = list.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext()){</div><div class="line">    TUser user = (TUser)it.next();</div><div class="line">    System.out.println(user.getName);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>两种查询方式的不同之处在于Query面向HQL和Native SQL，而Criteria则提供面向对象的查询模式。</p>
<h2 id="基础配置">基础配置</h2>
<h3 id="1-SessionFactory配置">1.SessionFactory配置</h3>
<p>配置方面就不作过多记录，很多文章都讲的很好了。</p>
<ul>
<li>数据库连接配置</li>
<li>数据库连接池配置<ul>
<li>默认数据库连接池</li>
<li>C3P0</li>
<li>dbcp</li>
<li>Proxool</li>
</ul>
</li>
</ul>
<h2 id="事务管理">事务管理</h2>
<p>为了使用Hibernate的Transaction API，我们必须通过hibernate.transaction.factory_class属性指定一个Transaction实例工厂类。Transaction API隐藏了底层的事务机制，允许Hibernate代码在受管制和非管制的环境下都可以运行。</p>
<h3 id="1-使用JDBC的事务处理机制">1.使用JDBC的事务处理机制</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hibernate.transaction.factory_class = net.sf.hibernate.transaction.JDBCTransactionFactory</div></pre></td></tr></table></figure>

<h3 id="2-使用JTA">2.使用JTA</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hibernate.transaction.factory_class = net.sf.hibernate.transaction.JTATransactionFactory</div><div class="line">jta.UserTransaction jta/usertransaction</div></pre></td></tr></table></figure>

<p>可选的配置项很多就不一一记录了。</p>
<h2 id="Hibernate_O/R_映射">Hibernate O/R 映射</h2>
<p>O/R映射是ORM框架中最为关键的组成部分。</p>
<h3 id="1-Hibernate基本数据类型">1.Hibernate基本数据类型</h3>
<p>integer是Hibernate基本数据类型之一。Hibernate中提供了丰富的数据类型支持，其中包括了传统的Java数据类型，如String ,Integer，以及JDBC数据类型，如Clob，Blob等。除此之外，Hibernate还提供用户自定义的数据类型支持。</p>
<p>Hibernate基本数据类型覆盖了日常开发中的绝大多数情况，它提供了传统数据库类型与Java数据类型之间的连接纽带。</p>
<h3 id="2-实体映射">2.实体映射</h3>
<p>下面介绍了实体映射由浅入深的顺序，分为三个部分：</p>
<ul>
<li><p>实体映射基础：介绍Hibernate中类/表映射。属性/字段映射的基本技术</p>
</li>
<li><p>高级映射技术：<br>较少自定义数据类型，复合主键，特殊字段的相关映射技术</p>
</li>
<li><p>实体映射策略：<br>围绕实体映射中实体粒度，层次的设计思路进行探讨，对特殊情况下与实体逻辑结构，实体读写性能相关的一些通用设计策略介绍。</p>
</li>
</ul>
<h4 id="2-1实体映射基础">2.1实体映射基础</h4>
<p>Hibernate中，类表映射主要包括三个部分：（1）类名-表名映射（2）主键映射（3）字段映射。具体配置现一般采用注解方式配置。</p>
<h4 id="2-2高级映射技术">2.2高级映射技术</h4>
<ul>
<li><strong>自定义数据类型：</strong>比如说一个用户可能需要保存多个Email地址信息，当然完全可以在一个String字段中保存一长串用;分割的字符串，但这样做起来不是很优雅，所以可以将email字段映射为一个List集合类型，但是Hibernate并没有提供原生的支持，这时候就需要实现自定义的数据类型了。</li>
<li><strong>复合主键：</strong>在实际开发中，可能一开始要求用户名不能重复，但是由于需求变更导致可以允许用户名相同，这时候为了减少更改库表的工作量，需要映入复合主键来解决问题。</li>
<li><strong>BLOB，CLOB字段的映射：</strong>例如在User表中，假设要为用户增加两个大型字段，其中image字段用于保存照片（Blog），resume字段用于保存建立（CLOB）。BLOB和CLOB的主要区别在于Blob字段采用单字节存储，适合保存二进制数据，如图片文件。Clob字段采用多字节存储，适合大型文本数据保存。</li>
<li><strong>实体映射策略：</strong>就是通过设计将各个部分进一步细分，得到更加细粒度的对象。<ul>
<li><strong><em>面向设计的粒度细分：</em></strong>通过对象细化，实现更加清晰的系统逻辑划分，体现出更加清晰合理的设计逻辑。</li>
<li><strong><em>面向性能的粒度细分：</em></strong>针对业务逻辑，通过合理的细粒度对象，提高系统的能耗比。当一个对象中有一个Blob这种重量级的数据时，当我们加载对象时，Hibernate会从库表中读取所有的字段数据，并构造相应的类实例返回。这样对于Blob这种数据就对读取操作的代价提高，如何避免这个问题，Hibernate提供了属性的延迟加载功能，通过这个功能，我们可以在调用TUser.getImage时才真正从数据库中读取数据，</li>
</ul>
</li>
<li><strong><em>实体层次设计：</em></strong> 继承关系是关系型数据库和面向对象数据结构之间的主要差异之一。Hibernate中支持3种类型的继承形式:<ul>
<li><strong>Table per concrete class:</strong>表与子表之间的独立一对一关系。</li>
<li><strong>Table per subclass:</strong> 每个子类对应一张子表，并与主类共享主表。</li>
<li><strong>Table per class hierarchy:</strong> 表与类的一对多关系。</li>
</ul>
</li>
</ul>
<h2 id="数据关联">数据关联</h2>
<p>对于ORM而言，一个非常关键的特性就是对实体之间关联关系的管理。数据关联是ORM的一个重要特性，但往往也是导致系统性能低下的原因。</p>
<h3 id="1-一对一关联">1.一对一关联</h3>
<p>一对一关联包括两种类型：</p>
<ul>
<li><strong><em>主键关联：</em></strong>即两张表通过主键形成一对一的映射关系。级联关系设置为all，级联（cascade）在Hibernate映射关系中是个非常重要的概念。它指的是当主控方执行操作时，关联对象（被动方）是否同步执行同一操作。如对主控对象调用save-update或delete方法时，是否同时对关联对象(被动方）进行save-update或delete，设定为all则代表无论主控方执行任何操作都对其关联类进行同样的操作。</li>
<li><strong><em>唯一外键关联:</em></strong> 在一个假定的权限管理系统示例中，每个用户都从属于一个用户组，用户表T_User中包含一个group_id字段，此字段与T_Group的id字段相关联，这就是典型的“唯一外键关联”。</li>
</ul>
<h3 id="2-一对多关联">2.一对多关联</h3>
<p>比如每个用户(T_User)都关联到多个地址(TAddress),如一个用户可能有多个电话等等，这样的话就反应为“一对多关联”。分为单一对关系和双向一对多关系。</p>
<ul>
<li><strong><em>单向一对多关联：</em></strong> 单向一对多的实现相对比较简单，但是存在一个问题，由于是单向关联，为了保持关联关系，我们只鞥通过主控方对被动方进行级联更新，如果被关联方的关联字段为“NOT NULL”，当Hibernate创建或者更新关联关系时，可能出现约束违例。</li>
<li><strong><em>双向一对多关联：</em></strong> 双向一对多关联实际上是一对多和多对一的组合，在主控方配置一对多，在被控方配置多对一。</li>
</ul>
<h3 id="3-多对多关联">3.多对多关联</h3>
<p>多对多关联需要借助中间表完成多对多映射信息的保存。但是多对多的性能不佳，应避免使用，应根据情况采用延迟加载机制来避免无谓的性能开销。</p>
<h2 id="Hibernate数据检索">Hibernate数据检索</h2>
<h3 id="1-Criteria_Query">1.Criteria Query</h3>
<p>Criteria Query通过面向对象化的设计，将数据查询条件封装成一个对象。简单来讲，Criteria Query可以看作是传统SQL的对象化表示,如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Criteria criteria = session.createCriteria(TUser.class);</div><div class="line">criteria.add(Expression.eq(<span class="string">"name"</span>,<span class="string">"Erica"</span>);</div><div class="line">criteria.add(Expression.eq(<span class="string">"sex"</span>,<span class="keyword">new</span> Integer(<span class="number">1</span>));</div></pre></td></tr></table></figure>

<p>这里的criteria实例本质上是对SQL “Select * from t_user where name = ‘Erica’ and sex =1”的封装。Hibernate会在运行期间根据Criteria中指定的查询条件(criteria.add方法添加的查询表达式)生成相应的SQL语句。这种方式对于SQL了解有限的程序员比较方便。</p>
<h4 id="Criteria查询表达式">Criteria查询表达式</h4>
<p>Criteria本身只是一个查询容器，具体的查询条件需要通过Criteria.add方法添加到Criteria实例中。</p>
<h4 id="示例查询">示例查询</h4>
<p>Example类实现了Criterion接口，同样它也可以座位Criteria的查询条件，Example的作用是：根据已有对象，查找属性与之相符的其他对象。</p>
<h3 id="复合查询">复合查询</h3>
<p>也就是查询多个条件的查询。</p>
<p>这里就不详细记录了。</p>
<h3 id="2-DetachedCriteria">2.DetachedCriteria</h3>
<p>在Hibernate2中，Criteria生命周期位于其宿主session生命周期之内，也就是所session销毁的话有它创建的Criteria实例也就失效了。</p>
<p>在Hibernate3中，提供了新的Criteria实现：DetachedCriteria。</p>
<p>DetachedCriteria可以脱离Session实例独立存在，这样我们就可以将某些通用的Criteria查询条件进行抽离，每次使用时再与当前Session实例绑定以获得更好的代码重用效果。</p>
<h4 id="Criteria高级特性">Criteria高级特性</h4>
<ul>
<li><strong>限定返回的记录范围:</strong> 通过criteria.setFirstResult/setMaxResult方法可以限制一次查询返回的记录范围。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Criteria criteria = session.createCriteria(TUser.class);</div><div class="line"><span class="comment">//限定查询返回检索结果中，从100条结果开始的20条记录</span></div><div class="line">criteria.setFirstResult(<span class="number">100</span>);</div><div class="line">criteria.setMaxResults(<span class="number">20</span>);</div></pre></td></tr></table></figure>

<p>记录排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查询所有groupId=2的记录，并分别按照姓名（顺序）和groupId（逆序）排序</span></div><div class="line">Criteria criteria = session.createCriteria(TUser.class);</div><div class="line"></div><div class="line">criteria.add(Expression.eq(<span class="string">"groupId"</span>,<span class="keyword">new</span> Integer(<span class="number">2</span>)));</div><div class="line"></div><div class="line">criteria.addOrder(Order.asc(<span class="string">"name"</span>));</div><div class="line">criteria.addOrder(Order.desc(<span class="string">"groupId"</span>));</div></pre></td></tr></table></figure>

<h4 id="Criteria综述">Criteria综述</h4>
<p>虽然这个比较简单，但是由于Hibernate实现过程中更加集中在HQL查询语言上，因此在实际开发中还是用官方推荐的HQL语句。</p>
<h3 id="3-Hibernate_Query_Language（HQL）">3.Hibernate Query Language（HQL）</h3>
<p>Criteria提供了符合面向对象编程风格的查询封装模式，不过HQL提供了更加丰富灵活的特性，它在涵盖了Criteria功能范围的前提下，提供了强大的查询能力。</p>
<p>完整的HQL 语法结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[select|update|delete ...] [from ...] [where ...] [group by ... [having ...] ] [order by ...]</div></pre></td></tr></table></figure>

<h2 id="HQL实用技术">HQL实用技术</h2>
<h3 id="1-实体查询">1.实体查询</h3>
<p>首先来一个最简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String hql = <span class="string">"from TUser"</span>;</div><div class="line">Query query = session.createQuery(hql);</div><div class="line">List userList = query.list();</div></pre></td></tr></table></figure>

<p>取出TUser的所有对应记录，其中在HQL中也可以采用全路径类名，特别在应用中有同类名但包名不同的情况。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"from com.zalezone.TUser"</span></div></pre></td></tr></table></figure>

<p><strong>注意：</strong>HQL子句本身大小写无关，但是区中出现的类名和属性名必须注意大小写区分。另外，需要注意的是，查询的目标实体存在着继承关系的判定， 如”from TUser”将返回所有TUser以及TUser子类的记录，假设系统中存在TUser的两个子类，TSysAdmin和TSysOperator，那么将返回包含两个子类的所有数据，即使两个子类的表分别对应了不同的库表。</p>
<p>如我们所知，Java中所有类都继承自java.lang.Object，那么如果这样查”from java.lang.Object”就会返回库表中所有库表的记录。</p>
<ul>
<li><strong>Where子句</strong><br>如果我们需要取出指定名称的记录，类似SQL，我们可以通过HQL语句加以限定:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String hql = <span class="string">"from TUser as user where user.name = 'Erica'"</span>;</div><div class="line">Query query = session.createQuery(hql);</div><div class="line">List userList = query.list();</div></pre></td></tr></table></figure>

<p>这里的as为类名创建了一个别名,as可以忽略，而where子句指定了限定条件。where子句中可以加许多限定如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from TUser user where user.age &gt;<span class="number">20</span></div><div class="line">from TUser user where user.age between <span class="number">20</span> and <span class="number">30</span></div><div class="line">from TUser user where user.age in (<span class="number">18</span>,<span class="number">28</span>)</div><div class="line">from TUser user where user.age is <span class="keyword">null</span></div><div class="line">from TUser user where user.name like <span class="string">'er%'</span> </div><div class="line"><span class="comment">//也可求算术表达式的值</span></div><div class="line">from TUser user where (user.age%<span class="number">2</span>=<span class="number">1</span>)</div><div class="line"><span class="comment">//可加and，or来连接各个表达式</span></div><div class="line">from TUser user where (user.age &gt;<span class="number">20</span>) and (user.name like <span class="string">'er%'</span>)</div></pre></td></tr></table></figure>

<h3 id="2-属性查询">2.属性查询</h3>
<p>有时候我们并不需要获取完整的实体对象，如在一个下拉框中显示用户名，我们可能只是需要某个属性就行，我们可以这样来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List list = session.createQuery(<span class="string">"select user.name from TUser user"</span>).list();</div><div class="line">Iterator it = list.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext())</div><div class="line">{</div><div class="line">    System.out.pringln(it.next());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里我们只指定获取name属性一个String类型。如果要获取多个属性的话如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List list = session.createQuery(<span class="string">"select user.name，user.age from TUser user"</span>).list();</div><div class="line">Iterator it = list.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext())</div><div class="line">{</div><div class="line">    Object[] results =(Object[])it.next();</div><div class="line">    System.out.println(results[<span class="number">0</span>]);</div><div class="line">    System.out.println(results[<span class="number">1</span>]);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果觉得返回数组的方式不符合面向对象的风格，可以在HQL中动态的构造对象实例的方法对这些平面化的数据进行封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List list = session.createQuery(<span class="string">"select new TUser(user.name,user.age) from TUser user"</span>).list();</div><div class="line">Iterator it = list.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext())</div><div class="line">{</div><div class="line">    TUser user = (TUser)it.next();</div><div class="line">    System.out.pringtln(user.getName());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过在HQL中动态的构造对象实例，我们实现了对查询结果的对象化封装。注意此时在查询结果中的TUser对象仅仅是一个普通的Java对象，仅用于对查询结果的封装，出了在构造是赋予的属性值外，其他属性均为未赋值的状态，这也就意味着我们无法通过Session对此对象进行更新，下面代码中，对user对象的更新将导致向数据库中插入一条新的记录，而不是更新原有的记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List list = session.createQuery(<span class="string">"select new TUser(user.name,user.age) from TUser user"</span>).list();</div><div class="line">Iterator it = list.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext())</div><div class="line">{</div><div class="line">    TUser user = (TUser)it.next();</div><div class="line">    user.setName(“test”);</div><div class="line">    session.saveOrUpdate(user);<span class="comment">//这里将导致一次insert操作，而非update</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>另外，我们也可以在HQL中的Select子句中使用统计函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List list = session.createQuery(<span class="string">"select count(*),min(user.age) from TUser user"</span>).list();</div><div class="line">Iterator it = list.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext())</div><div class="line">{</div><div class="line">    Object[] results =(Object[])it.next();</div><div class="line">    System.out.println(results[<span class="number">0</span>]);</div><div class="line">    System.out.println(results[<span class="number">1</span>]);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>甚至原生SQL函数如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select upper(user.name) from TUser user;</div><div class="line">select distinct user.name from TUser user;</div></pre></td></tr></table></figure>

<h3 id="3-实体更新与删除">3.实体更新与删除</h3>
<p>在Hibernate3中HQL具备了更加强大的功能，其中实体更新和删除是主要特性之一。在2中是先加载实体在更改保存，在hibernate3中的话HQL提供了更加灵活便捷的实现方式。（bulk delete/update）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Transaction tx = session.beginTransaction();</div><div class="line">String hql = <span class="string">"update TUser set age =18 where id =1"</span>;</div><div class="line">Query query = session.createQuery(hql);</div><div class="line">query.executeUpdate();</div><div class="line">tx.commit();</div></pre></td></tr></table></figure>

<p>虽然在对单个对象更新时代码没有减少多少，但是对与批量性更新操作时便捷性和性能提高就很可观。</p>
<p>HQL的delete子句的使用同样非常简单，以下代码删除了所有年龄大于18的用户记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Transaction tx = session.beginTransaction();</div><div class="line">String hql = <span class="string">"update TUser set age =18 where age &gt;18"</span>;</div><div class="line">Query query = session.createQuery(hql);</div><div class="line">query.executeUpdate();</div><div class="line">tx.commit();</div></pre></td></tr></table></figure>

<p><strong>注意:</strong>在使用HQL的delte/update子句时，我们必须特别注意它们对缓存策略的影响，delete/update子句极有可能导致缓存同步上的障碍。</p>
<p>总体来看，Hibernate3中的HQL功能已越来越全面，与SQL不同的是，SQL面向的是二维的结构化数据，而HQL则面向数据对象。在对象型数据库尚不成熟时，通过面向对象的查询语言对关系型数据库进行访问，既满足了上层结构中面向对象设计的需求，也充分利用了现有技术平台，这也是Hibernate的优势。</p>
<h3 id="4-分组与排序">4.分组与排序</h3>
<ul>
<li><p><strong>Order by子句</strong></p>
<p>  与SQL类似，HQL通过order by子句对查询结果排序如：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from TUser user order by user.name,user.age desc</div></pre></td></tr></table></figure>

<ul>
<li><p><strong>Group by子句(having 子句)</strong></p>
<p>  用Group by对子句进行分组统计,如下我们通过Group by子句实现了同龄用户的统计：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List list = session.createQuery(<span class="string">"select count(user),user.age from TUser user group by user.age having count(user)&gt;10"</span>).list();</div><div class="line">Iterator it = list.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext())</div><div class="line">{</div><div class="line">    Object[] results =(Object[])it.next();</div><div class="line">    System.out.println(results[<span class="number">0</span>]);</div><div class="line">    System.out.println(results[<span class="number">1</span>]);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="5-参数绑定">5.参数绑定</h3>
<p>如上面的许多Hql语句我们可以看到里面的参数都是直接写在里面的，如果要求查询的参数是变量，直接用变量名代替变量如“from TUser user where user.age&gt;” + age;进行HQL拼接的话虽然能实现功能，但是会存在如下缺陷：</p>
<ul>
<li><strong>编码更加凌乱，可读性降低:</strong> 如果存在很多很多的查询参数将混乱无序。</li>
<li><strong>难以进行性能优化:</strong>根据JDBC以及数据库的操作原理可知每次SQL执行时，数据库都将对SQL语句进行解析和优化，并将其处理结果保存在缓存中，如果以后有参数不同，语法相同的SQL命令，则直接以此缓存结果加以执行，从而避免了SQL解析和优化的开销，另外从Hibernate角度而言，它使用了PreparedStatement作为底层数据库访问手段，对于相同的SQL，也可以重用以及创建的PrepareStatement，这样如果将参数写在SQL中，将导致每次提交的SQL语句都不同，从系统角度而言不同参数将导致判断为是两个不同的SQL命令，（有些数据库相同内容的SQL大小写不同也视为是不同的SQL命令），从而会将其视为一个全新的SQL语法进行处理，缓存无法得到利用，导致了性能优化策略失效。</li>
<li><strong>引入额外的安全风险：</strong>最常见的就是SQL 注入攻击了，就是针对这些SQL字符拼装造成的漏洞。</li>
</ul>
<p>参数的动态绑定机制可以妥善的处理好以上问题。类似JDBC的SQL操作，我们可以通过顺序占位符“？”对参数进行标识，并在之后对参数内容进行填充，如：</p>
<ul>
<li>在Session.find方法（Hibernate2）中填充参数：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session.find(<span class="string">"from TUser user where user.name=?"</span>,<span class="string">"Erica"</span>,Hibernate.STRING);</div></pre></td></tr></table></figure>

<p>多参数的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object[] args = <span class="keyword">new</span> Object[]{<span class="string">"Erica"</span>,<span class="keyword">new</span> Integer(<span class="number">20</span>)};</div><div class="line">Type[] types = <span class="keyword">new</span> Type[]{Hibernate,STRING,Hibernate.INTEGER};</div><div class="line">session.find(<span class="string">"from TUser user where user.name=? and user.age &gt; ?"</span>,args,types);</div></pre></td></tr></table></figure>

<ul>
<li>通过Query接口进行参数填充：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Query query = session.createQuery(<span class="string">"from TUser user where user.name =? and user.age&gt;?"</span>);</div><div class="line">query.setString(<span class="number">0</span>,<span class="string">"Erica"</span>);</div><div class="line">query.setInteger(<span class="number">1</span>,<span class="number">20</span>);</div></pre></td></tr></table></figure>

<p>除了用顺序占位符外，Hibernate还支持引用占位符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String hql = <span class="string">"from TUser where name = :name"</span>;</div><div class="line">Query query = session.createQuery(hql);</div><div class="line">query.setParameter(<span class="string">"name"</span>,<span class="string">"Erica"</span>);</div><div class="line">Iterator it = query.iterate();</div><div class="line"><span class="keyword">while</span>(it.hasNext()){</div><div class="line">    TUser user = (TUser)it.next();</div><div class="line">    System.out.pringln(user.getName());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>以上的:name即所谓的引用占位符，它标识了一个名为“name”的查询参数，通过session.createQuery方法构造Query实例后，我们即可以根据此参数名进行参数填充。另外，我们也可以用一个JavaBean封装查询参数。</p>
<p>参数绑定机制可以使得查询语法与具体的参数数值相互独立，这样，对于参数不同，查询语法相同的查询操作，数据库即可以实施性能优化策略，同时，参数绑定机制也杜绝了参数值对查询语法本身的影响，避免SQL注入。</p>
<h3 id="6-引用查询">6.引用查询</h3>
<p>有时候会碰到如下编码规范，规定在代码中不允许出现SQL语句，总之，为了避免SQL语句混杂在代码之间，我们可以采取将SQL保存在配置文件中，需要调用的时候再进行读取。Hibernate提供了HQL可配置化的内置支持。</p>
<h3 id="7-联合查询">7.联合查询</h3>
<p>SQL通过join子句实现多表之间的联合查询，HQL提供以下几种联合查询机制：</p>
<ol>
<li>inner join</li>
<li>left outer join</li>
<li>right outer join</li>
<li>full join(not usually useful)</li>
</ol>
<p>这里的概念就是数据库中的连接问题，inner join类似于自然连接，对于Inner join：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from TUser user inner join fetch user.address</div></pre></td></tr></table></figure>

<p>等于执行了一下语句：select … from T_User user inner join TAddress addr on user.id =addr.userid</p>
<p>注意到上面HQL语句中的“fetch”关键字表明TAddress对象读出后立即填充到对应的TUser对象中。如果忽略fetch关键字，则在得到的结果集中，每个条目都是一个Object数组，其中包括了一个TUser对象以及对应的TAddress对象。另外，SQL中的on user.id = addr.user_id对于关系在映射文件指定了，所以HQL并没有对应表现。注意fetch关键字只对inner join和left join有效，对于right join而言，由于作为对象容器的TUser对象可能为null，所以也就无法通过fetch关键字强制Hibernate进行集合填充操作。右连接的话就将对象取出然后进行操作。</p>
<h3 id="8-子查询">8.子查询</h3>
<p>HQL同样支持子查询，假设我们需要从一个结果中提取出拥有两条及以上地址信息的TUser对象，那么我们可以这样写HQL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from TUser user where (select count(*) from user.addresses)&gt;<span class="number">1</span></div></pre></td></tr></table></figure>

<p>HQL中，子查询必须出现在where子句中，且必须以一对圆括号包围。</p>
<h3 id="9-数据加载方式">9.数据加载方式</h3>
<p>Hibernate支持以下几种数据加载方式：</p>
<ol>
<li><p><strong>即时加载（Immediate Loading）</strong></p>
<p> 当实体加载完成后，立即加载其关联数据。</p>
</li>
<li><p><strong>延迟加载（Lazy Loading）</strong></p>
<p> 实体加载时，其关联数据并非即刻获取，而是当关联数据第一次被访问时再进行读取。</p>
</li>
<li><p><strong>预先加载（Eager Loading）</strong></p>
<p> 预先加载时，实体及其关联对象同时读取，这与即时加载类似，不过实体及其关联数据是通过一条SQL语句（基于外连接[outer join]）同时读取。</p>
</li>
<li><p><strong>批量加载（Batch Loading）</strong></p>
<p> 对于即时加载和延迟加载，可以采用批量加载的方式进行性能上的优化。就是通过批量提交多个限定条件，一次完成多个数据的读取。如果使用了批量加载机制，Hibernate在进行数据查询操作前，会自动在当前的session中寻找是否还有其他同类型待加载数据，如果有，则将其查询条件合并在当前的select语句中一并提交，这样，通过一次数据库操作即完成了多个读取任务。</p>
</li>
</ol>
<h2 id="10-SQL查询">10.SQL查询</h2>
<p>由于SQL语法本身的庞杂，以及各种数据库原生功能的多样性，HQL不能涵盖所有查询特性，有时候我们不得不借助原生的SQL或存储过程来达到我们的目标。</p>
<p>Hibernate提供了对原生SQL以及存储过程（Hibernate3）的支持，相对于基于JDBC的SQL操作，Hibernate提供了更为妥善的封装。在Hibernate SQL查询接口中，我们只需要指定别名，而ResultSet与实体的映射将由Hibernate自动完成。从一个简单的例子入手：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Select * from TUser where name = <span class="string">'Erica'</span></div></pre></td></tr></table></figure>

<p>上面的sql从表中返回特定名字的记录。如何通过HQL调用这条SQL语句，并返回对应的TUser对象？如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String sql = <span class="string">"select {user.*} from TUser user"</span>;</div><div class="line">List list = session.createSQLQuery(sql,<span class="string">"usr"</span>,TUser.class).list();</div><div class="line">Iterator it = list.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext){</div><div class="line">    TUser user = (TUser)it.next();</div><div class="line">    System.out.println(user.getName());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的SQL片段“select u.id as {usr.id}”,其中u是SQL中TUser表的别名，而usr是我们指定的实体对象别名。在session.createSQLQuery(sql,”usr”,TUser.class)方法中，我们将待执行的SQL传入，并指定其实体对象别名为usr，实体对象类型为TUser.class,这样，Hibernate就会根据在SQL中的别名配置，将返回的ResultSet映射到对应的实体对象实例返回。</p>
<h2 id="11-自定义持久化实现">11.自定义持久化实现</h2>
<p>简单来说就是运行自己定义持久化的实现机制。</p>


</div>
    <footer class="article-footer">
      <a data-url="http://zalezone.cn/2015/04/26/hibernate/" data-id="9e0l1uhesy65jzcu" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hibernate/">hibernate</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据持久化/">数据持久化</a></li></ul>

    </footer>

<!-- baidu start -->
<div style="padding-left:30px;"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a></div></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<div id="gbook" style="padding-left:20px;padding-right:20px;">
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="hibernate" data-title="hibernate入门" data-url="http://zalezone.cn/2015/04/26/hibernate/"></div>
<!-- 多说评论框 end -->
</div>




  
<nav id="article-nav">
  
    <a href="/2015/05/13/hibernate高级特性/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hibernate高级特性
        
      </div>
    </a>
  
  
    <a href="/2015/04/22/Android自定义ActionBar/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android自定义ActionBar</div>
    </a>
  
</nav>



      
  </div>
</article>
</section>
        
          <aside id="sidebar">
  
    
<div class="widget-wrap">
<h3 class="widget-title">ABOUT ME</h3>
<ul class="widget about-me">

<li><img class="author" title="About me" src="/image/touxiang2.jpg" /></li>


<li>name->    zale</li>

<li>Job->     student</li>

<li>Email->   1433317488@qq.com</li>


</ul>
</div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web前端/">web前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/人生轨迹/">人生轨迹</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/07/13/翻墙攻略（二）/">翻墙攻略（二）</a>
          </li>
        
          <li>
            <a href="/2015/05/16/Android-NDK入门/">Android NDK 入门</a>
          </li>
        
          <li>
            <a href="/2015/05/13/hibernate高级特性/">Hibernate高级特性</a>
          </li>
        
          <li>
            <a href="/2015/04/26/hibernate/">hibernate入门</a>
          </li>
        
          <li>
            <a href="/2015/04/22/Android自定义ActionBar/">Android自定义ActionBar</a>
          </li>
        
          <li>
            <a href="/2015/03/15/java垃圾回收机制/">java垃圾回收机制</a>
          </li>
        
          <li>
            <a href="/2015/02/15/适配器模式/">适配器模式</a>
          </li>
        
          <li>
            <a href="/2015/01/01/newStart/">再见2014，你好2015</a>
          </li>
        
          <li>
            <a href="/2014/12/06/Angularjs/">AngularJS</a>
          </li>
        
          <li>
            <a href="/2014/11/16/单例模式/">单例模式</a>
          </li>
        
          <li>
            <a href="/2014/11/12/观察者模式/">观察者模式</a>
          </li>
        
          <li>
            <a href="/2014/10/26/java自制线程池/">java自制线程池</a>
          </li>
        
          <li>
            <a href="/2014/10/22/Android编译执行C代码/">android 编译调用C代码</a>
          </li>
        
          <li>
            <a href="/2014/09/29/不要怪老天不公平/">不要怪老天不公平</a>
          </li>
        
          <li>
            <a href="/2014/09/25/Android侧拉菜单SlidingMenu的配置和使用/">Android侧拉菜单SlidingMenu的配置和使用</a>
          </li>
        
          <li>
            <a href="/2014/09/17/NIO精粹/">java NIO详解</a>
          </li>
        
          <li>
            <a href="/2014/09/08/linux翻墙攻略/">linux翻墙攻略</a>
          </li>
        
          <li>
            <a href="/2014/08/24/暑假之末/">暑假之末</a>
          </li>
        
          <li>
            <a href="/2014/08/13/git使用小记/">Git使用小记</a>
          </li>
        
          <li>
            <a href="/2014/08/13/正则表达式基础/">正则表达式基础</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        <ul>
<li><a href="http://blog.csdn.net/u012457196" target="_blank" title="csdn">CSDN</a></li>
<li><a href="http://user.qzone.qq.com/1433317488" target="_blank" title="qqzone">qq空间</a></li>
	  	</ul>
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ActionBarSherlock/" style="font-size: 10.00px;">ActionBarSherlock</a><a href="/tags/AngularJS/" style="font-size: 10.00px;">AngularJS</a><a href="/tags/C/" style="font-size: 10.00px;">C</a><a href="/tags/DIY/" style="font-size: 10.00px;">DIY</a><a href="/tags/GFW/" style="font-size: 10.00px;">GFW</a><a href="/tags/Hibernate/" style="font-size: 10.00px;">Hibernate</a><a href="/tags/JDK/" style="font-size: 10.00px;">JDK</a><a href="/tags/NDK/" style="font-size: 10.00px;">NDK</a><a href="/tags/NIO/" style="font-size: 10.00px;">NIO</a><a href="/tags/SlidingMenu/" style="font-size: 10.00px;">SlidingMenu</a><a href="/tags/UI/" style="font-size: 13.33px;">UI</a><a href="/tags/VPS主机/" style="font-size: 10.00px;">VPS主机</a><a href="/tags/actionBar/" style="font-size: 10.00px;">actionBar</a><a href="/tags/android/" style="font-size: 16.67px;">android</a><a href="/tags/assets/" style="font-size: 10.00px;">assets</a><a href="/tags/git/" style="font-size: 10.00px;">git</a><a href="/tags/goagent/" style="font-size: 10.00px;">goagent</a><a href="/tags/hibernate/" style="font-size: 10.00px;">hibernate</a><a href="/tags/java/" style="font-size: 20.00px;">java</a><a href="/tags/javascript/" style="font-size: 10.00px;">javascript</a><a href="/tags/life/" style="font-size: 10.00px;">life</a><a href="/tags/linux/" style="font-size: 13.33px;">linux</a><a href="/tags/shadowsocks/" style="font-size: 10.00px;">shadowsocks</a><a href="/tags/web前端/" style="font-size: 10.00px;">web前端</a><a href="/tags/不公平/" style="font-size: 10.00px;">不公平</a><a href="/tags/交叉编译/" style="font-size: 10.00px;">交叉编译</a><a href="/tags/代理服务器/" style="font-size: 10.00px;">代理服务器</a><a href="/tags/代码管理/" style="font-size: 10.00px;">代码管理</a><a href="/tags/侧拉菜单/" style="font-size: 10.00px;">侧拉菜单</a><a href="/tags/内存管理/" style="font-size: 10.00px;">内存管理</a><a href="/tags/创建类模式/" style="font-size: 10.00px;">创建类模式</a><a href="/tags/单例模式/" style="font-size: 10.00px;">单例模式</a><a href="/tags/垃圾回收/" style="font-size: 10.00px;">垃圾回收</a><a href="/tags/心态/" style="font-size: 10.00px;">心态</a><a href="/tags/性能/" style="font-size: 10.00px;">性能</a><a href="/tags/数据库/" style="font-size: 10.00px;">数据库</a><a href="/tags/数据持久化/" style="font-size: 10.00px;">数据持久化</a><a href="/tags/正则表达式/" style="font-size: 10.00px;">正则表达式</a><a href="/tags/线程池/" style="font-size: 10.00px;">线程池</a><a href="/tags/结构性模式/" style="font-size: 10.00px;">结构性模式</a>
      
    </div>
  </div>




  
</aside>
        
      </div>
      
<footer id="footer">
  

  <div class="outer">


  <div class="outer">

    <div id="footer-info" class="inner">
<style type="text/css">
   #ds-recent-visitors .ds-avatar {
    float: left;
</style>
<ul class="ds-recent-visitors" data-num-items="0"></ul>
</div>



<div id="footer-info" class="inner">
      &copy; 2015 zale
<br>


    </div>
  </div>



</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">存档</a>
  
</nav>
    <script src="/js/jquery-2.1.1.min.js"></script>

<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"zalezone"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->

<div id="scroll2top" style="position:fixed;bottom:150px;right:50px;cursor: pointer;Z-index:9999">
<a title="返回顶部" href="#"><img src="/scroll2top/scrollup.png"/></a>
</div>
<script src="/scroll2top/scroll2top.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">(function() {var s = document.getElementsByTagName("script")[0],rdb = document.createElement("script"); rdb.type = "text/javascript"; rdb.async = true; rdb.src = document.location.protocol + "//www.readability.com/embed.js"; s.parentNode.insertBefore(rdb, s); })();</script>


<script src="/js/script.js" type="text/javascript"></script>




  </div>
</body>
</html>