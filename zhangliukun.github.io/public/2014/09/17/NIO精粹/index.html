<!DOCTYPE html>
<html>



<head>
  <meta charset="utf-8">
  
  <title>java NIO详解 | Zale Zone</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言
我们在写java程序的时候，为了进行优化，把全部的精力用在了处理效率上，但是对IO的关注却很少。这也可能是由以前java早期时JVM在解释字节码时速度慢，运行速率大大低于本地编译代码，因此以前往往忽视了IO的优化。   
但是现在JVM在运行时优化已前进了一大步，现在的java应用程序更多的是受IO的束缚，也就是将时间花在等待数据传输上。现在有了NIO，就可以减少IO的等待时间，从而提升I">
<meta property="og:type" content="article">
<meta property="og:title" content="java NIO详解">
<meta property="og:url" content="http://zalezone.cn/2014/09/17/NIO精粹/">
<meta property="og:site_name" content="Zale Zone">
<meta property="og:description" content="前言
我们在写java程序的时候，为了进行优化，把全部的精力用在了处理效率上，但是对IO的关注却很少。这也可能是由以前java早期时JVM在解释字节码时速度慢，运行速率大大低于本地编译代码，因此以前往往忽视了IO的优化。   
但是现在JVM在运行时优化已前进了一大步，现在的java应用程序更多的是受IO的束缚，也就是将时间花在等待数据传输上。现在有了NIO，就可以减少IO的等待时间，从而提升I">
<meta property="og:image" content="/image/javaboy.jpg">
<meta property="og:image" content="/image/javaNIO.png">
<meta property="og:image" content="/image/Bytebuffer.png">
<meta property="og:image" content="/image/channel.png">
<meta property="og:image" content="/image/Selector.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java NIO详解">
<meta name="twitter:description" content="前言
我们在写java程序的时候，为了进行优化，把全部的精力用在了处理效率上，但是对IO的关注却很少。这也可能是由以前java早期时JVM在解释字节码时速度慢，运行速率大大低于本地编译代码，因此以前往往忽视了IO的优化。   
但是现在JVM在运行时优化已前进了一大步，现在的java应用程序更多的是受IO的束缚，也就是将时间花在等待数据传输上。现在有了NIO，就可以减少IO的等待时间，从而提升I">

  
    <link rel="alternative" href="/atom.xml" title="Zale Zone" type="application/atom+xml">
  
  
    <link rel="icon" href="/z.png">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->


  <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F5775b426920e4c5be15841fdaf67886f' type='text/javascript'%3E%3C/script%3E"));
</script>







<style type="text/css">
@font-face {
  font-family: 'Source Code Pro';
  font-style: normal;
  font-weight: 400;
  src: local('Source Code Pro'), local('SourceCodePro-Regular'), url(/font/SourceCodePro-Regular.ttf) format('ttf');
}
</style>

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zale Zone</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">不愿冒险的人，通常只能选择别人剩下的东西</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">存档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://zalezone.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-NIO精粹" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/17/NIO精粹/" class="article-date">
  <time datetime="2014-09-17T07:39:00.000Z" itemprop="datePublished">9月 17 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>


<div class="rdbWrapper" style="float:left;position:relative;bottom:6px;" data-version="1" data-orientation="0" data-show-email="0" data-show-print="0" data-show-send-to-kindle="1" data-show-read-later="0" data-show-read-now="0"></div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java NIO详解 <span style='color:#999;font:12px "Helvetica Neue",Helvetica,Arial,sans-serif;'><span class="ds-thread-count" data-thread-key="NIO精粹" data-count-type="comments"></span>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
          

<!-- toc -->

	<div id="toc" class="toc-article">
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java_NIO的思维导图:"><span class="toc-number">1.1.</span> <span class="toc-text">java NIO的思维导图:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM利弊"><span class="toc-number">1.1.1.</span> <span class="toc-text">JVM利弊</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO原理"><span class="toc-number">2.</span> <span class="toc-text">NIO原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO与IO的区别"><span class="toc-number">2.1.</span> <span class="toc-text">NIO与IO的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓冲区Buffer"><span class="toc-number">2.2.</span> <span class="toc-text">缓冲区Buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通道Channel"><span class="toc-number">2.3.</span> <span class="toc-text">通道Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通道特性"><span class="toc-number">2.3.1.</span> <span class="toc-text">通道特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择器Selector"><span class="toc-number">2.4.</span> <span class="toc-text">选择器Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#传统的socket监控"><span class="toc-number">2.4.1.</span> <span class="toc-text">传统的socket监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择器属性"><span class="toc-number">2.4.2.</span> <span class="toc-text">选择器属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#键对象"><span class="toc-number">2.4.3.</span> <span class="toc-text">键对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#停止选择过程"><span class="toc-number">2.4.4.</span> <span class="toc-text">停止选择过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简单的NIO服务器"><span class="toc-number">2.5.</span> <span class="toc-text">简单的NIO服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理解释"><span class="toc-number">2.5.1.</span> <span class="toc-text">原理解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发性"><span class="toc-number">2.6.</span> <span class="toc-text">并发性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择过程的可扩展性"><span class="toc-number">2.7.</span> <span class="toc-text">选择过程的可扩展性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务线程池服务器示例"><span class="toc-number">2.8.</span> <span class="toc-text">服务线程池服务器示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用线程池来为通道提供服务"><span class="toc-number">2.8.1.</span> <span class="toc-text">使用线程池来为通道提供服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理解释-1"><span class="toc-number">2.8.2.</span> <span class="toc-text">原理解释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
	</div>

<p><img src="/image/javaboy.jpg" alt="javaNIO"></p>
<h1 id="前言">前言</h1>
<p>我们在写java程序的时候，为了进行优化，把全部的精力用在了处理效率上，但是对IO的关注却很少。这也可能是由以前java早期时JVM在解释字节码时速度慢，运行速率大大低于本地编译代码，因此以前往往忽视了IO的优化。   </p>
<p>但是现在<a href="http://baike.baidu.com/view/160708.htm" target="_blank" rel="external">JVM</a>在运行时优化已前进了一大步，现在的java应用程序更多的是受IO的束缚，也就是将时间花在等待数据传输上。现在有了<a href="http://baike.baidu.com/view/1007976.htm?from_id=13029359&amp;type=syn&amp;fromtitle=java+nio&amp;fr=aladdin" target="_blank" rel="external">NIO</a>，就可以减少<a href="http://baike.baidu.com/subview/1142749/5362454.htm" target="_blank" rel="external">IO</a>的等待时间，从而提升IO的效率。</p>
<p><a id="more"></a></p>
<h2 id="java_NIO的思维导图:">java NIO的思维导图:</h2>
<p><img src="/image/javaNIO.png" alt="javaNIO"></p>
<h3 id="JVM利弊">JVM利弊</h3>
<p>JVM 是把双刃剑。它提供了统一的操作环境,让 Java 程序员不用再为操作系统环境的区别而烦恼。与特定平台相关的细枝末节大都被隐藏了起来,因而代码写得又快又容易。但是隐藏操作系统的技术细节也意味着某些个性鲜明、功能强大的特性被挡在了门外。</p>
<p>怎么办呢?如果您是程序员,可以使用 Java 本地接口(<a href="http://baike.baidu.com/view/1272329.htm" target="_blank" rel="external">JNI</a>)编写本地代码,直接使用操作系统特性。这样的话，不同的操作系统的局限性就体现出来了。为了解决这一问题,java.nio 软件包提供了新的抽象。具体地说,就是 Channel 和 Selector类。它们提供了使用 I/O 服务的通用 API,JDK 1.4 以前的版本是无法使用这些服务的。天下还是没有免费的午餐:您无法使用每一种操作系统的每一种特性,但是这些新类还是提供了强大的新框架,涵盖了当今商业操作系统普遍提供的高效 I/O 特性。不仅如此,java.nio.channels.spi还提供了新的服务提供接口(SPI),允许接入新型通道和选择器,同时又不违反规范的一致性。</p>
<p>随着 NIO 的面世,Java 已经为严肃的商业、娱乐、科研和学术应用做好了准备。在这些领域,高性能 I/O 是必不可少的。</p>
<h1 id="NIO原理">NIO原理</h1>
<h2 id="NIO与IO的区别">NIO与IO的区别</h2>
<p>首先来讲一下传统的IO和NIO的区别，传统的IO又称BIO，即阻塞式IO，NIO就是非阻塞IO了。还有一种<a href="http://stevex.blog.51cto.com/4300375/1284437" target="_blank" rel="external">AIO</a>就是异步IO，这里不加阐述了。</p>
<p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h2 id="缓冲区Buffer">缓冲区Buffer</h2>
<p>一个Buffer对象是固定数量的数据的容器。其作用是一个存储器,或者分段运输区,在这里数据可被存储并在之后用于检索。尽管缓冲区作用于它们存储的原始数据类型,但缓冲区十分倾向于处理字节。非字节缓冲区可以在后台执行从字节或到字节的转换,这取决于缓冲区是如何创建的。</p>
<p>缓冲区的工作与通道紧密联系。通道是 I/O 传输发生时通过的入口,而缓冲区是这些数据传输的来源或目标。对于离开缓冲区的传输,您想传递出去的数据被置于一个缓冲区,被传送到通道。对于传回缓冲区的传输,一个通道将数据放置在您所提供的缓冲区中。这种在协同对象(通常是您所写的对象以及一到多个 Channel 对象)之间进行的缓冲区数据传递是高效数据处理的关键。</p>
<p>以下是一个新创建的ByteBuffer:<br><img src="/image/Bytebuffer.png" alt="ByteBuffer"></p>
<p>位置被设为 0,而且容量和上界被设为 10,刚好经过缓冲区能够容纳的最后一个字节。标记最初未定义。容量是固定的,但另外的三个属性可以在使用缓冲区时改变。</p>
<p>其中的四个属性的含义分别如下：</p>
<ul>
<li>容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。这一个容量在缓冲区创建时被设定，并且永远不能改变。</li>
<li>上界(Limit)：缓冲区的第一个不能被读或写的元素。或者说,缓冲区中现存元素的计数。</li>
<li>位置(Position)：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。</li>
<li>标记(Mark)：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。</li>
</ul>
<p><strong>Buffer的常见方法</strong>如下所示:</p>
<ul>
<li>flip(): 写模式转换成读模式</li>
<li>rewind()：将 position 重置为 0 ，一般用于重复读。</li>
<li>clear() ：清空 buffer ，准备再次被写入 (position 变成 0 ， limit 变成 capacity) 。</li>
<li>compact(): 将未读取的数据拷贝到 buffer 的头部位。</li>
<li>mark(): reset():mark 可以标记一个位置， reset 可以重置到该位置。</li>
<li>Buffer 常见类型： ByteBuffer 、 MappedByteBuffer 、 CharBuffer 、 DoubleBuffer 、 FloatBuffer 、 IntBuffer 、 LongBuffer 、 ShortBuffer 。 </li>
</ul>
<h2 id="通道Channel">通道Channel</h2>
<p>通道(Channel)是 java.nio 的第二个主要创新。它们既不是一个扩展也不是一项增强,而是全新、极好的 Java I/O 示例,提供与 I/O 服务的直接连接。Channel 用于在字节缓冲区和位于通道另一侧的实体(通常是一个文件或套接字)之间有效地传输数据。</p>
<p>通道是一种途径,借助该途径,可以用最小的总开销来访问操作系统本身的 I/O 服务。缓冲区则是通道内部用来发送和接收数据的端点。通道channel充当连接I/O服务的导管，入下图所示<img src="/image/channel.png" alt="channel"></p>
<h3 id="通道特性">通道特性</h3>
<p>通道可以是单向或者双向的。一个 channel 类可能实现定义read( )方法的 ReadableByteChannel 接口,而另一个 channel 类也许实现 WritableByteChannel 接口以提供 write( )方法。实现这两种接口其中之一的类都是单向的,只能在一个方向上传输数据。如果一个类同时实现这两个接口,那么它是双向的,可以双向传输数据。</p>
<p>每一个 file 或 socket 通道都实现全部三个接口。从类定义的角度而言,这意味着全部 file 和 socket 通道对象都是双向的。这对于 sockets 不是问题,因为它们一直都是双向的,不过对于 files 却是个问题了。我们知道,一个文件可以在不同的时候以不同的权限打开。从 FileInputStream 对象的getChannel( )方法获取的 FileChannel 对象是只读的,不过从接口声明的角度来看却是双向的,因为FileChannel 实现 ByteChannel 接口。在这样一个通道上调用 write( )方法将抛出未经检查的NonWritableChannelException 异常,因为 FileInputStream 对象总是以 read-only 的权限打开文件。</p>
<p>通道会连接一个特定 I/O 服务且通道实例(channel instance)的性能受它所连接的 I/O 服务的特征限制,记住这很重要。一个连接到只读文件的 Channel 实例不能进行写操作,即使该实例所属的类可能有 write( )方法。基于此,程序员需要知道通道是如何打开的,避免试图尝试一个底层 I/O服务不允许的操作。</p>
<p>通道可以以阻塞(blocking)或非阻塞(nonblocking)模式运行。非阻塞模式的通道永远不会让调用的线程休眠。请求的操作要么立即完成,要么返回一个结果表明未进行任何操作。只有面向流的(stream-oriented)的通道,如 sockets 和 pipes 才能使用非阻塞模式。</p>
<h2 id="选择器Selector">选择器Selector</h2>
<p>选择器提供选择执行已经就绪的任务的能力，这使得多元I/O成为可能，就绪选择和多元执行使得单线程能够有效率的同时管理多个I/O通道（channels），简单言之就是selector充当一个监视者，您需要将之前创建的一个或多个可选择的通道注册到选择器对象中。一个表示通道和选择器的键将会被返回。选择键会记住您关心的通道。它们也会追踪对应的通道是否已经就绪当您调用一个选择器对象的 select( )方法时,相关的键会被更新,用来检查所有被注册到该选择器的通道。您可以获取一个键的集合,从而找到当时已经就绪的通道。通过遍历这些键,您可以选择出每个从上次您调用 select( )开始直到现在,已经就绪的通道。</p>
<h3 id="传统的socket监控">传统的socket监控</h3>
<p>传统的监控多个 socket 的 Java 解决方案是为每个 socket 创建一个线程并使得线程可以在 read( )调用中阻塞,直到数据可用。这事实上将每个被阻塞的线程当作了 socket 监控器,并将 Java 虚拟机的线程调度当作了通知机制。这两者本来都不是为了这种目的而设计的。程序员和 Java 虚拟机都为管理所有这些线程的复杂性和性能损耗付出了代价,这在线程数量的增长时表现得更为突出。</p>
<h3 id="选择器属性">选择器属性</h3>
<ul>
<li><p>选择器（Selector）<br>选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册的,并且使用选择器来更新通道的就绪状态。当这么做的时候,可以选择将被激发的线程挂起,直到有就绪的的通道。</p>
</li>
<li><p>可选择通道(SelectableChannel)<br>SelectableChannel 可以被注册到 Selector 对象上,同时可以指定对那个选择器而言,那种操作是感兴趣的。一个通道可以被注册到多个选择器上,但对每个选择器而言只能被注册一次。</p>
</li>
<li><p>选择键(SelectionKey)<br>选择键封装了特定的通道与特定的选择器的注册关系。选择键对象被SelectableChannel.register( ) 返回并提供一个表示这种注册关系的标记。选择键包含了两个比特集(以整数的形式进行编码),指示了该注册关系所关心的通道操作,以及通道已经准备好的操作。</p>
</li>
</ul>
<p><strong>下图体现了就绪选择注册和Selector的关系</strong><br><img src="/image/Selector.png" alt="Selector"></p>
<p>一个单独的通道对象可以被注册到多个选择器上。可以调用 isRegistered( )方法来检查一个通道是否被注册到任何一个选择器上。这个方法没有提供关于通道被注册到哪个选择器上的信息,而只能知道它至少被注册到了一个选择器上。此外,在一个键被取消之后,直到通道被注销为止,可能有时间上的延迟。这个方法只是一个提示,而不是确切的答案。</p>
<h3 id="键对象">键对象</h3>
<p>键对象表示了一种特定的注册关系。当应该终结这种关系的时候,可以调用 SelectionKey对象的 cancel( )方法。可以通过调用 isValid( )方法来检查它是否仍然表示一种有效的关系。当键被取消时,它将被放在相关的选择器的已取消的键的集合里。注册不会立即被取消,但键会立即失效。当再次调用 select( )方法时(或者一个正在进行的 select()调用结束时),已取消的键的集合中的被取消的键将被清理掉,并且相应的注销也将完成。通道会被注销,而新的SelectionKey 将被返回。</p>
<p>SelectionKey 类定义了四个便于使用的布尔方法来为您测试这些比特值:isReadable( ),isWritable( ),isConnectable( ), 和 isAcceptable( )。每一个方法都与使用特定掩码来测试 readyOps( )方法的结果的效果相同。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (key.isWritable( ))</div><div class="line">等价于:</div><div class="line"><span class="keyword">if</span> ((key.readyOps( ) & SelectionKey.OP_WRITE) != <span class="number">0</span>)</div></pre></td></tr></table></figure>

<p>这四个方法在任意一个 SelectionKey 对象上都能安全地调用。不能在一个通道上注册一个它不支持的操作,这种操作也永远不会出现在 ready 集合中。调用一个不支持的操作将总是返回 false,因为这种操作在该通道上永远不会准备好。</p>
<h3 id="停止选择过程">停止选择过程</h3>
<p>有三种方式可以唤醒在select（）方法中睡眠的线程。</p>
<ol>
<li><p>调用wakeup（）<br>调用 Selector 对象的 wakeup( )方法将使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有在进行中的选择,那么下一次对 select( )方法的一种形式的调用将立即返回。后续的选择操作将正常进行。在选择操作之间多次调用 wakeup( )方法与调用它一次没有什么不同。有时这种延迟的唤醒行为并不是您想要的。您可能只想唤醒一个睡眠中的线程,而使得后续的选择继续正常地进行。您可以通过在调用 wakeup( )方法后调用 selectNow( )方法来绕过这个问题。尽管如此,如果您将您的代码构造为合理地关注于返回值和执行选择集合,那么即使下一个 select( )方法的调用在没有通道就绪时就立即返回,也应该不会有什么不同。不管怎么说,您应该为可能发生的事件做好准备。</p>
</li>
<li><p>调用 close( )<br>如果选择器的 close( )方法被调用,那么任何一个在选择操作中阻塞的线程都将被唤醒,就像wakeup( )方法被调用了一样。与选择器相关的通道将被注销,而键将被取消。</p>
</li>
<li><p>调用 interrupt( )<br>如果睡眠中的线程的 interrupt( )方法被调用,它的返回状态将被设置。如果被唤醒的线程之后将试图在通道上执行 I/O 操作,通道将立即关闭,然后线程将捕捉到一个异常。这是由于在第三章中已经探讨过的通道的中断语义。使用 wakeup( )方法将会优雅地将一个在 select( )方法中睡眠的线程唤醒。如果您想让一个睡眠的线程在直接中断之后继续执行,需要执行一些步骤来清理中断状态</p>
</li>
</ol>
<h2 id="简单的NIO服务器">简单的NIO服务器</h2>
<p>下面是一个简单的NIO服务器的例子，使用select（）来为多个通道提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SelectableChannel;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</div><div class="line"><span class="keyword">import</span> java.nio.channels.Selector;</div><div class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.swing.text.html.HTMLDocument.Iterator;</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line">* Simple echo-back server which listens for incoming stream connections and</div><div class="line">* echoes back whatever it reads. A single Selector object is used to listen to</div><div class="line">* the server socket (to accept new connections) and all the active socket</div><div class="line">* channels.</div><div class="line">*<span class="javadoctag"> @author</span> zale (zalezone.cn)</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSockets</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT_NUMBER = <span class="number">1234</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] argv) <span class="keyword">throws</span> Exception </div><div class="line">	{</div><div class="line">		<span class="keyword">new</span> SelectSockets().go(argv);</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span>(String[] argv) <span class="keyword">throws</span> Exception </div><div class="line">	{</div><div class="line">		<span class="keyword">int</span> port = PORT_NUMBER;</div><div class="line">		<span class="keyword">if</span> (argv.length &gt; <span class="number">0</span>) </div><div class="line">		{ <span class="comment">// 覆盖默认的监听端口</span></div><div class="line">			port = Integer.parseInt(argv[<span class="number">0</span>]);</div><div class="line">		}</div><div class="line">		System.out.println(<span class="string">"Listening on port "</span> + port);</div><div class="line">		ServerSocketChannel serverChannel = ServerSocketChannel.open();<span class="comment">// 打开一个未绑定的serversocketchannel</span></div><div class="line">		ServerSocket serverSocket = serverChannel.socket();<span class="comment">// 得到一个ServerSocket去和它绑定	</span></div><div class="line">		Selector selector = Selector.open();<span class="comment">// 创建一个Selector供下面使用</span></div><div class="line">		serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));<span class="comment">//设置server channel将会监听的端口</span></div><div class="line">		serverChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">//设置非阻塞模式</span></div><div class="line">		serverChannel.register(selector, SelectionKey.OP_ACCEPT);<span class="comment">//将ServerSocketChannel注册到Selector</span></div><div class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) </div><div class="line">		{</div><div class="line">			<span class="comment">// This may block for a long time. Upon returning, the</span></div><div class="line">			<span class="comment">// selected set contains keys of the ready channels.</span></div><div class="line">			<span class="keyword">int</span> n = selector.select();</div><div class="line">			<span class="keyword">if</span> (n == <span class="number">0</span>) </div><div class="line">			{</div><div class="line">				<span class="keyword">continue</span>; <span class="comment">// nothing to do</span></div><div class="line">			}			</div><div class="line">			java.util.Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<span class="comment">// Get an iterator over the set of selected keys</span></div><div class="line">			<span class="comment">//在被选择的set中遍历全部的key</span></div><div class="line">			<span class="keyword">while</span> (it.hasNext()) </div><div class="line">			{</div><div class="line">				SelectionKey key = (SelectionKey) it.next();</div><div class="line">				<span class="comment">// 判断是否是一个连接到来</span></div><div class="line">				<span class="keyword">if</span> (key.isAcceptable()) </div><div class="line">				{</div><div class="line">					ServerSocketChannel server =(ServerSocketChannel) key.channel();</div><div class="line">					SocketChannel channel = server.accept();</div><div class="line">					registerChannel(selector, channel,SelectionKey.OP_READ);<span class="comment">//注册读事件</span></div><div class="line">					sayHello(channel);<span class="comment">//对连接进行处理</span></div><div class="line">				}</div><div class="line">				<span class="comment">//判断这个channel上是否有数据要读</span></div><div class="line">				<span class="keyword">if</span> (key.isReadable()) </div><div class="line">				{</div><div class="line">					readDataFromSocket(key);</div><div class="line">				}</div><div class="line">				<span class="comment">//从selected set中移除这个key，因为它已经被处理过了</span></div><div class="line">				it.remove();</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">// ----------------------------------------------------------</span></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	* Register the given channel with the given selector for the given</div><div class="line">	* operations of interest</div><div class="line">	*/</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerChannel</span>(Selector selector,SelectableChannel channel, <span class="keyword">int</span> ops) <span class="keyword">throws</span> Exception</div><div class="line">	{</div><div class="line">		<span class="keyword">if</span> (channel == <span class="keyword">null</span>) </div><div class="line">		{</div><div class="line">			<span class="keyword">return</span>; <span class="comment">// 可能会发生</span></div><div class="line">		}</div><div class="line">		<span class="comment">// 设置通道为非阻塞</span></div><div class="line">		channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">		<span class="comment">// 将通道注册到选择器上</span></div><div class="line">		channel.register(selector, ops);</div><div class="line">	}</div><div class="line">	<span class="comment">// ----------------------------------------------------------</span></div><div class="line">	<span class="comment">// Use the same byte buffer for all channels. A single thread is</span></div><div class="line">	<span class="comment">// servicing all the channels, so no danger of concurrent acccess.</span></div><div class="line">	<span class="comment">//对所有的通道使用相同的缓冲区。单线程为所有的通道进行服务，所以并发访问没有风险</span></div><div class="line">	<span class="keyword">private</span> ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	* Sample data handler method for a channel with data ready to read.</div><div class="line">	* 对于一个准备读入数据的通道的简单的数据处理方法</div><div class="line">	*<span class="javadoctag"> @param</span> key</div><div class="line">	*</div><div class="line">	A SelectionKey object associated with a channel determined by</div><div class="line">	the selector to be ready for reading. If the channel returns</div><div class="line">	an EOF condition, it is closed here, which automatically</div><div class="line">	invalidates the associated key. The selector will then</div><div class="line">	de-register the channel on the next select call.</div><div class="line">	</div><div class="line">	一个选择器决定了和通道关联的SelectionKey object是准备读状态。如果通道返回EOF，通道将被关闭。</div><div class="line">	并且会自动使相关的key失效，选择器然后会在下一次的select call时取消掉通道的注册</div><div class="line">	*/</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">readDataFromSocket</span>(SelectionKey key) <span class="keyword">throws</span> Exception </div><div class="line">	{</div><div class="line">		SocketChannel socketChannel = (SocketChannel) key.channel();</div><div class="line">		<span class="keyword">int</span> count;</div><div class="line">		buffer.clear(); <span class="comment">// 清空Buffer</span></div><div class="line">		<span class="comment">// Loop while data is available; channel is nonblocking</span></div><div class="line">		<span class="comment">//当可以读到数据时一直循环，通道为非阻塞</span></div><div class="line">		<span class="keyword">while</span> ((count = socketChannel.read(buffer)) &gt; <span class="number">0</span>) </div><div class="line">		{</div><div class="line">			buffer.flip(); <span class="comment">// 将缓冲区置为可读</span></div><div class="line">			<span class="comment">// Send the data; don't assume it goes all at once</span></div><div class="line">			<span class="comment">//发送数据，不要期望能一次将数据发送完</span></div><div class="line">			<span class="keyword">while</span> (buffer.hasRemaining()) </div><div class="line">			{</div><div class="line">				socketChannel.write(buffer);</div><div class="line">			}</div><div class="line">			<span class="comment">// WARNING: the above loop is evil. Because</span></div><div class="line">			<span class="comment">// it's writing back to the same nonblocking</span></div><div class="line">			<span class="comment">// channel it read the data from, this code can</span></div><div class="line">			<span class="comment">// potentially spin in a busy loop. In real life</span></div><div class="line">			<span class="comment">// you'd do something more useful than this.</span></div><div class="line">			<span class="comment">//这里的循环是无意义的，具体按实际情况而定</span></div><div class="line">			buffer.clear(); <span class="comment">// Empty buffer</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (count &lt; <span class="number">0</span>) </div><div class="line">		{</div><div class="line">			<span class="comment">// Close channel on EOF, invalidates the key</span></div><div class="line">			<span class="comment">//读取结束后关闭通道，使key失效</span></div><div class="line">			socketChannel.close();</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">// ----------------------------------------------------------</span></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	* Spew a greeting to the incoming client connection.</div><div class="line">	*</div><div class="line">	*<span class="javadoctag"> @param</span> channel</div><div class="line">	*</div><div class="line">	The newly connected SocketChannel to say hello to.</div><div class="line">	*/</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span>(SocketChannel channel) <span class="keyword">throws</span> Exception </div><div class="line">	{</div><div class="line">		buffer.clear();</div><div class="line">		buffer.put(<span class="string">"Hi there!\r\n"</span>.getBytes());</div><div class="line">		buffer.flip();</div><div class="line">		channel.write(buffer);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<h3 id="原理解释">原理解释</h3>
<p>上面这个例子实现了一个简单的服务器，它创建了 ServerSocketChannel 和 Selector 对象,并将通道注册到选择器上。我们不在注册的键中保存服务器 socket 的引用,因为它永远不会被注销。这个无限循环在最上面先调用了 select( ),这可能会无限期地阻塞。当选择结束时,就遍历选择键并检查已经就绪的通道。</p>
<p>如果一个键指示与它相关的通道已经准备好执行一个 accecpt( )操作,我们就通过键获取关联的通道,并将它转换为 SeverSocketChannel 对象。我们都知道这么做是安全的,因为只有ServerSocketChannel 支持 OP_ACCEPT 操作。我们也知道我们的代码只把对一个单一的ServerSocketChannel 对象的 OP_ACCEPT 操作进行了注册。通过对服务器 socket 通道的引用,我 们调用了它 的 accept( )方法 ,来获取刚到达 的 socket 的句 柄。返回的 对象的类型 是<br>SocketChannel,也是一个可选择的通道类型。这时,与创建一个新线程来从新的连接中读取数据不同,我们只是简单地将 socket 同多注册到选择器上。我们通过传入 OP_READ 标记,告诉选择器我们关心新的 socket 通道什么时候可以准备好读取数据。</p>
<p>如果键指示通道还没有准备好执行 accept( ),我们就检查它是否准备好执行 read( )。任何一个这么指示的 socket 通道一定是之前 ServerSocketChannel 创建的 SocketChannel 对象之一,并且被注册为只对读操作感兴趣。对于每个有数据需要读取的 socket 通道,我们调用一个公共的方法来读取并处理这个带有数据的 socket。需要注意的是这个公共方法需要准备好以非阻塞的方式处理 socket 上的不完整的数据。它需要迅速地返回,以其他带有后续输入的通道能够及时地得到处理。例 4-1 中只是简单地对数据进行响应,将数据写回 socket,传回给发送者。</p>
<p>在循环的底部,我们通过调用 Iterator(迭代器)对象的 remove()方法,将键从已选择的键的集合中移除。键可以直接从 selectKeys()返回的 Set 中移除,但同时需要用 Iterator 来检查集合,您需要使用迭代器的 remove()方法来避免破坏迭代器内部的状态。</p>
<h2 id="并发性">并发性</h2>
<p>选择器对象是线程安全的,但它们包含的键集合不是。通过 keys( )和 selectKeys( )返回的键的集合是 Selector 对象内部的私有的 Set 对象集合的直接引用。这些集合可能在任意时间被改变。已注册的键的集合是只读的。如果您试图修改它,那么您得到的奖品将是一个java.lang.UnsupportedOperationException,但是当您在观察它们的时候,它们可能发生了改变的话,您仍然会遇到麻烦。Iterator 对象是快速失败的(fail-fast):如果底层的 Set 被改变了,它们将会抛出 java.util.ConcurrentModificationException,因此如果您期望在多个线程间共享选择器和/或键,请对此做好准备。您可以直接修改选择键,但请注意您这么做时可能会彻底破坏另一个线程的 Iterator。</p>
<p>如果在多个线程并发地访问一个选择器的键的集合的时候存在任何问题,您可以采取一些步骤来合理地同步访问。在执行选择操作时,选择器在 Selector 对象上进行同步,然后是已注册的键的集合,最后是已选择的键的集合,按照这样的顺序。已取消的键的集合也在选择过程的的第 1步和第 3 步之间保持同步(当与已取消的键的集合相关的通道被注销时)。</p>
<p>在多线程的场景中,如果您需要对任何一个键的集合进行更改,不管是直接更改还是其他操作带来的副作用,您都需要首先以相同的顺序,在同一对象上进行同步。锁的过程是非常重要的。如果竞争的线程没有以相同的顺序请求锁,就将会有死锁的潜在隐患。如果您可以确保否其他线程不会同时访问选择器,那么就不必要进行同步了。</p>
<p>Selector 类的 close( )方法与 slect( )方法的同步方式是一样的,因此也有一直阻塞的可能性。在选择过程还在进行的过程中,所有对 close( )的调用都会被阻塞,直到选择过程结束,或者执行选择的线程进入睡眠。在后面的情况下,执行选择的线程将会在执行关闭的线程获得锁时立即被唤醒,并关闭选择器。</p>
<h2 id="选择过程的可扩展性">选择过程的可扩展性</h2>
<p>对于单CPU的系统用一个线程来为多个通道提供服务可能是个好主意，但是对于多个CPU的系统来说就可能不能使其他CPU高效发挥作用。  </p>
<p>一个比较好的优化策略是对所有的可选择通道使用一个选择器,并将对就绪通道的服务委托给其他线程。根据部署的条件,线程池的大小是可以调整的(或者它自己进行动态的调整)。  </p>
<p>另外，有些通道要求比其他通道有更高的响应速度，可以通过使用两个选择器来解决：一个为命令连接服务，另一个为普通连接服务。与将所有准备好的通道放到同一个线程池的做法不同,通道可以根据功能由不同的工作线程来处理。它们可能可以是日志线程池,命令/控制线程池,状态请求线程池,等等。</p>
<h2 id="服务线程池服务器示例">服务线程池服务器示例</h2>
<p>这个例子是上一个简单服务器的一般性的选择循环的扩展。它覆写了 readDataFromSocket( )方法,并使用线程池来为准备好数据用于读取的通道提供服务。与在主线程中同步地读取数据不同,这个版本的实现将 SelectionKey 对象传递给为其服务的工作线程。</p>
<h3 id="使用线程池来为通道提供服务">使用线程池来为通道提供服务</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line">* Specialization of the SelectSockets class which uses a thread pool to service</div><div class="line">* channels. The thread pool is an ad-hoc implementation quicky lashed togther</div><div class="line">* in a few hours for demonstration purposes. It's definitely not production</div><div class="line">* quality.</div><div class="line">*</div><div class="line">*<span class="javadoctag"> @author</span> Ron Hitchens (ron@ronsoft.com)</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSocketsThreadPool</span> <span class="keyword">extends</span> <span class="title">SelectSockets</span> </span></div><div class="line">{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_THREADS = <span class="number">5</span>;</div><div class="line">	<span class="keyword">private</span> ThreadPool pool = <span class="keyword">new</span> ThreadPool(MAX_THREADS);</div><div class="line">	<span class="comment">// -------------------------------------------------------------</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] argv) <span class="keyword">throws</span> Exception </div><div class="line">	{</div><div class="line">		<span class="keyword">new</span> SelectSocketsThreadPool().go(argv);</div><div class="line">	}</div><div class="line">	<span class="comment">// -------------------------------------------------------------</span></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	* Sample data handler method for a channel with data ready to read. This</div><div class="line">	* method is invoked from(被调用) the go( ) method in the parent class. This handler</div><div class="line">	* delegates（委托） to a worker thread in a thread pool to service the channel,</div><div class="line">	* then returns immediately.</div><div class="line">	*</div><div class="line">	*<span class="javadoctag"> @param</span> key</div><div class="line">	*</div><div class="line">	A SelectionKey object representing a channel determined by the</div><div class="line">	*</div><div class="line">	selector to be ready for reading. If the channel returns an</div><div class="line">	*</div><div class="line">	EOF condition, it is closed here, which automatically</div><div class="line">	*</div><div class="line">	invalidates the associated key. The selector will then</div><div class="line">	*</div><div class="line">	de-register the channel on the next select call.</div><div class="line">	*/</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">readDataFromSocket</span>(SelectionKey key) <span class="keyword">throws</span> Exception </div><div class="line">	{</div><div class="line">		WorkerThread worker = pool.getWorker();</div><div class="line">		<span class="keyword">if</span> (worker == <span class="keyword">null</span>) </div><div class="line">		{</div><div class="line">			<span class="comment">// No threads available. Do nothing. The selection</span></div><div class="line">			<span class="comment">// loop will keep calling this method until a</span></div><div class="line">			<span class="comment">// thread becomes available. This design could</span></div><div class="line">			<span class="comment">// be improved.</span></div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		}</div><div class="line">		<span class="comment">// Invoking this wakes up the worker thread, then returns</span></div><div class="line">		worker.serviceChannel(key);</div><div class="line">	}</div><div class="line">	<span class="comment">// ---------------------------------------------------------------</span></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	* A very simple thread pool class. The pool size is set at construction</div><div class="line">	* time and remains fixed. Threads are cycled through a FIFO idle queue.</div><div class="line">	*/</div><div class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></div><div class="line">	{</div><div class="line">		List idle = <span class="keyword">new</span> LinkedList();</div><div class="line">		ThreadPool(<span class="keyword">int</span> poolSize) </div><div class="line">		{</div><div class="line">			<span class="comment">// Fill up the pool with worker threads</span></div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++)</div><div class="line">			{</div><div class="line">				WorkerThread thread = <span class="keyword">new</span> WorkerThread(<span class="keyword">this</span>);</div><div class="line">				<span class="comment">// Set thread name for debugging. Start it.</span></div><div class="line">				thread.setName(<span class="string">"Worker"</span> + (i + <span class="number">1</span>));</div><div class="line">				thread.start();</div><div class="line">				idle.add(thread);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="javadoc">/**</span></div><div class="line">		* Find an idle worker thread, if any. Could return null.</div><div class="line">		*/</div><div class="line">		WorkerThread getWorker() </div><div class="line">		{</div><div class="line">			WorkerThread worker = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">synchronized</span> (idle) </div><div class="line">			{</div><div class="line">				<span class="keyword">if</span> (idle.size() &gt; <span class="number">0</span>) </div><div class="line">				{</div><div class="line">					worker = (WorkerThread) idle.remove(<span class="number">0</span>);</div><div class="line">				}</div><div class="line">			}</div><div class="line">			<span class="keyword">return</span> (worker);</div><div class="line">		}</div><div class="line">		<span class="javadoc">/**</span></div><div class="line">		* Called by the worker thread to return itself to the idle pool.</div><div class="line">		*/</div><div class="line">		<span class="keyword">void</span> returnWorker(WorkerThread worker) </div><div class="line">		{</div><div class="line">			<span class="keyword">synchronized</span> (idle) </div><div class="line">			{</div><div class="line">				idle.add(worker);</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	* A worker thread class which can drain（排空） channels and echo-back（回显） the input.</div><div class="line">	* Each instance is constructed with a reference（参考） to the owning thread pool</div><div class="line">	* object. When started, the thread loops forever waiting to be awakened to</div><div class="line">	* service the channel associated with a SelectionKey object. The worker is</div><div class="line">	* tasked by calling its serviceChannel( ) method with a SelectionKey</div><div class="line">	* object. The serviceChannel( ) method stores the key reference in the</div><div class="line">	* thread object then calls notify( ) to wake it up. When the channel has</div><div class="line">	* been drained, the worker thread returns itself to its parent pool.</div><div class="line">	*/</div><div class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span></div><div class="line">	{</div><div class="line">		<span class="keyword">private</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">		<span class="keyword">private</span> ThreadPool pool;</div><div class="line">		<span class="keyword">private</span> SelectionKey key;</div><div class="line">		WorkerThread(ThreadPool pool) </div><div class="line">		{</div><div class="line">			<span class="keyword">this</span>.pool = pool;</div><div class="line">		}</div><div class="line">		<span class="comment">// Loop forever waiting for work to do</span></div><div class="line">		<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span>() </div><div class="line">		{</div><div class="line">			System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" is ready"</span>);</div><div class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) </div><div class="line">			{</div><div class="line">				<span class="keyword">try</span> </div><div class="line">				{</div><div class="line">					<span class="comment">// Sleep and release object lock</span></div><div class="line">					<span class="comment">//休眠并且释放掉对象锁</span></div><div class="line">					<span class="keyword">this</span>.wait();</div><div class="line">				} </div><div class="line">				<span class="keyword">catch</span> (InterruptedException e) </div><div class="line">				{</div><div class="line">					e.printStackTrace();</div><div class="line">					<span class="comment">// Clear interrupt status</span></div><div class="line">					<span class="keyword">this</span>.interrupted();</div><div class="line">				}</div><div class="line">				<span class="keyword">if</span> (key == <span class="keyword">null</span>) </div><div class="line">				{</div><div class="line">					<span class="keyword">continue</span>; <span class="comment">// just in case</span></div><div class="line">				}</div><div class="line">				System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" has been awakened"</span>);</div><div class="line">				<span class="keyword">try</span> </div><div class="line">				{</div><div class="line">					drainChannel(key);</div><div class="line">				} </div><div class="line">				<span class="keyword">catch</span> (Exception e) </div><div class="line">				{</div><div class="line">					System.out.println(<span class="string">"Caught '"</span> + e + <span class="string">"' closing channel"</span>);</div><div class="line">					<span class="comment">// Close channel and nudge selector</span></div><div class="line">					<span class="keyword">try</span> </div><div class="line">					{</div><div class="line">						key.channel().close();</div><div class="line">					} </div><div class="line">					<span class="keyword">catch</span> (IOException ex) </div><div class="line">					{</div><div class="line">						ex.printStackTrace();</div><div class="line">					}</div><div class="line">					key.selector().wakeup();</div><div class="line">				}</div><div class="line">				key = <span class="keyword">null</span>;</div><div class="line">				<span class="comment">// Done. Ready for more. Return to pool</span></div><div class="line">				<span class="keyword">this</span>.pool.returnWorker(<span class="keyword">this</span>);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="javadoc">/**</span></div><div class="line">		* Called to initiate a unit of work by this worker thread on the</div><div class="line">		* provided SelectionKey object. This method is synchronized, as is the</div><div class="line">		* run( ) method, so only one key can be serviced at a given time.</div><div class="line">		* Before waking the worker thread, and before returning to the main</div><div class="line">		* selection loop, this key's interest set is updated to remove OP_READ.</div><div class="line">		* This will cause the selector to ignore read-readiness for this</div><div class="line">		* channel while the worker thread is servicing it.</div><div class="line">		* 通过一个被提供SelectionKey对象的工作线程来初始化一个工作集合，这个方法是同步的，所以</div><div class="line">		* 里面的run方法只有一个key能被服务在同一个时间，在唤醒工作线程和返回到主循环之前，这个key的</div><div class="line">		* 感兴趣的集合被更新来删除OP_READ，这将会引起工作线程在提供服务的时候选择器会忽略读就绪的通道</div><div class="line">		*/</div><div class="line">		<span class="keyword">synchronized</span> <span class="keyword">void</span> serviceChannel(SelectionKey key) </div><div class="line">		{</div><div class="line">			<span class="keyword">this</span>.key = key;</div><div class="line">			key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));</div><div class="line">			<span class="keyword">this</span>.notify(); <span class="comment">// Awaken the thread</span></div><div class="line">		}</div><div class="line">		<span class="javadoc">/**</span></div><div class="line">		* The actual code which drains the channel associated with the given</div><div class="line">		* key. This method assumes the key has been modified prior to</div><div class="line">		* invocation to turn off selection interest in OP_READ. When this</div><div class="line">		* method completes it re-enables OP_READ and calls wakeup( ) on the</div><div class="line">		* selector so the selector will resume watching this channel.</div><div class="line">		*/</div><div class="line">		<span class="keyword">void</span> drainChannel(SelectionKey key) <span class="keyword">throws</span> Exception </div><div class="line">		{</div><div class="line">			SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">			<span class="keyword">int</span> count;</div><div class="line">			buffer.clear(); <span class="comment">// 清空buffer</span></div><div class="line">			<span class="comment">// Loop while data is available; channel is nonblocking</span></div><div class="line">			<span class="keyword">while</span> ((count = channel.read(buffer)) &gt; <span class="number">0</span>)</div><div class="line">			{</div><div class="line">				buffer.flip(); <span class="comment">// make buffer readable</span></div><div class="line">				<span class="comment">// Send the data; may not go all at once</span></div><div class="line">				<span class="keyword">while</span> (buffer.hasRemaining()) </div><div class="line">				{</div><div class="line">					channel.write(buffer);</div><div class="line">				}</div><div class="line">				<span class="comment">// WARNING: the above loop is evil.</span></div><div class="line">				<span class="comment">// See comments in superclass.</span></div><div class="line">				buffer.clear(); <span class="comment">// Empty buffer</span></div><div class="line">			}</div><div class="line">			<span class="keyword">if</span> (count &lt; <span class="number">0</span>) </div><div class="line">			{</div><div class="line">				<span class="comment">// Close channel on EOF; invalidates the key</span></div><div class="line">				channel.close();</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			}</div><div class="line">			<span class="comment">// Resume interest in OP_READ</span></div><div class="line">			key.interestOps(key.interestOps() | SelectionKey.OP_READ);</div><div class="line">			<span class="comment">// Cycle the selector so this key is active again</span></div><div class="line">			key.selector().wakeup();</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<h3 id="原理解释-1">原理解释</h3>
<p>由于执行选择过程的线程将重新循环并几乎立即再次调用 select( ),键的 interest 集合将被修改,并将 interest(感兴趣的操作)从读取就绪(read-rreadiness)状态中移除。这将防止选择器重复地调用 readDataFromSocket( )(因为通道仍然会准备好读取数据,直到工作线程从它那里读取数据)。当工作线程结束为通道提供的服务时,它将再次更新键的 ready 集合,来将 interest 重新放到读取就绪集合中。它也会在选择器上显式地调用 wakeup( )。如果主线程在 select( )中被阻塞,这将使它继续执行。这个选择循环会再次执行一个轮回(可能什么也没做)并带着被更新的键重新进入select( )。</p>
<h1 id="总结">总结</h1>
<p>对于java NIO的常见框架有Mina，Netty等，关于Mina和Netty到底哪个框架比较好，因为还未深入进行研究，<br>所以也不敢下定论，但个人还是倾向Netty框架吧。下一步准备好好研究一下Netty框架。</p>
<p><strong>参考文献</strong>：<a href="http://book.douban.com/subject/1433583/" target="_blank" rel="external">《java NIO》</a></p>


</div>
    <footer class="article-footer">
      <a data-url="http://zalezone.cn/2014/09/17/NIO精粹/" data-id="v0iex2kn3q70aeyg" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/">NIO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/非阻塞/">非阻塞</a></li></ul>

    </footer>

<!-- baidu start -->
<div style="padding-left:30px;"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a></div></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<div id="gbook" style="padding-left:20px;padding-right:20px;">
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="NIO精粹" data-title="java NIO详解" data-url="http://zalezone.cn/2014/09/17/NIO精粹/"></div>
<!-- 多说评论框 end -->
</div>




  
<nav id="article-nav">
  
    <a href="/2014/09/25/Android侧拉菜单SlidingMenu的配置和使用/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Android侧拉菜单SlidingMenu的配置和使用
        
      </div>
    </a>
  
  
    <a href="/2014/09/08/linux翻墙攻略/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">linux翻墙攻略</div>
    </a>
  
</nav>



      
  </div>
</article>
</section>
        
          <aside id="sidebar">
  
    
<div class="widget-wrap">
<h3 class="widget-title">ABOUT ME</h3>
<ul class="widget about-me">

<li><img class="author" title="About me" src="/image/touxiang2.jpg" /></li>


<li>name->    zale</li>

<li>Job->     student</li>

<li>Email->   1433317488@qq.com</li>


</ul>
</div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web前端/">web前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/人生轨迹/">人生轨迹</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/07/13/翻墙攻略（二）/">翻墙攻略（二）</a>
          </li>
        
          <li>
            <a href="/2015/05/16/Android-NDK入门/">Android NDK 入门</a>
          </li>
        
          <li>
            <a href="/2015/05/13/hibernate高级特性/">Hibernate高级特性</a>
          </li>
        
          <li>
            <a href="/2015/04/26/hibernate/">hibernate入门</a>
          </li>
        
          <li>
            <a href="/2015/04/22/Android自定义ActionBar/">Android自定义ActionBar</a>
          </li>
        
          <li>
            <a href="/2015/03/15/java垃圾回收机制/">java垃圾回收机制</a>
          </li>
        
          <li>
            <a href="/2015/02/15/适配器模式/">适配器模式</a>
          </li>
        
          <li>
            <a href="/2015/01/01/newStart/">再见2014，你好2015</a>
          </li>
        
          <li>
            <a href="/2014/12/06/Angularjs/">AngularJS</a>
          </li>
        
          <li>
            <a href="/2014/11/16/单例模式/">单例模式</a>
          </li>
        
          <li>
            <a href="/2014/11/12/观察者模式/">观察者模式</a>
          </li>
        
          <li>
            <a href="/2014/10/26/java自制线程池/">java自制线程池</a>
          </li>
        
          <li>
            <a href="/2014/10/22/Android编译执行C代码/">android 编译调用C代码</a>
          </li>
        
          <li>
            <a href="/2014/09/29/不要怪老天不公平/">不要怪老天不公平</a>
          </li>
        
          <li>
            <a href="/2014/09/25/Android侧拉菜单SlidingMenu的配置和使用/">Android侧拉菜单SlidingMenu的配置和使用</a>
          </li>
        
          <li>
            <a href="/2014/09/17/NIO精粹/">java NIO详解</a>
          </li>
        
          <li>
            <a href="/2014/09/08/linux翻墙攻略/">linux翻墙攻略</a>
          </li>
        
          <li>
            <a href="/2014/08/24/暑假之末/">暑假之末</a>
          </li>
        
          <li>
            <a href="/2014/08/13/git使用小记/">Git使用小记</a>
          </li>
        
          <li>
            <a href="/2014/08/13/正则表达式基础/">正则表达式基础</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        <ul>
<li><a href="http://blog.csdn.net/u012457196" target="_blank" title="csdn">CSDN</a></li>
<li><a href="http://user.qzone.qq.com/1433317488" target="_blank" title="qqzone">qq空间</a></li>
	  	</ul>
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ActionBarSherlock/" style="font-size: 10.00px;">ActionBarSherlock</a><a href="/tags/AngularJS/" style="font-size: 10.00px;">AngularJS</a><a href="/tags/C/" style="font-size: 10.00px;">C</a><a href="/tags/DIY/" style="font-size: 10.00px;">DIY</a><a href="/tags/GFW/" style="font-size: 10.00px;">GFW</a><a href="/tags/Hibernate/" style="font-size: 10.00px;">Hibernate</a><a href="/tags/JDK/" style="font-size: 10.00px;">JDK</a><a href="/tags/NDK/" style="font-size: 10.00px;">NDK</a><a href="/tags/NIO/" style="font-size: 10.00px;">NIO</a><a href="/tags/SlidingMenu/" style="font-size: 10.00px;">SlidingMenu</a><a href="/tags/UI/" style="font-size: 13.33px;">UI</a><a href="/tags/VPS主机/" style="font-size: 10.00px;">VPS主机</a><a href="/tags/actionBar/" style="font-size: 10.00px;">actionBar</a><a href="/tags/android/" style="font-size: 16.67px;">android</a><a href="/tags/assets/" style="font-size: 10.00px;">assets</a><a href="/tags/git/" style="font-size: 10.00px;">git</a><a href="/tags/goagent/" style="font-size: 10.00px;">goagent</a><a href="/tags/hibernate/" style="font-size: 10.00px;">hibernate</a><a href="/tags/java/" style="font-size: 20.00px;">java</a><a href="/tags/javascript/" style="font-size: 10.00px;">javascript</a><a href="/tags/life/" style="font-size: 10.00px;">life</a><a href="/tags/linux/" style="font-size: 13.33px;">linux</a><a href="/tags/shadowsocks/" style="font-size: 10.00px;">shadowsocks</a><a href="/tags/web前端/" style="font-size: 10.00px;">web前端</a><a href="/tags/不公平/" style="font-size: 10.00px;">不公平</a><a href="/tags/交叉编译/" style="font-size: 10.00px;">交叉编译</a><a href="/tags/代理服务器/" style="font-size: 10.00px;">代理服务器</a><a href="/tags/代码管理/" style="font-size: 10.00px;">代码管理</a><a href="/tags/侧拉菜单/" style="font-size: 10.00px;">侧拉菜单</a><a href="/tags/内存管理/" style="font-size: 10.00px;">内存管理</a><a href="/tags/创建类模式/" style="font-size: 10.00px;">创建类模式</a><a href="/tags/单例模式/" style="font-size: 10.00px;">单例模式</a><a href="/tags/垃圾回收/" style="font-size: 10.00px;">垃圾回收</a><a href="/tags/心态/" style="font-size: 10.00px;">心态</a><a href="/tags/性能/" style="font-size: 10.00px;">性能</a><a href="/tags/数据库/" style="font-size: 10.00px;">数据库</a><a href="/tags/数据持久化/" style="font-size: 10.00px;">数据持久化</a><a href="/tags/正则表达式/" style="font-size: 10.00px;">正则表达式</a><a href="/tags/线程池/" style="font-size: 10.00px;">线程池</a><a href="/tags/结构性模式/" style="font-size: 10.00px;">结构性模式</a>
      
    </div>
  </div>




  
</aside>
        
      </div>
      
<footer id="footer">
  

  <div class="outer">


  <div class="outer">

    <div id="footer-info" class="inner">
<style type="text/css">
   #ds-recent-visitors .ds-avatar {
    float: left;
</style>
<ul class="ds-recent-visitors" data-num-items="0"></ul>
</div>



<div id="footer-info" class="inner">
      &copy; 2015 zale
<br>


    </div>
  </div>



</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">存档</a>
  
</nav>
    <script src="/js/jquery-2.1.1.min.js"></script>

<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"zalezone"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->

<div id="scroll2top" style="position:fixed;bottom:150px;right:50px;cursor: pointer;Z-index:9999">
<a title="返回顶部" href="#"><img src="/scroll2top/scrollup.png"/></a>
</div>
<script src="/scroll2top/scroll2top.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">(function() {var s = document.getElementsByTagName("script")[0],rdb = document.createElement("script"); rdb.type = "text/javascript"; rdb.async = true; rdb.src = document.location.protocol + "//www.readability.com/embed.js"; s.parentNode.insertBefore(rdb, s); })();</script>


<script src="/js/script.js" type="text/javascript"></script>




  </div>
</body>
</html>