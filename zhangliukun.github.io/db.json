{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":false},{"_id":"source/image/AdapterMode.jpg","path":"image/AdapterMode.jpg","modified":false},{"_id":"source/image/Bytebuffer.png","path":"image/Bytebuffer.png","modified":false},{"_id":"source/image/Selector.png","path":"image/Selector.png","modified":false},{"_id":"source/image/channel.png","path":"image/channel.png","modified":false},{"_id":"source/image/android_demo.png","path":"image/android_demo.png","modified":false},{"_id":"source/image/danlimoshi.png","path":"image/danlimoshi.png","modified":false},{"_id":"source/image/demo.gif","path":"image/demo.gif","modified":false},{"_id":"source/image/git流程.png","path":"image/git流程.png","modified":false},{"_id":"source/image/gongp1.png","path":"image/gongp1.png","modified":false},{"_id":"source/image/gongp2.png","path":"image/gongp2.png","modified":false},{"_id":"source/image/gongp3.png","path":"image/gongp3.png","modified":false},{"_id":"source/image/gongp4.jpg","path":"image/gongp4.jpg","modified":false},{"_id":"source/image/google.png","path":"image/google.png","modified":false},{"_id":"source/image/haitan.jpg","path":"image/haitan.jpg","modified":false},{"_id":"source/image/haitan2.jpg","path":"image/haitan2.jpg","modified":false},{"_id":"source/image/javaNIO.png","path":"image/javaNIO.png","modified":false},{"_id":"source/image/javaboy.jpg","path":"image/javaboy.jpg","modified":false},{"_id":"source/image/me.jpeg","path":"image/me.jpeg","modified":false},{"_id":"source/image/observer.png","path":"image/observer.png","modified":false},{"_id":"source/image/proxy.png","path":"image/proxy.png","modified":false},{"_id":"source/image/regex示例.jpg","path":"image/regex示例.jpg","modified":false},{"_id":"source/image/touxiang2.jpg","path":"image/touxiang2.jpg","modified":false},{"_id":"source/music/WASURE2.mp3","path":"music/WASURE2.mp3","modified":false},{"_id":"themes/Landscape-zale/source/me.jpeg","path":"me.jpeg","modified":false},{"_id":"themes/Landscape-zale/source/me.png","path":"me.png","modified":false},{"_id":"themes/Landscape-zale/source/z.png","path":"z.png","modified":false},{"_id":"themes/Landscape-zale/source/js/script.js","path":"js/script.js","modified":false},{"_id":"themes/Landscape-zale/source/js/tagcloud.js","path":"js/tagcloud.js","modified":false},{"_id":"themes/Landscape-zale/source/scroll2top/scroll2top.js","path":"scroll2top/scroll2top.js","modified":false},{"_id":"themes/Landscape-zale/source/scroll2top/scrollup.png","path":"scroll2top/scrollup.png","modified":false},{"_id":"themes/Landscape-zale/source/css/style.styl","path":"css/style.styl","modified":false},{"_id":"themes/Landscape-zale/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":false},{"_id":"themes/Landscape-zale/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":false},{"_id":"themes/Landscape-zale/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":false},{"_id":"themes/Landscape-zale/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":false},{"_id":"themes/Landscape-zale/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":false},{"_id":"themes/Landscape-zale/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":false},{"_id":"themes/Landscape-zale/source/css/images/shanghai.jpg","path":"css/images/shanghai.jpg","modified":false},{"_id":"themes/Landscape-zale/source/css/images/xuanyicao2.jpg","path":"css/images/xuanyicao2.jpg","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":false},{"_id":"themes/Landscape-zale/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":false},{"_id":"source/image/ActionBar.png","path":"image/ActionBar.png","modified":false}],"Cache":[{"_id":"scaffolds/draft.md","mtime":1408675309000},{"_id":"scaffolds/page.md","mtime":1408675309000},{"_id":"scaffolds/photo.md","mtime":1408675309000},{"_id":"scaffolds/post.md","mtime":1408675309000},{"_id":"source/CNAME","mtime":1408854059000},{"_id":"source/_posts/Android侧拉菜单SlidingMenu的配置和使用.md","mtime":1429716514000},{"_id":"source/_posts/Android编译执行C代码.md","mtime":1413992768000},{"_id":"source/_posts/Angularjs.md","mtime":1417962245000},{"_id":"source/_posts/NIO精粹.md","mtime":1411645325000},{"_id":"source/_posts/git使用小记.md","mtime":1423024773000},{"_id":"source/_posts/java垃圾回收机制.md","mtime":1426427491000},{"_id":"source/_posts/java自制线程池.md","mtime":1414340326000},{"_id":"source/_posts/linux翻墙攻略.md","mtime":1419857336000},{"_id":"source/_posts/newStart.md","mtime":1420105035000},{"_id":"source/_posts/不要怪老天不公平.md","mtime":1411979444000},{"_id":"source/_posts/单例模式.md","mtime":1416115212000},{"_id":"source/_posts/暑假之末.md","mtime":1411307745000},{"_id":"source/_posts/正则表达式基础.md","mtime":1410339550000},{"_id":"source/_posts/观察者模式.md","mtime":1416115180000},{"_id":"source/_posts/适配器模式.md","mtime":1423964578000},{"_id":"source/image/AdapterMode.jpg","mtime":1423964447000},{"_id":"source/image/Bytebuffer.png","mtime":1410943141000},{"_id":"source/image/Selector.png","mtime":1410944462000},{"_id":"source/image/channel.png","mtime":1410944077000},{"_id":"source/image/android_demo.png","mtime":1411642823000},{"_id":"source/image/danlimoshi.png","mtime":1416114644000},{"_id":"source/image/demo.gif","mtime":1411643996000},{"_id":"source/image/git流程.png","mtime":1410336724000},{"_id":"source/image/gongp1.png","mtime":1411965439000},{"_id":"source/image/gongp2.png","mtime":1411965490000},{"_id":"source/image/gongp3.png","mtime":1411965552000},{"_id":"source/image/gongp4.jpg","mtime":1411974235000},{"_id":"source/image/google.png","mtime":1410191228000},{"_id":"source/image/haitan.jpg","mtime":1408894107000},{"_id":"source/image/haitan2.jpg","mtime":1408957565000},{"_id":"source/image/javaNIO.png","mtime":1410961532000},{"_id":"source/image/javaboy.jpg","mtime":1411645213000},{"_id":"source/image/me.jpeg","mtime":1410967816000},{"_id":"source/image/observer.png","mtime":1415793992000},{"_id":"source/image/proxy.png","mtime":1410188894000},{"_id":"source/image/regex示例.jpg","mtime":1410339481000},{"_id":"source/image/touxiang2.jpg","mtime":1413690336000},{"_id":"source/music/WASURE2.mp3","mtime":1417244023000},{"_id":"themes/Landscape-zale/Gruntfile.js","mtime":1408679904000},{"_id":"themes/Landscape-zale/LICENSE","mtime":1408679904000},{"_id":"themes/Landscape-zale/README.md","mtime":1408679904000},{"_id":"themes/Landscape-zale/_config.yml","mtime":1429433999000},{"_id":"themes/Landscape-zale/package.json","mtime":1408865841000},{"_id":"themes/Landscape-zale/scripts/fancybox.js","mtime":1408679904000},{"_id":"themes/Landscape-zale/node_modules/hexo-calendar/README.md","mtime":1402055561000},{"_id":"themes/Landscape-zale/node_modules/hexo-calendar/calendar.js","mtime":1402055561000},{"_id":"themes/Landscape-zale/node_modules/hexo-calendar/index.js","mtime":1402055561000},{"_id":"themes/Landscape-zale/node_modules/hexo-calendar/package.json","mtime":1408775900000},{"_id":"themes/Landscape-zale/layout/archive.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/category.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/index.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/layout.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/page.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/post.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/tag.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_widget/about_me.ejs","mtime":1411004378000},{"_id":"themes/Landscape-zale/layout/_widget/archive.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_widget/category.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_widget/links.ejs","mtime":1408770085000},{"_id":"themes/Landscape-zale/layout/_widget/mp3player.js","mtime":1409020145000},{"_id":"themes/Landscape-zale/layout/_widget/recent_posts.ejs","mtime":1409029233000},{"_id":"themes/Landscape-zale/layout/_widget/tag.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_widget/tagcloud.ejs","mtime":1411199044000},{"_id":"themes/Landscape-zale/layout/_widget/tagcloudjs","mtime":1411197839000},{"_id":"themes/Landscape-zale/layout/_partial/after-footer.ejs","mtime":1408879153000},{"_id":"themes/Landscape-zale/layout/_partial/archive-post.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/archive.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/article.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/footer.ejs","mtime":1426400175000},{"_id":"themes/Landscape-zale/layout/_partial/google-analytics.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/head.ejs","mtime":1408889308000},{"_id":"themes/Landscape-zale/layout/_partial/header.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/mobile-nav.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/scroll2top.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/sidebar.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/post/category.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/post/date.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/post/func.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/post/gallery.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/post/nav.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/post/readmore.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/post/tag.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/layout/_partial/post/title.ejs","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/me.jpeg","mtime":1410967816000},{"_id":"themes/Landscape-zale/source/me.png","mtime":1410998801000},{"_id":"themes/Landscape-zale/source/z.png","mtime":1408689186000},{"_id":"themes/Landscape-zale/source/js/script.js","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/js/tagcloud.js","mtime":1408868167000},{"_id":"themes/Landscape-zale/source/scroll2top/scroll2top.js","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/scroll2top/scrollup.png","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_extend.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_variables.styl","mtime":1428912617000},{"_id":"themes/Landscape-zale/source/css/style.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_partial/archive.styl","mtime":1408774466000},{"_id":"themes/Landscape-zale/source/css/_partial/article.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_partial/calendar.styl","mtime":1408776599000},{"_id":"themes/Landscape-zale/source/css/_partial/comment.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_partial/footer.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_partial/header.styl","mtime":1408774244000},{"_id":"themes/Landscape-zale/source/css/_partial/highlight.styl","mtime":1411647903000},{"_id":"themes/Landscape-zale/source/css/_partial/mobile.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_partial/sidebar-aside.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_partial/sidebar-bottom.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_partial/sidebar.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_partial/toc.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_util/grid.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/_util/mixin.styl","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/fonts/FontAwesome.otf","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/fonts/fontawesome-webfont.eot","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/fonts/fontawesome-webfont.svg","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/fonts/fontawesome-webfont.ttf","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/fonts/fontawesome-webfont.woff","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/images/banner.jpg","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/css/images/shanghai.jpg","mtime":1340427132000},{"_id":"themes/Landscape-zale/source/css/images/xuanyicao2.jpg","mtime":1409017865000},{"_id":"themes/Landscape-zale/source/fancybox/blank.gif","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/fancybox_loading.gif","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/fancybox_loading@2x.gif","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/fancybox_overlay.png","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/fancybox_sprite.png","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/fancybox_sprite@2x.png","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/jquery.fancybox.css","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/jquery.fancybox.js","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/jquery.fancybox.pack.js","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/helpers/fancybox_buttons.png","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/helpers/jquery.fancybox-buttons.css","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/helpers/jquery.fancybox-buttons.js","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/helpers/jquery.fancybox-media.js","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/helpers/jquery.fancybox-thumbs.css","mtime":1408679904000},{"_id":"themes/Landscape-zale/source/fancybox/helpers/jquery.fancybox-thumbs.js","mtime":1408679904000},{"_id":"source/_posts/Android自定义ActionBar.md","mtime":1429717544000},{"_id":"source/image/ActionBar.png","mtime":1429716036000},{"_id":"source/_posts/hibernate.md","mtime":1430046788000},{"_id":"source/_posts/hibernate高级特性.md","mtime":1431526942000},{"_id":"source/_posts/Android-NDK入门.md","mtime":1431763580000},{"_id":"source/_posts/翻墙攻略（二）.md","mtime":1436785769000}],"Category":[{"name":"web前端","_id":"ygdbd2v8cbb8rzgc","posts":["hm2mdjiqborgqld7"]},{"name":"java","_id":"ul6daxntcjqe0xkn","posts":["v0iex2kn3q70aeyg","08s984skupwf687w","8ybnrk1eedp9pvlg","5ya2xti44vlx3etz","51mm5v9ltr4k45mk"]},{"name":"linux","_id":"klheiemw6tkdcymi","posts":["socbgx7zyq5msdh5","x4dxwqu7l30yd6wo","0frszdnyftyf1c1i"]},{"name":"人生轨迹","_id":"uw37i2o0tlv7fezh","posts":["nbcib5xb70bov7bk","dvul5yz7lg9zdglr","rdjztuauarfhs0h9"]},{"name":"设计模式","_id":"d62md6j57kws527n","posts":["1ola4tvw75ou1nwh","mukwirk7jsh2805p","m5c3vnkf5ukpo1yz"]},{"name":"android","_id":"pmcyb6oshop5size","posts":["yg1dltd0yhkyzxla","qiq6o8fv4kkxvp59","nnpntx3oejvgfoso","krm3cu349djz2wjw"]},{"name":"数据库","_id":"53ssokygss0ah155","posts":["9e0l1uhesy65jzcu"]}],"Page":[],"Post":[{"title":"AngularJS","date":1417797120000,"categories":["ygdbd2v8cbb8rzgc"],"tags":["zaq9qstgoet3ih8y","pudrsj74uscdx0d5","v92q5ck2huq96atw"],"desctiption":"一篇自己对java NIO的理解","content":"<h2 id=\"AngularJS简介\">AngularJS简介</h2>\n<p>AngularJS 是一个 JavaScript 框架。它可通过 script 标签添加到 HTML 页面。</p>\n<p>AngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML。</p>\n<p>AngularJS 是以一个 JavaScript 文件形式发布的，可通过 script 标签添加到网页中：</p>\n<!--<script src=\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"></script> -->\n\n<p><strong>我们建议把脚本放在 <body> 元素的底部。这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。</body></strong></p>\n<a id=\"more\"></a>\n\n<h2 id=\"AngularJS_扩展了_HTML\">AngularJS 扩展了 HTML</h2>\n<p>AngularJS 通过 ng-directives 扩展了 HTML。</p>\n<p><strong>ng-app</strong> 指令定义一个 AngularJS 应用程序。</p>\n<p><strong>ng-model</strong> 指令把元素值（比如输入域的值）绑定到应用程序。</p>\n<p><strong>ng-bind</strong> 指令把应用程序数据绑定到 HTML 视图。</p>\n<p>例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">html</span>&gt;</span></span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">ng-app</span>=<span class=\"value\">\"\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>在输入框中尝试输入：<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>姓名：<span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">ng-model</span>=<span class=\"value\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">ng-bind</span>=<span class=\"value\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">src</span>=<span class=\"value\">\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p>实例讲解：</p>\n<p>当网页加载完毕，AngularJS 自动开启。</p>\n<p>ng-app 指令告诉 AngularJS，div 元素是 AngularJS 应用程序 的”所有者”。</p>\n<p>ng-model 指令把输入域的值绑定到应用程序变量 name。</p>\n<p>ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。</p>\n<p><strong>如果您移除了 ng-app 指令，HTML 将直接把表达式显示出来，不会去计算表达式的结果。</strong></p>\n<h2 id=\"AngularJS_表达式\">AngularJS 表达式</h2>\n<p>AngularJS 表达式写在双大括号内：。</p>\n<p>AngularJS 表达式把数据绑定到 HTML，这与 ng-bind 指令有异曲同工之妙。</p>\n<p>AngularJS 将在表达式书写的位置”输出”数据。</p>\n<p>AngularJS 表达式 很像 JavaScript 表达式：它们可以包含文字、运算符和变量。</p>\n<p>实例 10 或  </p>\n<h2 id=\"AngularJS_对象\">AngularJS 对象</h2>\n<p>AngularJS 对象就像 JavaScript 对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span> ng-init=<span class=\"string\">\"person={firstName:'John',lastName:'Doe'}\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>姓为 <span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"AngularJS_数组\">AngularJS 数组</h2>\n<p>AngularJS 数组就像 JavaScript 数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span> ng-init=<span class=\"string\">\"points=[1,15,19,2,40]\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>第三个值为 undefined<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"AngularJS_指令\">AngularJS 指令</h2>\n<p>AngularJS 通过被称为 指令 的新属性来扩展 HTML</p>\n<p>AngularJS 指令是扩展的 HTML 属性，带有前缀 ng-。</p>\n<p>ng-app 指令初始化一个 AngularJS 应用程序。</p>\n<p>ng-init 指令初始化应用程序数据。</p>\n<p>ng-model 指令把应用程序数据绑定到 HTML 元素。</p>\n<p><strong>一个网页可以包含多个运行在不同元素中的 AngularJS 应用程序。</strong></p>\n<h2 id=\"数据绑定\">数据绑定</h2>\n<p> 是通过 ng-model=”firstName” 进行同步。</p>\n<p>在下一个实例中，两个文本域是通过两个 ng-model 指令同步的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span> ng-init=<span class=\"string\">\"quantity=1;price=5\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">h2</span>&gt;</span>价格计算器<span class=\"tag\">&lt;/<span class=\"title\">h2</span>&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">数量： <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"number\"</span> <span class=\"attribute\">ng-model</span>=<span class=\"value\">\"quantity\"</span>&gt;</span></div><div class=\"line\">价格： <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"number\"</span> <span class=\"attribute\">ng-model</span>=<span class=\"value\">\"price\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"title\">b</span>&gt;</span>总价：<span class=\"tag\">&lt;/<span class=\"title\">b</span>&gt;</span> 0<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p><strong>使用 ng-init 不是很常见。您将在控制器一章中学习到一个更好的初始化数据的方式</strong></p>\n<h2 id=\"重复_HTML_元素\">重复 HTML 元素</h2>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ng-repeat 指令会重复一个 HTML 元素等于读出数组中所有的值</div><div class=\"line\"></div><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span> ng-init=<span class=\"string\">\"names=['Jani','Hege','Kai']\"</span>&gt;</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>使用 ng-repeat 来循环数组<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">ul</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"title\">li</span> <span class=\"attribute\">ng-repeat</span>=<span class=\"value\">\"x in names\"</span>&gt;</span></div><div class=\"line\">      </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"title\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"title\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"AngularJS_控制器\">AngularJS 控制器</h2>\n<p>AngularJS 应用程序被控制器控制。</p>\n<p>ng-controller 指令定义了应用程序控制器。</p>\n<p>控制器是 JavaScript 对象，由标准的 JavaScript 对象的构造函数 创建。</p>\n<p>控制器的 $scope 是控制器所指向的应用程序 HTML 元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span> ng-controller=<span class=\"string\">\"personController\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\">名： &lt;input type=<span class=\"string\">\"text\"</span> ng-model=<span class=\"string\">\"person.firstName\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></span></div><div class=\"line\">姓： <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">ng-model</span>=<span class=\"value\">\"person.lastName\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\">姓名：  </div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">personController</span><span class=\"params\">($scope)</span> </span>{</div><div class=\"line\">    $scope.person = {</div><div class=\"line\">        firstName: <span class=\"string\">\"John\"</span>,</div><div class=\"line\">        lastName: <span class=\"string\">\"Doe\"</span></div><div class=\"line\">    };</div><div class=\"line\">}</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p>实例讲解：</p>\n<p>AngularJS 应用程序由 ng-app 定义。应用程序在 <div> 内运行。</div></p>\n<p>ng-controller 指令把控制器命名为 object。</p>\n<p>函数 personController 是一个标准的 JavaScript 对象的构造函数。</p>\n<p>控制器对象有一个属性：$scope.person。</p>\n<p>person 对象有两个属性：firstName 和 lastName。</p>\n<p>ng-model 指令绑定输入域到控制器的属性（firstName 和 lastName）。</p>\n<h2 id=\"控制器属性\">控制器属性</h2>\n<p>控制器也可以把函数作为对象属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span> ng-controller=<span class=\"string\">\"personController\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\">名： &lt;input type=<span class=\"string\">\"text\"</span> ng-model=<span class=\"string\">\"person.firstName\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></span></div><div class=\"line\">姓： <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">ng-model</span>=<span class=\"value\">\"person.lastName\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\">姓名： </div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">personController</span><span class=\"params\">($scope)</span> </span>{</div><div class=\"line\">    $scope.person = {</div><div class=\"line\">        firstName: <span class=\"string\">\"John\"</span>,</div><div class=\"line\">        lastName: <span class=\"string\">\"Doe\"</span>,</div><div class=\"line\">        fullName: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">            <span class=\"keyword\">var</span> x;</div><div class=\"line\">            x = $scope.person;</div><div class=\"line\">            <span class=\"keyword\">return</span> x.firstName + <span class=\"string\">\" \"</span> + x.lastName;</div><div class=\"line\">        }</div><div class=\"line\">    };</div><div class=\"line\">}</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"控制器方法\">控制器方法</h2>\n<p>控制器也可以带有方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span> ng-controller=<span class=\"string\">\"personController\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\">名： &lt;input type=<span class=\"string\">\"text\"</span> ng-model=<span class=\"string\">\"person.firstName\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></span></div><div class=\"line\">姓： <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">ng-model</span>=<span class=\"value\">\"person.lastName\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\">姓名： </div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">personController</span><span class=\"params\">($scope)</span> </span>{</div><div class=\"line\">    $scope.person = {</div><div class=\"line\">        firstName: <span class=\"string\">\"John\"</span>,</div><div class=\"line\">        lastName: <span class=\"string\">\"Doe\"</span>,</div><div class=\"line\">     };</div><div class=\"line\">     $scope.fullName = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">         <span class=\"keyword\">var</span> x;</div><div class=\"line\">         x = $scope.person;</div><div class=\"line\">         <span class=\"keyword\">return</span> x.firstName + <span class=\"string\">\" \"</span> + x.lastName;</div><div class=\"line\">     };</div><div class=\"line\">}</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"外部文件中的控制器\">外部文件中的控制器</h2>\n<p>在大型的应用程序中，通常是把控制器存储在外部文件中。</p>\n<figure class=\"highlight javascrt\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">ng-app</span>=<span class=\"value\">\"\"</span> <span class=\"attribute\">ng-controller</span>=<span class=\"value\">\"personController\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">名： <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">ng-model</span>=<span class=\"value\">\"person.firstName\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\">姓： <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">ng-model</span>=<span class=\"value\">\"person.lastName\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\">姓名：  </div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">src</span>=<span class=\"value\">\"personController.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"AngularJS_过滤器\">AngularJS 过滤器</h2>\n<p>AngularJS 过滤器可用于转换数据：</p>\n<p>过滤器     描述</p>\n<p>currency     格式化数字为货币格式。</p>\n<p>filter     从数组项中选择一个子集。</p>\n<p>lowercase     格式化字符串为小写。</p>\n<p>orderBy     根据某个表达式排列数组。</p>\n<p>uppercase     格式化字符串为大写。</p>\n<p>uppercase 过滤器格式化字符串为大写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span> ng-controller=<span class=\"string\">\"personController\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>姓名为 <span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h3 id=\"过滤输入\">过滤输入</h3>\n<p>输入过滤器可以通过一个管道字符（|）和一个过滤器添加到指令中，该过滤器后跟一个冒号和一个模型名称。</p>\n<p>filter 过滤器从数组中选择一个子集：</p>\n<h2 id=\"AngularJS_XMLHttpRequest\">AngularJS XMLHttpRequest</h2>\n<p>$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。</p>\n<h3 id=\"AngularJS_$http\">AngularJS $http</h3>\n<p>AngularJS $http 是一个用于读取web服务器上数据的服务。</p>\n<p>$http.get(url) 是用于读取服务器数据的函数。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span> ng-controller=<span class=\"string\">\"customersController\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">ul</span>&gt;</span></span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">li</span> <span class=\"attribute\">ng-repeat</span>=<span class=\"value\">\"x in names\"</span>&gt;</span></div><div class=\"line\">    , </div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"title\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">ul</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">customersController</span><span class=\"params\">($scope,$http)</span> </span>{</div><div class=\"line\">    $http.get(<span class=\"string\">\"http://www.w3cschool.cc/try/angularjs/data/Customers_JSON.php\"</span>)</div><div class=\"line\">    .success(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(response)</span> </span>{$scope.names = response;});</div><div class=\"line\">}</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p>应用解析:</p>\n<p>AngularJS 应用通过 ng-app 定义。应用在 <div> 中执行。</div></p>\n<p>ng-controller 指令设置了 controller 对象 名。</p>\n<p>函数 customersController 是一个标准的 JavaScript 对象构造器。</p>\n<p>控制器对象有一个属性: $scope.names。</p>\n<p>$http.get() 从web服务器上读取静态 JSON 数据。</p>\n<p>服务器数据文件为：  <a href=\"http://www.w3cschool.cc/try/angularjs/data/Customers_JSON.php。\" target=\"_blank\" rel=\"external\">http://www.w3cschool.cc/try/angularjs/data/Customers_JSON.php。</a></p>\n<p>当从服务端载入 JSON 数据时，$scope.names 变为一个数组。</p>\n<p><strong>以上代码也可以用于读取数据库数据。</strong></p>\n<h2 id=\"AngularJS_表格\">AngularJS 表格</h2>\n<p>排序显示</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">html</span>&gt;</span></span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">style</span>&gt;</span><span class=\"css\"></span></div><div class=\"line\"><span class=\"tag\">table</span>, <span class=\"tag\">th</span> , <span class=\"tag\">td</span>  <span class=\"rules\">{</span></div><div class=\"line\">  <span class=\"rule\"><span class=\"attribute\">border</span>:<span class=\"value\"> <span class=\"number\">1px</span> solid grey</span></span>;</div><div class=\"line\">  <span class=\"rule\"><span class=\"attribute\">border-collapse</span>:<span class=\"value\"> collapse</span></span>;</div><div class=\"line\">  <span class=\"rule\"><span class=\"attribute\">padding</span>:<span class=\"value\"> <span class=\"number\">5px</span></span></span>;</div><div class=\"line\"><span class=\"rule\">}</span></div><div class=\"line\"><span class=\"tag\">table</span> <span class=\"tag\">tr</span><span class=\"pseudo\">:nth-child(odd)</span>    <span class=\"rules\">{</span></div><div class=\"line\">  <span class=\"rule\"><span class=\"attribute\">background-color</span>:<span class=\"value\"> <span class=\"hexcolor\">#f1f1f1</span></span></span>;</div><div class=\"line\"><span class=\"rule\">}</span></div><div class=\"line\"><span class=\"tag\">table</span> <span class=\"tag\">tr</span><span class=\"pseudo\">:nth-child(even)</span> <span class=\"rules\">{</span></div><div class=\"line\">  <span class=\"rule\"><span class=\"attribute\">background-color</span>:<span class=\"value\"> <span class=\"hexcolor\">#ffffff</span></span></span>;</div><div class=\"line\"><span class=\"rule\">}</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">head</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">ng-app</span>=<span class=\"value\">\"\"</span> <span class=\"attribute\">ng-controller</span>=<span class=\"value\">\"customersController\"</span>&gt;</span> </div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">table</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">tr</span> <span class=\"attribute\">ng-repeat</span>=<span class=\"value\">\"x in names | orderBy : 'Country'\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"title\">td</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">td</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"title\">td</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">td</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"title\">tr</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">table</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">customersController</span><span class=\"params\">($scope,$http)</span> </span>{</div><div class=\"line\">\t$http.get(<span class=\"string\">\"http://www.w3cschool.cc/try/angularjs/data/Customers_JSON.php\"</span>)</div><div class=\"line\">  .success(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(response)</span> </span>{$scope.names = response;});</div><div class=\"line\">}</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">src</span>=<span class=\"value\">\"http://apps.bdimg.com/libs/angular.js/1.2.15/angular.min.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"AngularJS_HTML_DOM\">AngularJS HTML DOM</h2>\n<p>AngularJS 有自己的 HTML 属性指令。</p>\n<h3 id=\"ng-disabled_指令\">ng-disabled 指令</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span></span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">button</span> <span class=\"attribute\">ng-disabled</span>=<span class=\"value\">\"mySwitch\"</span>&gt;</span>点我！<span class=\"tag\">&lt;/<span class=\"title\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"checkbox\"</span> <span class=\"attribute\">ng-model</span>=<span class=\"value\">\"mySwitch\"</span>&gt;</span>按钮</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h3 id=\"ng-show_指令\">ng-show 指令</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">ng-show</span>=<span class=\"value\">\"true\"</span>&gt;</span>我是可见的。<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">ng-show</span>=<span class=\"value\">\"false\"</span>&gt;</span>我是不可见的。<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p>您可以使用一个评估为 true or false 的表达式（比如 ng-show=”hour &lt; 12”）来隐藏和显示 HTML 元素。</p>\n<h2 id=\"AngularJS_HTML_事件\">AngularJS HTML 事件</h2>\n<p>AngularJS 有自己的 HTML 事件指令。</p>\n<h3 id=\"ng-click_指令\">ng-click 指令</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span> ng-controller=<span class=\"string\">\"myController\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">button</span> <span class=\"attribute\">ng-click</span>=<span class=\"value\">\"count = count + 1\"</span>&gt;</span>点我！<span class=\"tag\">&lt;/<span class=\"title\">button</span>&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h3 id=\"隐藏_HTML_元素\">隐藏 HTML 元素</h3>\n<p>ng-hide 指令用于设置应用的一部分 不可见 。</p>\n<p>ng-hide=”true” 让 HTML 元素 不可见。</p>\n<p>ng-hide=”false” 让元素可见。</p>\n<p>ng-show 指令可用于设置应用中的一部分可见 。</p>\n<p>ng-show=”false” 可以设置 HTML 元素 不可见。</p>\n<p>ng-show=”true” 可以以设置 HTML 元素可见。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=<span class=\"string\">\"\"</span> ng-controller=<span class=\"string\">\"personController\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">button</span> <span class=\"attribute\">ng-click</span>=<span class=\"value\">\"toggle()\"</span>&gt;</span>隐藏/显示<span class=\"tag\">&lt;/<span class=\"title\">button</span>&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">ng-hide</span>=<span class=\"value\">\"myVar\"</span>&gt;</span></div><div class=\"line\">名: <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">ng-model</span>=<span class=\"value\">\"person.firstName\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\">姓: <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">ng-model</span>=<span class=\"value\">\"person.lastName\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">br</span>&gt;</span></div><div class=\"line\">姓名:  </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">personController</span><span class=\"params\">($scope)</span> </span>{</div><div class=\"line\">    $scope.person = {</div><div class=\"line\">        firstName: <span class=\"string\">\"John\"</span>,</div><div class=\"line\">        lastName: <span class=\"string\">\"Doe\"</span></div><div class=\"line\">    };</div><div class=\"line\">    $scope.myVar = <span class=\"literal\">false</span>;</div><div class=\"line\">    $scope.toggle = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">        $scope.myVar = !$scope.myVar;</div><div class=\"line\">    };</div><div class=\"line\">}</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"AngularJS_模块\">AngularJS 模块</h2>\n<p>模块定义了您的应用程序。</p>\n<p>所有的控制器都应该属于一个模块。</p>\n<p>模块保持全局命名空间中的整洁。</p>\n<h3 id=\"AngularJS_模块实例\">AngularJS 模块实例</h3>\n<p>在本实例中，”myApp.js” 包含了一个应用程序模块定义，”myCtrl.js” 包含了一个控制器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">html</span>&gt;</span></span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">ng-app</span>=<span class=\"value\">\"myApp\"</span> <span class=\"attribute\">ng-controller</span>=<span class=\"value\">\"myCtrl\"</span>&gt;</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">src</span>=<span class=\"value\">\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">src</span>=<span class=\"value\">\"myApp.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">src</span>=<span class=\"value\">\"myCtrl.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p>使用一个由 模块 替代的控制器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">html</span>&gt;</span></span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">src</span>=<span class=\"value\">\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">head</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">ng-app</span>=<span class=\"value\">\"myApp\"</span> <span class=\"attribute\">ng-controller</span>=<span class=\"value\">\"myCtrl\"</span>&gt;</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"keyword\">var</span> app = angular.module(<span class=\"string\">\"myApp\"</span>, []);</div><div class=\"line\"></div><div class=\"line\">app.controller(<span class=\"string\">\"myCtrl\"</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">($scope)</span> </span>{</div><div class=\"line\">    $scope.firstName = <span class=\"string\">\"John\"</span>;</div><div class=\"line\">    $scope.lastName = <span class=\"string\">\"Doe\"</span>;</div><div class=\"line\">});</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">html</span>&gt;</span> </div><div class=\"line\"></div><div class=\"line\">###模块定义应放置在何处？</div><div class=\"line\">对于 HTML 应用程序，通常建议把所有的脚本都放置在 <span class=\"tag\">&lt;<span class=\"title\">body</span>&gt;</span> 元素的最底部。</div><div class=\"line\"></div><div class=\"line\">这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。</div><div class=\"line\"></div><div class=\"line\">在上面的多个 AngularJS 实例中，您将看到 AngularJS 库是在文档的 <span class=\"tag\">&lt;<span class=\"title\">head</span>&gt;</span> 区域被加载。</div><div class=\"line\"></div><div class=\"line\">在上面的实例中，AngularJS 在 <span class=\"tag\">&lt;<span class=\"title\">head</span>&gt;</span> 元素中被加载，因为对 angular.module 的调用只能在库加载完成后才能进行。</div><div class=\"line\"></div><div class=\"line\">另一个解决方案是在 <span class=\"tag\">&lt;<span class=\"title\">body</span>&gt;</span> 元素中加载 AngularJS 库，但是必须放置在您的 AngularJS 脚本前面</div></pre></td></tr></table></figure>\n\n<p>javascript<br> &lt;!DOCTYPE html&gt;</p>\n<html><br><body><br><br><div ng-app=\"myApp\" ng-controller=\"myCtrl\"><br><br></div><br><br><script src=\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"></script><br><br><script><br>var app = angular.module(“myApp”, []);<br><br>app.controller(“myCtrl”, function($scope) {<br>    $scope.firstName = “John”;<br>    $scope.lastName = “Doe”;<br>});<br></script><br><br></body><br></html> \n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">###AngularJS 应用程序文件</span></div><div class=\"line\">现在您已经知道模块是什么以及它们是如何工作的，现在您可以尝试创建您自己的应用程序文件。</div><div class=\"line\"></div><div class=\"line\">您的应用程序至少应该有一个模块文件，一个控制器文件。</div><div class=\"line\"></div><div class=\"line\">首先，创建模块文件 <span class=\"string\">\"myApp.js\"</span>：</div></pre></td></tr></table></figure>\n\n<p>javascript<br>var app = angular.module(“myApp”, []); </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">然后，创建控制器文件。本实例中是 <span class=\"string\">\"myCtrl.js\"</span>：</div></pre></td></tr></table></figure>\n\n<p>javascript<br>app.controller(“myCtrl”, function($scope) {<br>    $scope.firstName = “John”;<br>    $scope.lastName = “Doe”;<br>});</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">最后，编辑您的 HTML 页面：</div></pre></td></tr></table></figure>\n\n<p>javascript<br>&lt;!DOCTYPE html&gt;</p>\n<html><br><body><br><br><div ng-app=\"myApp\" ng-controller=\"myCtrl\"><br><br></div><br><br><script src=\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"></script><br><br><script src=\"myApp.js\"></script><br><script src=\"myCtrl.js\"></script><br><br></body><br></html> \n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"preprocessor\">##HTML 表单</span></div></pre></td></tr></table></figure>\n\n<p>javascript</p>\n<div ng-app=\"\" ng-controller=\"formController\"><br>  <form novalidate=\"\"><br>    First Name:<br><br>    <input type=\"text\" ng-model=\"user.firstName\"><br><br>    Last Name:<br><br>    <input type=\"text\" ng-model=\"user.lastName\"><br>    <br><br><br>    <button ng-click=\"reset()\">RESET</button><br>  </form><br>  <p>form = </p><br>  <p>master = </p><br></div>\n\n<script>\nfunction formController ($scope) {\n    $scope.master = {firstName: \"John\", lastName: \"Doe\"};\n    $scope.reset = function() {\n        $scope.user = angular.copy($scope.master);\n    };\n    $scope.reset();\n};\n</script> \n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">*</span><span class=\"keyword\">*</span>HTML 属性 novalidate 用于禁用浏览器的默认验证<span class=\"keyword\">*</span><span class=\"keyword\">*</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">##AngularJS 输入验证</span></div><div class=\"line\">AngularJS 表单和控件可以提供验证功能，并对用户输入的非法数据进行警告。</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">*</span><span class=\"keyword\">*</span>     客户端的验证不能确保用户输入数据的安全，所以服务端的数据验证也是必须的。<span class=\"keyword\">*</span><span class=\"keyword\">*</span></div></pre></td></tr></table></figure>\n\n<p>java<br> &lt;!DOCTYPE html&gt;</p>\n<html><br><br><body><br><h2>Validation Example</h2><br><br><form ng-app=\"\" ng-controller=\"validateCtrl\" name=\"myForm\" novalidate=\"\"><br><br><p>Username:<br><br>  <input type=\"text\" name=\"user\" ng-model=\"user\" required><br>  <span style=\"color:red\" ng-show=\"myForm.user.$dirty && myForm.user.$invalid\"><br>  <span ng-show=\"myForm.user.$error.required\">Username is required.</span><br>  </span><br></p><br><br><p>Email:<br><br>  <input type=\"email\" name=\"email\" ng-model=\"email\" required><br>  <span style=\"color:red\" ng-show=\"myForm.email.$dirty && myForm.email.$invalid\"><br>  <span ng-show=\"myForm.email.$error.required\">Email is required.</span><br>  <span ng-show=\"myForm.email.$error.email\">Invalid email address.</span><br>  </span><br></p><br><br><p><br>  <input type=\"submit\" ng-disabled=\"myForm.user.$dirty && myForm.user.$invalid ||\n  myForm.email.$dirty && myForm.email.$invalid\"><br></p><br><br></form><br><br><script src=\"//apps.bdimg.com/libs/angular.js/1.2.15/angular.min.js\"></script><br><script><br>function validateCtrl($scope) {<br>    $scope.user = ‘John Doe’;<br>    $scope.email = ‘john.doe@gmail.com’;<br>}<br></script><br><br></body><br></html> \n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">##AngularJS Bootstrap</span></div><div class=\"line\"></div><div class=\"line\">AngularJS 的首选样式表是 Twitter Bootstrap， Twitter Bootstrap 是目前最受欢迎的前端框架。</div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">###Bootstrap</span></div><div class=\"line\"></div><div class=\"line\">你可以在你的 AngularJS 应用中加入 Twitter Bootstrap，你可以在你的 &lt;head&gt;元素中添加如下代码:</div></pre></td></tr></table></figure>\n\n<p>javascript</p>\n<link rel=\"stylesheet\" href=\"//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css\">\n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">如果站点在国内，建议使用百度静态资源库的Bootstrap，代码如下：</div></pre></td></tr></table></figure>\n\n<p>javascript</p>\n<link rel=\"stylesheet\" href=\"//apps.bdimg.com/libs/bootstrap/3.2.0/css/bootstrap.min.css\">\n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">以下是一个完整的 HTML 实例, 使用了 AngularJS 指令和 Bootstrap 类。</div><div class=\"line\"></div><div class=\"line\">HTML 代码</div></pre></td></tr></table></figure>\n\n<p>javascript</p>\n<p><html ang-app=\"\"></html></p>\n<head><br><link rel=\"stylesheet\" href=\"http://apps.bdimg.com/libs/bootstrap/3.2.0/css/bootstrap.min.css\"><br></head>\n\n<body ng-controller=\"userController\"><br><div class=\"container\"><br><br><h3>Users</h3><br><br><table class=\"table table-striped\"><br>  <thead><tr><br>    <th>Edit</th><br>    <th>First Name</th><br>    <th>Last Name</th><br>  </tr></thead><br>  <tbody><tr ng-repeat=\"user in users\"><br>    <td><br>      <button class=\"btn\" ng-click=\"editUser(user.id)\"><br>      <span class=\"glyphicon glyphicon-pencil\"></span>&nbsp;&nbsp;Edit<br>      </button><br>    </td><br>    <td></td><br>    <td></td><br>  </tr></tbody><br></table><br><br><hr><br><button class=\"btn btn-success\" ng-click=\"editUser('new')\"><br>  <span class=\"glyphicon glyphicon-user\"></span> Create New User<br></button><br><hr><br><br><h3 ng-show=\"edit\">Create New User:</h3><br><h3 ng-hide=\"edit\">Edit User:</h3><br><br><form class=\"form-horizontal\"><br><div class=\"form-group\"><br>  <label class=\"col-sm-2 control-label\">First Name:</label><br>  <div class=\"col-sm-10\"><br>    <input type=\"text\" ng-model=\"fName\" ng-disabled=\"!edit\" placeholder=\"First Name\"><br>  </div><br></div><br><div class=\"form-group\"><br>  <label class=\"col-sm-2 control-label\">Last Name:</label><br>  <div class=\"col-sm-10\"><br>    <input type=\"text\" ng-model=\"lName\" ng-disabled=\"!edit\" placeholder=\"Last Name\"><br>  </div><br></div><br><div class=\"form-group\"><br>  <label class=\"col-sm-2 control-label\">Password:</label><br>  <div class=\"col-sm-10\"><br>    <input type=\"password\" ng-model=\"passw1\" placeholder=\"Password\"><br>  </div><br></div><br><div class=\"form-group\"><br>  <label class=\"col-sm-2 control-label\">Repeat:</label><br>  <div class=\"col-sm-10\"><br>    <input type=\"password\" ng-model=\"passw2\" placeholder=\"Repeat Password\"><br>  </div><br></div><br></form><br><br><hr><br><button class=\"btn btn-success\" ng-disabled=\"error || incomplete\"><br>  <span class=\"glyphicon glyphicon-save\"></span> Save Changes<br></button><br></div><br><br><script src=\"http://apps.bdimg.com/libs/angular.js/1.2.15/angular.min.js\"></script><br><script src=\"myUsers.js\"></script><br><button ng-click=\"clear()\">清除</button><br><p></p><br><br><p>剩下的字符数：<span ng-bind=\"left()\"></span></p><br><br><br><br><script src=\"myTodoApp.js\"></script><br><script src=\"myTodoCtrl.js\"></script><br><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">应用程序文件 <span class=\"string\">\"myTodoApp.js\"</span>：</div></pre></td></tr></table></figure><br><br>javascript<br>var app = angular.module(“myTodoApp”, []);<br><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">控制器文件 <span class=\"string\">\"myTodoCtrl.js\"</span>：</div></pre></td></tr></table></figure><br><br>javascript<br>app.controller(“myTodoCtrl”, function($scope) {<br>    $scope.message = “”;<br>    $scope.left  = function() {return 100 - $scope.message.length;};<br>    $scope.clear = function() {$scope.message=””;};<br>    $scope.save  = function() {$scope.message=””;};<br>});<br><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">HTML 页面中的一个 &lt;div&gt;，指向 <span class=\"variable\">ng-app=</span><span class=\"string\">\"myTodoApp\"</span> 和 <span class=\"variable\">ng-controller=</span><span class=\"string\">\"myTodoCtrl\"</span>：</div></pre></td></tr></table></figure><br><br>javascript<br><div ng-app=\"myTodoApp\" ng-controller=\"myTodoCtrl\"><br><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">一个 ng-model 指令，绑定一个 textarea 到控制器变量 <span class=\"class\"><span class=\"keyword\">message</span>：</span></div></pre></td></tr></table></figure><br><br>javascript<br><textarea ng-model=\"message\" cols=\"40\" rows=\"10\"></textarea><br><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">两个 ng-click 事件，调用控制器函数 <span class=\"function\">clear</span>() 和 <span class=\"function\">save</span>()：</div></pre></td></tr></table></figure><br><br>javascript<br><button ng-click=\"save()\">保存</button><br><button ng-click=\"clear()\">清除</button><br><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">一个 ng-bind 指令，绑定控制器函数 <span class=\"keyword\">left</span>() 到一个 &lt;span&gt;，字符会向左对齐显示：</div></pre></td></tr></table></figure><br><br>javascript<br>剩下的字符数：<span ng-bind=\"left()\"></span><br><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">两个应用程序库被添加到 HTML 页面：</div></pre></td></tr></table></figure><br><br>javascript<br><script src=\"myTodoApp.js\"></script><br><script src=\"myTodoCtrl.js\"></script><br><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"gherkin\"><span class=\"keyword\">*</span><span class=\"keyword\">*</span><span class=\"keyword\">*</span>[更多AngularJS参考手册](http://www.w3cschool.cc/angularjs/angularjs-reference.html)<span class=\"keyword\">*</span><span class=\"keyword\">*</span><span class=\"keyword\">*</span></span></div><div class=\"line\"><span class=\"variable\">&lt;/body&gt;</span></div><div class=\"line\"><span class=\"variable\">&lt;/html&gt;</span></div></pre></td></tr></table></figure><br><br>###Bootstrap 类解析<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">元素        Bootstrap 类       定义</div><div class=\"line\">&lt;div&gt;       container           内容容器</div><div class=\"line\">&lt;table&gt;   table               表格</div><div class=\"line\">&lt;table&gt;   table-striped       带条纹背景的表格</div><div class=\"line\">&lt;button&gt;  btn               按钮</div><div class=\"line\">&lt;button&gt;  btn-success       成功按钮</div><div class=\"line\">&lt;span&gt;      glyphicon           字形图标</div><div class=\"line\">&lt;span&gt;      glyphicon-pencil  铅笔图标</div><div class=\"line\">&lt;span&gt;      glyphicon-user    用户图标</div><div class=\"line\">&lt;span&gt;      glyphicon-save    保存图标</div><div class=\"line\">&lt;form&gt;      form-horizontal   水平表格</div><div class=\"line\">&lt;div&gt;     form-group        表单组</div><div class=\"line\">&lt;label&gt;   control-label     控制器标签</div><div class=\"line\">&lt;label&gt;   col-sm-<span class=\"number\">2</span>          跨越 <span class=\"number\">2</span> 列</div><div class=\"line\">&lt;div&gt;     col-sm-<span class=\"number\">10</span>         跨越 <span class=\"number\">10</span> 列</div></pre></td></tr></table></figure><br><br>###JavaScript 代码<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">userController</span><span class=\"params\">($scope)</span> </span>{</div><div class=\"line\">$scope.fName = <span class=\"string\">''</span>;</div><div class=\"line\">$scope.lName = <span class=\"string\">''</span>;</div><div class=\"line\">$scope.passw1 = <span class=\"string\">''</span>;</div><div class=\"line\">$scope.passw2 = <span class=\"string\">''</span>;</div><div class=\"line\">$scope.users = [</div><div class=\"line\">{id:<span class=\"number\">1</span>, fName:<span class=\"string\">'Hege'</span>,  lName:<span class=\"string\">\"Pege\"</span> },</div><div class=\"line\">{id:<span class=\"number\">2</span>, fName:<span class=\"string\">'Kim'</span>,   lName:<span class=\"string\">\"Pim\"</span> },</div><div class=\"line\">{id:<span class=\"number\">3</span>, fName:<span class=\"string\">'Sal'</span>,   lName:<span class=\"string\">\"Smith\"</span> },</div><div class=\"line\">{id:<span class=\"number\">4</span>, fName:<span class=\"string\">'Jack'</span>,  lName:<span class=\"string\">\"Jones\"</span> },</div><div class=\"line\">{id:<span class=\"number\">5</span>, fName:<span class=\"string\">'John'</span>,  lName:<span class=\"string\">\"Doe\"</span> },</div><div class=\"line\">{id:<span class=\"number\">6</span>, fName:<span class=\"string\">'Peter'</span>, lName:<span class=\"string\">\"Pan\"</span> }</div><div class=\"line\">];</div><div class=\"line\">$scope.edit = <span class=\"literal\">true</span>;</div><div class=\"line\">$scope.error = <span class=\"literal\">false</span>;</div><div class=\"line\">$scope.incomplete = <span class=\"literal\">false</span>;</div><div class=\"line\"></div><div class=\"line\">$scope.editUser = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(id)</span> </span>{</div><div class=\"line\">  <span class=\"keyword\">if</span> (id == <span class=\"string\">'new'</span>) {</div><div class=\"line\">    $scope.edit = <span class=\"literal\">true</span>;</div><div class=\"line\">    $scope.incomplete = <span class=\"literal\">true</span>;</div><div class=\"line\">    $scope.fName = <span class=\"string\">''</span>;</div><div class=\"line\">    $scope.lName = <span class=\"string\">''</span>;</div><div class=\"line\">    } <span class=\"keyword\">else</span> {</div><div class=\"line\">    $scope.edit = <span class=\"literal\">false</span>;</div><div class=\"line\">    $scope.fName = $scope.users[id-<span class=\"number\">1</span>].fName;</div><div class=\"line\">    $scope.lName = $scope.users[id-<span class=\"number\">1</span>].lName;</div><div class=\"line\">  }</div><div class=\"line\">};</div><div class=\"line\"></div><div class=\"line\">$scope.$watch(<span class=\"string\">'passw1'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{$scope.test();});</div><div class=\"line\">$scope.$watch(<span class=\"string\">'passw2'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{$scope.test();});</div><div class=\"line\">$scope.$watch(<span class=\"string\">'fName'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{$scope.test();});</div><div class=\"line\">$scope.$watch(<span class=\"string\">'lName'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{$scope.test();});</div><div class=\"line\"></div><div class=\"line\">$scope.test = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">  <span class=\"keyword\">if</span> ($scope.passw1 !== $scope.passw2) {</div><div class=\"line\">    $scope.error = <span class=\"literal\">true</span>;</div><div class=\"line\">    } <span class=\"keyword\">else</span> {</div><div class=\"line\">    $scope.error = <span class=\"literal\">false</span>;</div><div class=\"line\">  }</div><div class=\"line\">  $scope.incomplete = <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> ($scope.edit && (!$scope.fName.length ||</div><div class=\"line\">  !$scope.lName.length ||</div><div class=\"line\">  !$scope.passw1.length || !$scope.passw2.length)) {</div><div class=\"line\">       $scope.incomplete = <span class=\"literal\">true</span>;</div><div class=\"line\">  }</div><div class=\"line\">};</div><div class=\"line\"></div><div class=\"line\">}</div></pre></td></tr></table></figure><br><br>###JavaScript 代码解析<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scope 属性     用途</div><div class=\"line\">$scope.fName  模型变量 (用户名)</div><div class=\"line\">$scope.lName  模型变量 (用户姓)</div><div class=\"line\">$scope.passw1   模型变量 (用户密码 <span class=\"number\">1</span>)</div><div class=\"line\">$scope.passw2   模型变量 (用户密码 <span class=\"number\">2</span>)</div><div class=\"line\">$scope.users  模型变量 (用户的数组)</div><div class=\"line\">$scope.edit   当用户点击创建用户时设置为<span class=\"literal\">true</span>。</div><div class=\"line\">$scope.error  如果 passw1 不等于 passw2 设置为 <span class=\"literal\">true</span></div><div class=\"line\">$scope.incomplete   如果每个字段都为空(length = <span class=\"number\">0</span>)设置为 <span class=\"literal\">true</span></div><div class=\"line\">$scope.editUser   设置模型变量</div><div class=\"line\">$scope.watch  监控模型变量</div><div class=\"line\">$scope.test   验证模型变量的错误和完整性</div></pre></td></tr></table></figure><br><br>##AngularJS Include（包含）<br>使用 AngularJS, 你可以在 HTML 中包含 HTML 文件。<br><br>###服务端包含<br><br>大部分web服务器支持服务端脚本的包含 (SSI：Server Side Includes)。<br><br>使用 SSI, 你可以在HTML页面发送至浏览器前包含 HTML。<br>PHP 实例<br><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"preprocessor\">&lt;?php</span> <span class=\"keyword\">require</span>(<span class=\"string\">\"navigation.php\"</span>); <span class=\"preprocessor\">?&gt;</span></div></pre></td></tr></table></figure><br><br>###客户端包含<br><br>客户端在 HTML 中使用 JavaScript 有多种方式可以包含 HTML 文件。<br><br>通常我们使用 http 请求 (AJAX) 从服务端获取数据，返回的数据我们可以通过 使用 innerHTML 写入到 HTML 元素中。<br><br><br>###AngularJS 包含<br><br>使用 AngularJS, 你可以使用 ng-include 指令来包含 HTML 内容:<br>实例<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;body&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">class</span>=<span class=\"value\">\"container\"</span>&gt;</span></span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">ng-include</span>=<span class=\"value\">\"'myUsers_List.htm'\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">ng-include</span>=<span class=\"value\">\"'myUsers_Form.htm'\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></div></pre></td></tr></table></figure><br><br></div></body>\n\n<h2 id=\"AngularJS_应用程序实例\">AngularJS 应用程序实例</h2>\n<h3 id=\"Html文件\">Html文件</h3>\n<p>```javascript<br> <div ng-app=\"myTodoApp\" ng-controller=\"myTodoCtrl\"></div></p>\n<h2>我的笔记</h2>\n\n<p><textarea ng-model=\"message\" cols=\"40\" rows=\"10\"></textarea></p>\n\n<p></p><p></p>\n<button ng-click=\"save()\">保存</button>","source":"_posts/Angularjs.md","raw":"title: AngularJS\ndate: 2014-12-06 00:32:00\ncategories: web前端\ntags: [AngularJS,web前端,javascript]\ndesctiption: 一篇自己对java NIO的理解\n\n---\n\n##AngularJS简介\n\nAngularJS 是一个 JavaScript 框架。它可通过 script 标签添加到 HTML 页面。\n\nAngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML。\n\nAngularJS 是以一个 JavaScript 文件形式发布的，可通过 script 标签添加到网页中：\n\n<!--<script src=\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"></script> -->\n\n**我们建议把脚本放在 <body> 元素的底部。这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。**\n\n<!--more-->\n\n##AngularJS 扩展了 HTML\nAngularJS 通过 ng-directives 扩展了 HTML。\n\n**ng-app** 指令定义一个 AngularJS 应用程序。\n\n**ng-model** 指令把元素值（比如输入域的值）绑定到应用程序。\n\n**ng-bind** 指令把应用程序数据绑定到 HTML 视图。\n\n例：\n```javascript\n<!DOCTYPE html>\n<html>\n<body>\n\n<div ng-app=\"\">\n  <p>在输入框中尝试输入：</p>\n  <p>姓名：<input type=\"text\" ng-model=\"name\"></p>\n  <p ng-bind=\"name\"></p>\n</div>\n\n<script src=\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"></script>\n\n</body>\n</html>\n```\n\n实例讲解：\n\n当网页加载完毕，AngularJS 自动开启。\n\nng-app 指令告诉 AngularJS，div 元素是 AngularJS 应用程序 的\"所有者\"。\n\nng-model 指令把输入域的值绑定到应用程序变量 name。\n\nng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。\n\n**如果您移除了 ng-app 指令，HTML 将直接把表达式显示出来，不会去计算表达式的结果。**\n\n##AngularJS 表达式\nAngularJS 表达式写在双大括号内：{{ expression }}。\n\nAngularJS 表达式把数据绑定到 HTML，这与 ng-bind 指令有异曲同工之妙。\n\nAngularJS 将在表达式书写的位置\"输出\"数据。\n\nAngularJS 表达式 很像 JavaScript 表达式：它们可以包含文字、运算符和变量。\n\n实例 {{ 5 + 5 }} 或 {{ firstName + \" \" + lastName }}\n\n##AngularJS 对象\nAngularJS 对象就像 JavaScript 对象：\n\n```javascript\n<div ng-app=\"\" ng-init=\"person={firstName:'John',lastName:'Doe'}\">\n\n<p>姓为 {{ person.lastName }}</p>\n\n</div> \n```\n\n##AngularJS 数组\nAngularJS 数组就像 JavaScript 数组：\n```javascript\n<div ng-app=\"\" ng-init=\"points=[1,15,19,2,40]\">\n\n<p>第三个值为 {{ points[2] }}</p>\n\n</div> \n```\n\n##AngularJS 指令\nAngularJS 通过被称为 指令 的新属性来扩展 HTML\n\nAngularJS 指令是扩展的 HTML 属性，带有前缀 ng-。\n\nng-app 指令初始化一个 AngularJS 应用程序。\n\nng-init 指令初始化应用程序数据。\n\nng-model 指令把应用程序数据绑定到 HTML 元素。\n\n**一个网页可以包含多个运行在不同元素中的 AngularJS 应用程序。**\n\n##数据绑定\n{{ firstName }} 是通过 ng-model=\"firstName\" 进行同步。\n\n在下一个实例中，两个文本域是通过两个 ng-model 指令同步的：\n```javascript\n<div ng-app=\"\" ng-init=\"quantity=1;price=5\">\n\n<h2>价格计算器</h2>\n\n数量： <input type=\"number\" ng-model=\"quantity\">\n价格： <input type=\"number\" ng-model=\"price\">\n\n<p><b>总价：</b> {{ quantity * price }}</p>\n\n</div>\n```\n**使用 ng-init 不是很常见。您将在控制器一章中学习到一个更好的初始化数据的方式**\n\n##重复 HTML 元素\n\n```javascript\nng-repeat 指令会重复一个 HTML 元素等于读出数组中所有的值\n\n<div ng-app=\"\" ng-init=\"names=['Jani','Hege','Kai']\">\n  <p>使用 ng-repeat 来循环数组</p>\n  <ul>\n    <li ng-repeat=\"x in names\">\n      {{ x }}\n    </li>\n  </ul>\n<div>\n```\n\n##AngularJS 控制器\nAngularJS 应用程序被控制器控制。\n\nng-controller 指令定义了应用程序控制器。\n\n控制器是 JavaScript 对象，由标准的 JavaScript 对象的构造函数 创建。\n\n控制器的 $scope 是控制器所指向的应用程序 HTML 元素。\n\n```javascript\n<div ng-app=\"\" ng-controller=\"personController\">\n\n名： <input type=\"text\" ng-model=\"person.firstName\"><br>\n姓： <input type=\"text\" ng-model=\"person.lastName\"><br>\n<br>\n姓名： {{person.firstName + \" \" + person.lastName}}\n\n</div>\n\n<script>\nfunction personController($scope) {\n    $scope.person = {\n        firstName: \"John\",\n        lastName: \"Doe\"\n    };\n}\n</script>\n```\n\n实例讲解：\n\nAngularJS 应用程序由 ng-app 定义。应用程序在 <div> 内运行。\n\nng-controller 指令把控制器命名为 object。\n\n函数 personController 是一个标准的 JavaScript 对象的构造函数。\n\n控制器对象有一个属性：$scope.person。\n\nperson 对象有两个属性：firstName 和 lastName。\n\nng-model 指令绑定输入域到控制器的属性（firstName 和 lastName）。\n\n##控制器属性\n控制器也可以把函数作为对象属性\n```javascript\n<div ng-app=\"\" ng-controller=\"personController\">\n\n名： <input type=\"text\" ng-model=\"person.firstName\"><br>\n姓： <input type=\"text\" ng-model=\"person.lastName\"><br>\n<br>\n姓名： {{person.fullName()}}\n\n</div>\n\n<script>\nfunction personController($scope) {\n    $scope.person = {\n        firstName: \"John\",\n        lastName: \"Doe\",\n        fullName: function() {\n            var x;\n            x = $scope.person;\n            return x.firstName + \" \" + x.lastName;\n        }\n    };\n}\n</script> \n```\n\n\n##控制器方法\n控制器也可以带有方法\n```javascript\n<div ng-app=\"\" ng-controller=\"personController\">\n\n名： <input type=\"text\" ng-model=\"person.firstName\"><br>\n姓： <input type=\"text\" ng-model=\"person.lastName\"><br>\n<br>\n姓名： {{fullName()}}\n\n</div>\n\n<script>\nfunction personController($scope) {\n    $scope.person = {\n        firstName: \"John\",\n        lastName: \"Doe\",\n     };\n     $scope.fullName = function() {\n         var x;\n         x = $scope.person;\n         return x.firstName + \" \" + x.lastName;\n     };\n}\n</script> \n```\n\n##外部文件中的控制器\n在大型的应用程序中，通常是把控制器存储在外部文件中。\n\n\n```javascrt\n\n<div ng-app=\"\" ng-controller=\"personController\">\n\n名： <input type=\"text\" ng-model=\"person.firstName\"><br>\n姓： <input type=\"text\" ng-model=\"person.lastName\"><br>\n<br>\n姓名： {{person.firstName + \" \" + person.lastName}}\n\n</div>\n\n<script src=\"personController.js\"></script> \n```\n\n##AngularJS 过滤器\nAngularJS 过滤器可用于转换数据：\n\n过滤器     描述\n\ncurrency     格式化数字为货币格式。\n\nfilter \t从数组项中选择一个子集。\n\nlowercase \t格式化字符串为小写。\n\norderBy \t根据某个表达式排列数组。\n\nuppercase \t格式化字符串为大写。\n\n\nuppercase 过滤器格式化字符串为大写：\n\n```javascript\n<div ng-app=\"\" ng-controller=\"personController\">\n\n<p>姓名为 {{ person.lastName | 'lowercase' }}</p>\n\n</div> \n```\n\n###过滤输入\n输入过滤器可以通过一个管道字符（|）和一个过滤器添加到指令中，该过滤器后跟一个冒号和一个模型名称。\n\nfilter 过滤器从数组中选择一个子集：\n\n\n\n##AngularJS XMLHttpRequest\n$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。\n\n###AngularJS $http\n\nAngularJS $http 是一个用于读取web服务器上数据的服务。\n\n$http.get(url) 是用于读取服务器数据的函数。 \n\n```javascript\n<div ng-app=\"\" ng-controller=\"customersController\">\n\n<ul>\n  <li ng-repeat=\"x in names\">\n    {{ x.Name + ', ' + x.Country }}\n  </li>\n</ul>\n\n</div>\n\n<script>\nfunction customersController($scope,$http) {\n    $http.get(\"http://www.w3cschool.cc/try/angularjs/data/Customers_JSON.php\")\n    .success(function(response) {$scope.names = response;});\n}\n</script> \n```\n\n应用解析:\n\nAngularJS 应用通过 ng-app 定义。应用在 <div> 中执行。\n\nng-controller 指令设置了 controller 对象 名。\n\n函数 customersController 是一个标准的 JavaScript 对象构造器。\n\n控制器对象有一个属性: $scope.names。\n\n$http.get() 从web服务器上读取静态 JSON 数据。\n\n服务器数据文件为：  http://www.w3cschool.cc/try/angularjs/data/Customers_JSON.php。\n\n当从服务端载入 JSON 数据时，$scope.names 变为一个数组。\n\n**以上代码也可以用于读取数据库数据。**\n\n##AngularJS 表格\n\n排序显示\n```javascript\n<!DOCTYPE html>\n<html>\n<head>\n<style>\ntable, th , td  {\n  border: 1px solid grey;\n  border-collapse: collapse;\n  padding: 5px;\n}\ntable tr:nth-child(odd)    {\n  background-color: #f1f1f1;\n}\ntable tr:nth-child(even) {\n  background-color: #ffffff;\n}\n</style>\n</head>\n\n<body>\n\n<div ng-app=\"\" ng-controller=\"customersController\"> \n\n<table>\n  <tr ng-repeat=\"x in names | orderBy : 'Country'\">\n    <td>{{ x.Name }}</td>\n    <td>{{ x.Country }}</td>\n  </tr>\n</table>\n\n</div>\n\n<script>\nfunction customersController($scope,$http) {\n\t$http.get(\"http://www.w3cschool.cc/try/angularjs/data/Customers_JSON.php\")\n  .success(function(response) {$scope.names = response;});\n}\n</script>\n\n<script src=\"http://apps.bdimg.com/libs/angular.js/1.2.15/angular.min.js\"></script>\n\n</body>\n</html>\n```\n\n##AngularJS HTML DOM\n\nAngularJS 有自己的 HTML 属性指令。\n\n###ng-disabled 指令\n\n```javascript\n<div ng-app=\"\">\n\n<p>\n<button ng-disabled=\"mySwitch\">点我！</button>\n</p>\n\n<p>\n<input type=\"checkbox\" ng-model=\"mySwitch\">按钮\n</p>\n\n</div> \n```\n\n###ng-show 指令\n\n```javascript\n<div ng-app=\"\">\n\n<p ng-show=\"true\">我是可见的。</p>\n\n<p ng-show=\"false\">我是不可见的。</p>\n\n</div> \n```\n您可以使用一个评估为 true or false 的表达式（比如 ng-show=\"hour < 12\"）来隐藏和显示 HTML 元素。\n\n##AngularJS HTML 事件\nAngularJS 有自己的 HTML 事件指令。\n\n###ng-click 指令\n```javascript\n<div ng-app=\"\" ng-controller=\"myController\">\n\n<button ng-click=\"count = count + 1\">点我！</button>\n\n<p>{{ count }}</p>\n\n</div>\n```\n\n###隐藏 HTML 元素\nng-hide 指令用于设置应用的一部分 不可见 。\n\nng-hide=\"true\" 让 HTML 元素 不可见。\n\nng-hide=\"false\" 让元素可见。\n\nng-show 指令可用于设置应用中的一部分可见 。\n\nng-show=\"false\" 可以设置 HTML 元素 不可见。\n\nng-show=\"true\" 可以以设置 HTML 元素可见。\n\n```javascript\n<div ng-app=\"\" ng-controller=\"personController\">\n\n<button ng-click=\"toggle()\">隐藏/显示</button>\n\n<p ng-hide=\"myVar\">\n名: <input type=\"text\" ng-model=\"person.firstName\"><br>\n姓: <input type=\"text\" ng-model=\"person.lastName\"><br>\n<br>\n姓名: {{person.firstName + \" \" + person.lastName}}\n</p>\n\n</div>\n\n<script>\nfunction personController($scope) {\n    $scope.person = {\n        firstName: \"John\",\n        lastName: \"Doe\"\n    };\n    $scope.myVar = false;\n    $scope.toggle = function() {\n        $scope.myVar = !$scope.myVar;\n    };\n}\n</script> \n```\n\n##AngularJS 模块\n\n模块定义了您的应用程序。\n\n所有的控制器都应该属于一个模块。\n\n模块保持全局命名空间中的整洁。\n\n###AngularJS 模块实例\n\n在本实例中，\"myApp.js\" 包含了一个应用程序模块定义，\"myCtrl.js\" 包含了一个控制器：\n\n```javascript\n<!DOCTYPE html>\n<html>\n<body>\n\n<div ng-app=\"myApp\" ng-controller=\"myCtrl\">\n{{ firstName + \" \" + lastName }}\n</div>\n\n<script src=\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"></script>\n\n<script src=\"myApp.js\"></script>\n<script src=\"myCtrl.js\"></script>\n\n</body>\n</html> \n```\n\n使用一个由 模块 替代的控制器：\n\n```javascript\n<!DOCTYPE html>\n<html>\n<head>\n<script src=\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"></script>\n</head>\n\n<body>\n\n<div ng-app=\"myApp\" ng-controller=\"myCtrl\">\n{{ firstName + \" \" + lastName }}\n</div>\n\n<script>\nvar app = angular.module(\"myApp\", []);\n\napp.controller(\"myCtrl\", function($scope) {\n    $scope.firstName = \"John\";\n    $scope.lastName = \"Doe\";\n});\n</script>\n\n</body>\n</html> \n\n###模块定义应放置在何处？\n对于 HTML 应用程序，通常建议把所有的脚本都放置在 <body> 元素的最底部。\n\n这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。\n\n在上面的多个 AngularJS 实例中，您将看到 AngularJS 库是在文档的 <head> 区域被加载。\n\n在上面的实例中，AngularJS 在 <head> 元素中被加载，因为对 angular.module 的调用只能在库加载完成后才能进行。\n\n另一个解决方案是在 <body> 元素中加载 AngularJS 库，但是必须放置在您的 AngularJS 脚本前面\n\n```javascript\n <!DOCTYPE html>\n<html>\n<body>\n\n<div ng-app=\"myApp\" ng-controller=\"myCtrl\">\n{{ firstName + \" \" + lastName }}\n</div>\n\n<script src=\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"></script>\n\n<script>\nvar app = angular.module(\"myApp\", []);\n\napp.controller(\"myCtrl\", function($scope) {\n    $scope.firstName = \"John\";\n    $scope.lastName = \"Doe\";\n});\n</script>\n\n</body>\n</html> \n```\n\n###AngularJS 应用程序文件\n现在您已经知道模块是什么以及它们是如何工作的，现在您可以尝试创建您自己的应用程序文件。\n\n您的应用程序至少应该有一个模块文件，一个控制器文件。\n\n首先，创建模块文件 \"myApp.js\"：\n\n```javascript\nvar app = angular.module(\"myApp\", []); \n```\n然后，创建控制器文件。本实例中是 \"myCtrl.js\"：\n\n```javascript\napp.controller(\"myCtrl\", function($scope) {\n    $scope.firstName = \"John\";\n    $scope.lastName = \"Doe\";\n});\n```\n\n最后，编辑您的 HTML 页面：\n\n```javascript\n<!DOCTYPE html>\n<html>\n<body>\n\n<div ng-app=\"myApp\" ng-controller=\"myCtrl\">\n{{ firstName + \" \" + lastName }}\n</div>\n\n<script src=\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"></script>\n\n<script src=\"myApp.js\"></script>\n<script src=\"myCtrl.js\"></script>\n\n</body>\n</html> \n```\n##HTML 表单\n\n```javascript\n<div ng-app=\"\" ng-controller=\"formController\">\n  <form novalidate>\n    First Name:<br>\n    <input type=\"text\" ng-model=\"user.firstName\"><br>\n    Last Name:<br>\n    <input type=\"text\" ng-model=\"user.lastName\">\n    <br><br>\n    <button ng-click=\"reset()\">RESET</button>\n  </form>\n  <p>form = {{user}}</p>\n  <p>master = {{master}}</p>\n</div>\n\n<script>\nfunction formController ($scope) {\n    $scope.master = {firstName: \"John\", lastName: \"Doe\"};\n    $scope.reset = function() {\n        $scope.user = angular.copy($scope.master);\n    };\n    $scope.reset();\n};\n</script> \n```\n\n**HTML 属性 novalidate 用于禁用浏览器的默认验证**\n\n##AngularJS 输入验证\nAngularJS 表单和控件可以提供验证功能，并对用户输入的非法数据进行警告。\n\n**     客户端的验证不能确保用户输入数据的安全，所以服务端的数据验证也是必须的。**\n\n```java\n <!DOCTYPE html>\n<html>\n\n<body>\n<h2>Validation Example</h2>\n\n<form  ng-app=\"\"  ng-controller=\"validateCtrl\"\nname=\"myForm\" novalidate>\n\n<p>Username:<br>\n  <input type=\"text\" name=\"user\" ng-model=\"user\" required>\n  <span style=\"color:red\" ng-show=\"myForm.user.$dirty && myForm.user.$invalid\">\n  <span ng-show=\"myForm.user.$error.required\">Username is required.</span>\n  </span>\n</p>\n\n<p>Email:<br>\n  <input type=\"email\" name=\"email\" ng-model=\"email\" required>\n  <span style=\"color:red\" ng-show=\"myForm.email.$dirty && myForm.email.$invalid\">\n  <span ng-show=\"myForm.email.$error.required\">Email is required.</span>\n  <span ng-show=\"myForm.email.$error.email\">Invalid email address.</span>\n  </span>\n</p>\n\n<p>\n  <input type=\"submit\"\n  ng-disabled=\"myForm.user.$dirty && myForm.user.$invalid ||\n  myForm.email.$dirty && myForm.email.$invalid\">\n</p>\n\n</form>\n\n<script src=\"//apps.bdimg.com/libs/angular.js/1.2.15/angular.min.js\"></script>\n<script>\nfunction validateCtrl($scope) {\n    $scope.user = 'John Doe';\n    $scope.email = 'john.doe@gmail.com';\n}\n</script>\n\n</body>\n</html> \n```\n\n##AngularJS Bootstrap\n\nAngularJS 的首选样式表是 Twitter Bootstrap， Twitter Bootstrap 是目前最受欢迎的前端框架。\n\n###Bootstrap\n\n你可以在你的 AngularJS 应用中加入 Twitter Bootstrap，你可以在你的 <head>元素中添加如下代码:\n```javascript\n<link rel=\"stylesheet\" href=\"//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css\">\n```\n如果站点在国内，建议使用百度静态资源库的Bootstrap，代码如下：\n```javascript\n<link rel=\"stylesheet\" href=\"//apps.bdimg.com/libs/bootstrap/3.2.0/css/bootstrap.min.css\">\n```\n以下是一个完整的 HTML 实例, 使用了 AngularJS 指令和 Bootstrap 类。\n\nHTML 代码\n```javascript\n<html ang-app=\"\">\n<head>\n<link rel=\"stylesheet\" href=\"http://apps.bdimg.com/libs/bootstrap/3.2.0/css/bootstrap.min.css\">\n</head>\n\n<body ng-controller=\"userController\">\n<div class=\"container\">\n\n<h3>Users</h3>\n\n<table class=\"table table-striped\">\n  <thead><tr>\n    <th>Edit</th>\n    <th>First Name</th>\n    <th>Last Name</th>\n  </tr></thead>\n  <tbody><tr ng-repeat=\"user in users\">\n    <td>\n      <button class=\"btn\" ng-click=\"editUser(user.id)\">\n      <span class=\"glyphicon glyphicon-pencil\"></span>&nbsp;&nbsp;Edit\n      </button>\n    </td>\n    <td>{{ user.fName }}</td>\n    <td>{{ user.lName }}</td>\n  </tr></tbody>\n</table>\n\n<hr>\n<button class=\"btn btn-success\" ng-click=\"editUser('new')\">\n  <span class=\"glyphicon glyphicon-user\"></span> Create New User\n</button>\n<hr>\n\n<h3 ng-show=\"edit\">Create New User:</h3>\n<h3 ng-hide=\"edit\">Edit User:</h3>\n\n<form class=\"form-horizontal\">\n<div class=\"form-group\">\n  <label class=\"col-sm-2 control-label\">First Name:</label>\n  <div class=\"col-sm-10\">\n    <input type=\"text\" ng-model=\"fName\" ng-disabled=\"!edit\" placeholder=\"First Name\">\n  </div>\n</div>\n<div class=\"form-group\">\n  <label class=\"col-sm-2 control-label\">Last Name:</label>\n  <div class=\"col-sm-10\">\n    <input type=\"text\" ng-model=\"lName\" ng-disabled=\"!edit\" placeholder=\"Last Name\">\n  </div>\n</div>\n<div class=\"form-group\">\n  <label class=\"col-sm-2 control-label\">Password:</label>\n  <div class=\"col-sm-10\">\n    <input type=\"password\" ng-model=\"passw1\" placeholder=\"Password\">\n  </div>\n</div>\n<div class=\"form-group\">\n  <label class=\"col-sm-2 control-label\">Repeat:</label>\n  <div class=\"col-sm-10\">\n    <input type=\"password\" ng-model=\"passw2\" placeholder=\"Repeat Password\">\n  </div>\n</div>\n</form>\n\n<hr>\n<button class=\"btn btn-success\" ng-disabled=\"error || incomplete\">\n  <span class=\"glyphicon glyphicon-save\"></span> Save Changes\n</button>\n</div>\n\n<script src = \"http://apps.bdimg.com/libs/angular.js/1.2.15/angular.min.js\"></script>\n<script src = \"myUsers.js\"></script>\n<button ng-click=\"clear()\">清除</button>\n</p>\n\n<p>剩下的字符数：<span ng-bind=\"left()\"></span></p>\n\n</div>\n\n<script src=\"myTodoApp.js\"></script>\n<script src=\"myTodoCtrl.js\"></script> \n```\n应用程序文件 \"myTodoApp.js\"：\n\n```javascript\nvar app = angular.module(\"myTodoApp\", []); \n```\n\n控制器文件 \"myTodoCtrl.js\"：\n\n```javascript\napp.controller(\"myTodoCtrl\", function($scope) {\n    $scope.message = \"\";\n    $scope.left  = function() {return 100 - $scope.message.length;};\n    $scope.clear = function() {$scope.message=\"\";};\n    $scope.save  = function() {$scope.message=\"\";};\n}); \n```\n\nHTML 页面中的一个 <div>，指向 ng-app=\"myTodoApp\" 和 ng-controller=\"myTodoCtrl\"：\n```javascript\n<div ng-app=\"myTodoApp\" ng-controller=\"myTodoCtrl\">\n```\n\n一个 ng-model 指令，绑定一个 textarea 到控制器变量 message：\n```javascript\n<textarea ng-model=\"message\" cols=\"40\" rows=\"10\"></textarea>\n```\n两个 ng-click 事件，调用控制器函数 clear() 和 save()：\n```javascript\n<button ng-click=\"save()\">保存</button>\n<button ng-click=\"clear()\">清除</button>\n```\n一个 ng-bind 指令，绑定控制器函数 left() 到一个 <span>，字符会向左对齐显示：\n```javascript\n剩下的字符数：<span ng-bind=\"left()\"></span>\n```\n\n两个应用程序库被添加到 HTML 页面：\n```javascript\n<script src=\"myTodoApp.js\"></script>\n<script src=\"myTodoCtrl.js\"></script>\n```\n\n\n***[更多AngularJS参考手册](http://www.w3cschool.cc/angularjs/angularjs-reference.html)***\n</body>\n</html>\n\n```\n\n###Bootstrap 类解析\n\n```javascript\n元素        Bootstrap 类       定义\n<div>       container           内容容器\n<table>   table               表格\n<table>   table-striped       带条纹背景的表格\n<button>  btn               按钮\n<button>  btn-success       成功按钮\n<span>      glyphicon           字形图标\n<span>      glyphicon-pencil  铅笔图标\n<span>      glyphicon-user    用户图标\n<span>      glyphicon-save    保存图标\n<form>      form-horizontal   水平表格\n<div>     form-group        表单组\n<label>   control-label     控制器标签\n<label>   col-sm-2          跨越 2 列\n<div>     col-sm-10         跨越 10 列\n\n```\n\n\n###JavaScript 代码\n\n\n\n```javascript\nfunction userController($scope) {\n$scope.fName = '';\n$scope.lName = '';\n$scope.passw1 = '';\n$scope.passw2 = '';\n$scope.users = [\n{id:1, fName:'Hege',  lName:\"Pege\" },\n{id:2, fName:'Kim',   lName:\"Pim\" },\n{id:3, fName:'Sal',   lName:\"Smith\" },\n{id:4, fName:'Jack',  lName:\"Jones\" },\n{id:5, fName:'John',  lName:\"Doe\" },\n{id:6, fName:'Peter', lName:\"Pan\" }\n];\n$scope.edit = true;\n$scope.error = false;\n$scope.incomplete = false;\n\n$scope.editUser = function(id) {\n  if (id == 'new') {\n    $scope.edit = true;\n    $scope.incomplete = true;\n    $scope.fName = '';\n    $scope.lName = '';\n    } else {\n    $scope.edit = false;\n    $scope.fName = $scope.users[id-1].fName;\n    $scope.lName = $scope.users[id-1].lName;\n  }\n};\n\n$scope.$watch('passw1',function() {$scope.test();});\n$scope.$watch('passw2',function() {$scope.test();});\n$scope.$watch('fName', function() {$scope.test();});\n$scope.$watch('lName', function() {$scope.test();});\n\n$scope.test = function() {\n  if ($scope.passw1 !== $scope.passw2) {\n    $scope.error = true;\n    } else {\n    $scope.error = false;\n  }\n  $scope.incomplete = false;\n  if ($scope.edit && (!$scope.fName.length ||\n  !$scope.lName.length ||\n  !$scope.passw1.length || !$scope.passw2.length)) {\n       $scope.incomplete = true;\n  }\n};\n\n}\n```\n\n###JavaScript 代码解析\n\n```javascript\nScope 属性     用途\n$scope.fName  模型变量 (用户名)\n$scope.lName  模型变量 (用户姓)\n$scope.passw1   模型变量 (用户密码 1)\n$scope.passw2   模型变量 (用户密码 2)\n$scope.users  模型变量 (用户的数组)\n$scope.edit   当用户点击创建用户时设置为true。\n$scope.error  如果 passw1 不等于 passw2 设置为 true\n$scope.incomplete   如果每个字段都为空(length = 0)设置为 true\n$scope.editUser   设置模型变量\n$scope.watch  监控模型变量\n$scope.test   验证模型变量的错误和完整性\n\n```\n\n##AngularJS Include（包含）\n使用 AngularJS, 你可以在 HTML 中包含 HTML 文件。\n\n###服务端包含\n\n大部分web服务器支持服务端脚本的包含 (SSI：Server Side Includes)。\n\n使用 SSI, 你可以在HTML页面发送至浏览器前包含 HTML。\nPHP 实例\n```php\n<?php require(\"navigation.php\"); ?>\n```\n\n###客户端包含\n\n客户端在 HTML 中使用 JavaScript 有多种方式可以包含 HTML 文件。\n\n通常我们使用 http 请求 (AJAX) 从服务端获取数据，返回的数据我们可以通过 使用 innerHTML 写入到 HTML 元素中。 \n\n\n###AngularJS 包含\n\n使用 AngularJS, 你可以使用 ng-include 指令来包含 HTML 内容:\n实例\n```javascript\n<body>\n\n<div class=\"container\">\n  <div ng-include=\"'myUsers_List.htm'\"></div>\n  <div ng-include=\"'myUsers_Form.htm'\"></div>\n</div>\n```\n</body>\n\n##AngularJS 应用程序实例\n\n###Html文件\n\n```javascript\n <div ng-app=\"myTodoApp\" ng-controller=\"myTodoCtrl\">\n\n<h2>我的笔记</h2>\n\n<p><textarea ng-model=\"message\" cols=\"40\" rows=\"10\"></textarea></p>\n\n<p>\n<button ng-click=\"save()\">保存</button>","slug":"Angularjs","updated":1417962245000,"excerpt":"<h2 id=\"AngularJS简介\">AngularJS简介</h2>\n<p>AngularJS 是一个 JavaScript 框架。它可通过 script 标签添加到 HTML 页面。</p>\n<p>AngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML。</p>\n<p>AngularJS 是以一个 JavaScript 文件形式发布的，可通过 script 标签添加到网页中：</p>\n<!--<script src=\"//www.w3cschool.cc/try/angularjs/1.2.5/angular.min.js\"></script> -->\n\n<p><strong>我们建议把脚本放在 <body> 元素的底部。这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。</body></strong></p>\n","_id":"hm2mdjiqborgqld7","comments":true,"layout":"post","photos":[],"link":""},{"title":"java NIO详解","date":1410939540000,"categories":["ul6daxntcjqe0xkn"],"tags":["8900a8x8zwmzl3ur","yzou6ohxuwbhfjes","vvkvm2peee13ln7r"],"desctiption":"一篇自己对java NIO的理解","content":"<p><img src=\"/image/javaboy.jpg\" alt=\"javaNIO\"></p>\n<h1 id=\"前言\">前言</h1>\n<p>我们在写java程序的时候，为了进行优化，把全部的精力用在了处理效率上，但是对IO的关注却很少。这也可能是由以前java早期时JVM在解释字节码时速度慢，运行速率大大低于本地编译代码，因此以前往往忽视了IO的优化。   </p>\n<p>但是现在<a href=\"http://baike.baidu.com/view/160708.htm\" target=\"_blank\" rel=\"external\">JVM</a>在运行时优化已前进了一大步，现在的java应用程序更多的是受IO的束缚，也就是将时间花在等待数据传输上。现在有了<a href=\"http://baike.baidu.com/view/1007976.htm?from_id=13029359&amp;type=syn&amp;fromtitle=java+nio&amp;fr=aladdin\" target=\"_blank\" rel=\"external\">NIO</a>，就可以减少<a href=\"http://baike.baidu.com/subview/1142749/5362454.htm\" target=\"_blank\" rel=\"external\">IO</a>的等待时间，从而提升IO的效率。</p>\n<p><a id=\"more\"></a></p>\n<h2 id=\"java_NIO的思维导图:\">java NIO的思维导图:</h2>\n<p><img src=\"/image/javaNIO.png\" alt=\"javaNIO\"></p>\n<h3 id=\"JVM利弊\">JVM利弊</h3>\n<p>JVM 是把双刃剑。它提供了统一的操作环境,让 Java 程序员不用再为操作系统环境的区别而烦恼。与特定平台相关的细枝末节大都被隐藏了起来,因而代码写得又快又容易。但是隐藏操作系统的技术细节也意味着某些个性鲜明、功能强大的特性被挡在了门外。</p>\n<p>怎么办呢?如果您是程序员,可以使用 Java 本地接口(<a href=\"http://baike.baidu.com/view/1272329.htm\" target=\"_blank\" rel=\"external\">JNI</a>)编写本地代码,直接使用操作系统特性。这样的话，不同的操作系统的局限性就体现出来了。为了解决这一问题,java.nio 软件包提供了新的抽象。具体地说,就是 Channel 和 Selector类。它们提供了使用 I/O 服务的通用 API,JDK 1.4 以前的版本是无法使用这些服务的。天下还是没有免费的午餐:您无法使用每一种操作系统的每一种特性,但是这些新类还是提供了强大的新框架,涵盖了当今商业操作系统普遍提供的高效 I/O 特性。不仅如此,java.nio.channels.spi还提供了新的服务提供接口(SPI),允许接入新型通道和选择器,同时又不违反规范的一致性。</p>\n<p>随着 NIO 的面世,Java 已经为严肃的商业、娱乐、科研和学术应用做好了准备。在这些领域,高性能 I/O 是必不可少的。</p>\n<h1 id=\"NIO原理\">NIO原理</h1>\n<h2 id=\"NIO与IO的区别\">NIO与IO的区别</h2>\n<p>首先来讲一下传统的IO和NIO的区别，传统的IO又称BIO，即阻塞式IO，NIO就是非阻塞IO了。还有一种<a href=\"http://stevex.blog.51cto.com/4300375/1284437\" target=\"_blank\" rel=\"external\">AIO</a>就是异步IO，这里不加阐述了。</p>\n<p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>\n<h2 id=\"缓冲区Buffer\">缓冲区Buffer</h2>\n<p>一个Buffer对象是固定数量的数据的容器。其作用是一个存储器,或者分段运输区,在这里数据可被存储并在之后用于检索。尽管缓冲区作用于它们存储的原始数据类型,但缓冲区十分倾向于处理字节。非字节缓冲区可以在后台执行从字节或到字节的转换,这取决于缓冲区是如何创建的。</p>\n<p>缓冲区的工作与通道紧密联系。通道是 I/O 传输发生时通过的入口,而缓冲区是这些数据传输的来源或目标。对于离开缓冲区的传输,您想传递出去的数据被置于一个缓冲区,被传送到通道。对于传回缓冲区的传输,一个通道将数据放置在您所提供的缓冲区中。这种在协同对象(通常是您所写的对象以及一到多个 Channel 对象)之间进行的缓冲区数据传递是高效数据处理的关键。</p>\n<p>以下是一个新创建的ByteBuffer:<br><img src=\"/image/Bytebuffer.png\" alt=\"ByteBuffer\"></p>\n<p>位置被设为 0,而且容量和上界被设为 10,刚好经过缓冲区能够容纳的最后一个字节。标记最初未定义。容量是固定的,但另外的三个属性可以在使用缓冲区时改变。</p>\n<p>其中的四个属性的含义分别如下：</p>\n<ul>\n<li>容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。这一个容量在缓冲区创建时被设定，并且永远不能改变。</li>\n<li>上界(Limit)：缓冲区的第一个不能被读或写的元素。或者说,缓冲区中现存元素的计数。</li>\n<li>位置(Position)：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。</li>\n<li>标记(Mark)：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。</li>\n</ul>\n<p><strong>Buffer的常见方法</strong>如下所示:</p>\n<ul>\n<li>flip(): 写模式转换成读模式</li>\n<li>rewind()：将 position 重置为 0 ，一般用于重复读。</li>\n<li>clear() ：清空 buffer ，准备再次被写入 (position 变成 0 ， limit 变成 capacity) 。</li>\n<li>compact(): 将未读取的数据拷贝到 buffer 的头部位。</li>\n<li>mark(): reset():mark 可以标记一个位置， reset 可以重置到该位置。</li>\n<li>Buffer 常见类型： ByteBuffer 、 MappedByteBuffer 、 CharBuffer 、 DoubleBuffer 、 FloatBuffer 、 IntBuffer 、 LongBuffer 、 ShortBuffer 。 </li>\n</ul>\n<h2 id=\"通道Channel\">通道Channel</h2>\n<p>通道(Channel)是 java.nio 的第二个主要创新。它们既不是一个扩展也不是一项增强,而是全新、极好的 Java I/O 示例,提供与 I/O 服务的直接连接。Channel 用于在字节缓冲区和位于通道另一侧的实体(通常是一个文件或套接字)之间有效地传输数据。</p>\n<p>通道是一种途径,借助该途径,可以用最小的总开销来访问操作系统本身的 I/O 服务。缓冲区则是通道内部用来发送和接收数据的端点。通道channel充当连接I/O服务的导管，入下图所示<img src=\"/image/channel.png\" alt=\"channel\"></p>\n<h3 id=\"通道特性\">通道特性</h3>\n<p>通道可以是单向或者双向的。一个 channel 类可能实现定义read( )方法的 ReadableByteChannel 接口,而另一个 channel 类也许实现 WritableByteChannel 接口以提供 write( )方法。实现这两种接口其中之一的类都是单向的,只能在一个方向上传输数据。如果一个类同时实现这两个接口,那么它是双向的,可以双向传输数据。</p>\n<p>每一个 file 或 socket 通道都实现全部三个接口。从类定义的角度而言,这意味着全部 file 和 socket 通道对象都是双向的。这对于 sockets 不是问题,因为它们一直都是双向的,不过对于 files 却是个问题了。我们知道,一个文件可以在不同的时候以不同的权限打开。从 FileInputStream 对象的getChannel( )方法获取的 FileChannel 对象是只读的,不过从接口声明的角度来看却是双向的,因为FileChannel 实现 ByteChannel 接口。在这样一个通道上调用 write( )方法将抛出未经检查的NonWritableChannelException 异常,因为 FileInputStream 对象总是以 read-only 的权限打开文件。</p>\n<p>通道会连接一个特定 I/O 服务且通道实例(channel instance)的性能受它所连接的 I/O 服务的特征限制,记住这很重要。一个连接到只读文件的 Channel 实例不能进行写操作,即使该实例所属的类可能有 write( )方法。基于此,程序员需要知道通道是如何打开的,避免试图尝试一个底层 I/O服务不允许的操作。</p>\n<p>通道可以以阻塞(blocking)或非阻塞(nonblocking)模式运行。非阻塞模式的通道永远不会让调用的线程休眠。请求的操作要么立即完成,要么返回一个结果表明未进行任何操作。只有面向流的(stream-oriented)的通道,如 sockets 和 pipes 才能使用非阻塞模式。</p>\n<h2 id=\"选择器Selector\">选择器Selector</h2>\n<p>选择器提供选择执行已经就绪的任务的能力，这使得多元I/O成为可能，就绪选择和多元执行使得单线程能够有效率的同时管理多个I/O通道（channels），简单言之就是selector充当一个监视者，您需要将之前创建的一个或多个可选择的通道注册到选择器对象中。一个表示通道和选择器的键将会被返回。选择键会记住您关心的通道。它们也会追踪对应的通道是否已经就绪当您调用一个选择器对象的 select( )方法时,相关的键会被更新,用来检查所有被注册到该选择器的通道。您可以获取一个键的集合,从而找到当时已经就绪的通道。通过遍历这些键,您可以选择出每个从上次您调用 select( )开始直到现在,已经就绪的通道。</p>\n<h3 id=\"传统的socket监控\">传统的socket监控</h3>\n<p>传统的监控多个 socket 的 Java 解决方案是为每个 socket 创建一个线程并使得线程可以在 read( )调用中阻塞,直到数据可用。这事实上将每个被阻塞的线程当作了 socket 监控器,并将 Java 虚拟机的线程调度当作了通知机制。这两者本来都不是为了这种目的而设计的。程序员和 Java 虚拟机都为管理所有这些线程的复杂性和性能损耗付出了代价,这在线程数量的增长时表现得更为突出。</p>\n<h3 id=\"选择器属性\">选择器属性</h3>\n<ul>\n<li><p>选择器（Selector）<br>选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册的,并且使用选择器来更新通道的就绪状态。当这么做的时候,可以选择将被激发的线程挂起,直到有就绪的的通道。</p>\n</li>\n<li><p>可选择通道(SelectableChannel)<br>SelectableChannel 可以被注册到 Selector 对象上,同时可以指定对那个选择器而言,那种操作是感兴趣的。一个通道可以被注册到多个选择器上,但对每个选择器而言只能被注册一次。</p>\n</li>\n<li><p>选择键(SelectionKey)<br>选择键封装了特定的通道与特定的选择器的注册关系。选择键对象被SelectableChannel.register( ) 返回并提供一个表示这种注册关系的标记。选择键包含了两个比特集(以整数的形式进行编码),指示了该注册关系所关心的通道操作,以及通道已经准备好的操作。</p>\n</li>\n</ul>\n<p><strong>下图体现了就绪选择注册和Selector的关系</strong><br><img src=\"/image/Selector.png\" alt=\"Selector\"></p>\n<p>一个单独的通道对象可以被注册到多个选择器上。可以调用 isRegistered( )方法来检查一个通道是否被注册到任何一个选择器上。这个方法没有提供关于通道被注册到哪个选择器上的信息,而只能知道它至少被注册到了一个选择器上。此外,在一个键被取消之后,直到通道被注销为止,可能有时间上的延迟。这个方法只是一个提示,而不是确切的答案。</p>\n<h3 id=\"键对象\">键对象</h3>\n<p>键对象表示了一种特定的注册关系。当应该终结这种关系的时候,可以调用 SelectionKey对象的 cancel( )方法。可以通过调用 isValid( )方法来检查它是否仍然表示一种有效的关系。当键被取消时,它将被放在相关的选择器的已取消的键的集合里。注册不会立即被取消,但键会立即失效。当再次调用 select( )方法时(或者一个正在进行的 select()调用结束时),已取消的键的集合中的被取消的键将被清理掉,并且相应的注销也将完成。通道会被注销,而新的SelectionKey 将被返回。</p>\n<p>SelectionKey 类定义了四个便于使用的布尔方法来为您测试这些比特值:isReadable( ),isWritable( ),isConnectable( ), 和 isAcceptable( )。每一个方法都与使用特定掩码来测试 readyOps( )方法的结果的效果相同。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (key.isWritable( ))</div><div class=\"line\">等价于:</div><div class=\"line\"><span class=\"keyword\">if</span> ((key.readyOps( ) & SelectionKey.OP_WRITE) != <span class=\"number\">0</span>)</div></pre></td></tr></table></figure>\n\n<p>这四个方法在任意一个 SelectionKey 对象上都能安全地调用。不能在一个通道上注册一个它不支持的操作,这种操作也永远不会出现在 ready 集合中。调用一个不支持的操作将总是返回 false,因为这种操作在该通道上永远不会准备好。</p>\n<h3 id=\"停止选择过程\">停止选择过程</h3>\n<p>有三种方式可以唤醒在select（）方法中睡眠的线程。</p>\n<ol>\n<li><p>调用wakeup（）<br>调用 Selector 对象的 wakeup( )方法将使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有在进行中的选择,那么下一次对 select( )方法的一种形式的调用将立即返回。后续的选择操作将正常进行。在选择操作之间多次调用 wakeup( )方法与调用它一次没有什么不同。有时这种延迟的唤醒行为并不是您想要的。您可能只想唤醒一个睡眠中的线程,而使得后续的选择继续正常地进行。您可以通过在调用 wakeup( )方法后调用 selectNow( )方法来绕过这个问题。尽管如此,如果您将您的代码构造为合理地关注于返回值和执行选择集合,那么即使下一个 select( )方法的调用在没有通道就绪时就立即返回,也应该不会有什么不同。不管怎么说,您应该为可能发生的事件做好准备。</p>\n</li>\n<li><p>调用 close( )<br>如果选择器的 close( )方法被调用,那么任何一个在选择操作中阻塞的线程都将被唤醒,就像wakeup( )方法被调用了一样。与选择器相关的通道将被注销,而键将被取消。</p>\n</li>\n<li><p>调用 interrupt( )<br>如果睡眠中的线程的 interrupt( )方法被调用,它的返回状态将被设置。如果被唤醒的线程之后将试图在通道上执行 I/O 操作,通道将立即关闭,然后线程将捕捉到一个异常。这是由于在第三章中已经探讨过的通道的中断语义。使用 wakeup( )方法将会优雅地将一个在 select( )方法中睡眠的线程唤醒。如果您想让一个睡眠的线程在直接中断之后继续执行,需要执行一些步骤来清理中断状态</p>\n</li>\n</ol>\n<h2 id=\"简单的NIO服务器\">简单的NIO服务器</h2>\n<p>下面是一个简单的NIO服务器的例子，使用select（）来为多个通道提供服务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</div><div class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SelectableChannel;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SelectionKey;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.Selector;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.ServerSocketChannel;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SocketChannel;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> javax.swing.text.html.HTMLDocument.Iterator;</div><div class=\"line\"></div><div class=\"line\"><span class=\"javadoc\">/**</span></div><div class=\"line\">* Simple echo-back server which listens for incoming stream connections and</div><div class=\"line\">* echoes back whatever it reads. A single Selector object is used to listen to</div><div class=\"line\">* the server socket (to accept new connections) and all the active socket</div><div class=\"line\">* channels.</div><div class=\"line\">*<span class=\"javadoctag\"> @author</span> zale (zalezone.cn)</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SelectSockets</span> </span>{</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> PORT_NUMBER = <span class=\"number\">1234</span>;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(String[] argv) <span class=\"keyword\">throws</span> Exception </div><div class=\"line\">\t{</div><div class=\"line\">\t\t<span class=\"keyword\">new</span> SelectSockets().go(argv);</div><div class=\"line\">\t}</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">go</span>(String[] argv) <span class=\"keyword\">throws</span> Exception </div><div class=\"line\">\t{</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> port = PORT_NUMBER;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (argv.length &gt; <span class=\"number\">0</span>) </div><div class=\"line\">\t\t{ <span class=\"comment\">// 覆盖默认的监听端口</span></div><div class=\"line\">\t\t\tport = Integer.parseInt(argv[<span class=\"number\">0</span>]);</div><div class=\"line\">\t\t}</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"Listening on port \"</span> + port);</div><div class=\"line\">\t\tServerSocketChannel serverChannel = ServerSocketChannel.open();<span class=\"comment\">// 打开一个未绑定的serversocketchannel</span></div><div class=\"line\">\t\tServerSocket serverSocket = serverChannel.socket();<span class=\"comment\">// 得到一个ServerSocket去和它绑定\t</span></div><div class=\"line\">\t\tSelector selector = Selector.open();<span class=\"comment\">// 创建一个Selector供下面使用</span></div><div class=\"line\">\t\tserverSocket.bind(<span class=\"keyword\">new</span> InetSocketAddress(port));<span class=\"comment\">//设置server channel将会监听的端口</span></div><div class=\"line\">\t\tserverChannel.configureBlocking(<span class=\"keyword\">false</span>);<span class=\"comment\">//设置非阻塞模式</span></div><div class=\"line\">\t\tserverChannel.register(selector, SelectionKey.OP_ACCEPT);<span class=\"comment\">//将ServerSocketChannel注册到Selector</span></div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\t<span class=\"comment\">// This may block for a long time. Upon returning, the</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// selected set contains keys of the ready channels.</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> n = selector.select();</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) </div><div class=\"line\">\t\t\t{</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>; <span class=\"comment\">// nothing to do</span></div><div class=\"line\">\t\t\t}\t\t\t</div><div class=\"line\">\t\t\tjava.util.Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<span class=\"comment\">// Get an iterator over the set of selected keys</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//在被选择的set中遍历全部的key</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> (it.hasNext()) </div><div class=\"line\">\t\t\t{</div><div class=\"line\">\t\t\t\tSelectionKey key = (SelectionKey) it.next();</div><div class=\"line\">\t\t\t\t<span class=\"comment\">// 判断是否是一个连接到来</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (key.isAcceptable()) </div><div class=\"line\">\t\t\t\t{</div><div class=\"line\">\t\t\t\t\tServerSocketChannel server =(ServerSocketChannel) key.channel();</div><div class=\"line\">\t\t\t\t\tSocketChannel channel = server.accept();</div><div class=\"line\">\t\t\t\t\tregisterChannel(selector, channel,SelectionKey.OP_READ);<span class=\"comment\">//注册读事件</span></div><div class=\"line\">\t\t\t\t\tsayHello(channel);<span class=\"comment\">//对连接进行处理</span></div><div class=\"line\">\t\t\t\t}</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//判断这个channel上是否有数据要读</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (key.isReadable()) </div><div class=\"line\">\t\t\t\t{</div><div class=\"line\">\t\t\t\t\treadDataFromSocket(key);</div><div class=\"line\">\t\t\t\t}</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//从selected set中移除这个key，因为它已经被处理过了</span></div><div class=\"line\">\t\t\t\tit.remove();</div><div class=\"line\">\t\t\t}</div><div class=\"line\">\t\t}</div><div class=\"line\">\t}</div><div class=\"line\">\t<span class=\"comment\">// ----------------------------------------------------------</span></div><div class=\"line\">\t<span class=\"javadoc\">/**</span></div><div class=\"line\">\t* Register the given channel with the given selector for the given</div><div class=\"line\">\t* operations of interest</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">registerChannel</span>(Selector selector,SelectableChannel channel, <span class=\"keyword\">int</span> ops) <span class=\"keyword\">throws</span> Exception</div><div class=\"line\">\t{</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (channel == <span class=\"keyword\">null</span>) </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span>; <span class=\"comment\">// 可能会发生</span></div><div class=\"line\">\t\t}</div><div class=\"line\">\t\t<span class=\"comment\">// 设置通道为非阻塞</span></div><div class=\"line\">\t\tchannel.configureBlocking(<span class=\"keyword\">false</span>);</div><div class=\"line\">\t\t<span class=\"comment\">// 将通道注册到选择器上</span></div><div class=\"line\">\t\tchannel.register(selector, ops);</div><div class=\"line\">\t}</div><div class=\"line\">\t<span class=\"comment\">// ----------------------------------------------------------</span></div><div class=\"line\">\t<span class=\"comment\">// Use the same byte buffer for all channels. A single thread is</span></div><div class=\"line\">\t<span class=\"comment\">// servicing all the channels, so no danger of concurrent acccess.</span></div><div class=\"line\">\t<span class=\"comment\">//对所有的通道使用相同的缓冲区。单线程为所有的通道进行服务，所以并发访问没有风险</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> ByteBuffer buffer = ByteBuffer.allocateDirect(<span class=\"number\">1024</span>);</div><div class=\"line\">\t<span class=\"javadoc\">/**</span></div><div class=\"line\">\t* Sample data handler method for a channel with data ready to read.</div><div class=\"line\">\t* 对于一个准备读入数据的通道的简单的数据处理方法</div><div class=\"line\">\t*<span class=\"javadoctag\"> @param</span> key</div><div class=\"line\">\t*</div><div class=\"line\">\tA SelectionKey object associated with a channel determined by</div><div class=\"line\">\tthe selector to be ready for reading. If the channel returns</div><div class=\"line\">\tan EOF condition, it is closed here, which automatically</div><div class=\"line\">\tinvalidates the associated key. The selector will then</div><div class=\"line\">\tde-register the channel on the next select call.</div><div class=\"line\">\t</div><div class=\"line\">\t一个选择器决定了和通道关联的SelectionKey object是准备读状态。如果通道返回EOF，通道将被关闭。</div><div class=\"line\">\t并且会自动使相关的key失效，选择器然后会在下一次的select call时取消掉通道的注册</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">readDataFromSocket</span>(SelectionKey key) <span class=\"keyword\">throws</span> Exception </div><div class=\"line\">\t{</div><div class=\"line\">\t\tSocketChannel socketChannel = (SocketChannel) key.channel();</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> count;</div><div class=\"line\">\t\tbuffer.clear(); <span class=\"comment\">// 清空Buffer</span></div><div class=\"line\">\t\t<span class=\"comment\">// Loop while data is available; channel is nonblocking</span></div><div class=\"line\">\t\t<span class=\"comment\">//当可以读到数据时一直循环，通道为非阻塞</span></div><div class=\"line\">\t\t<span class=\"keyword\">while</span> ((count = socketChannel.read(buffer)) &gt; <span class=\"number\">0</span>) </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\tbuffer.flip(); <span class=\"comment\">// 将缓冲区置为可读</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// Send the data; don't assume it goes all at once</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//发送数据，不要期望能一次将数据发送完</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> (buffer.hasRemaining()) </div><div class=\"line\">\t\t\t{</div><div class=\"line\">\t\t\t\tsocketChannel.write(buffer);</div><div class=\"line\">\t\t\t}</div><div class=\"line\">\t\t\t<span class=\"comment\">// WARNING: the above loop is evil. Because</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// it's writing back to the same nonblocking</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// channel it read the data from, this code can</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// potentially spin in a busy loop. In real life</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// you'd do something more useful than this.</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//这里的循环是无意义的，具体按实际情况而定</span></div><div class=\"line\">\t\t\tbuffer.clear(); <span class=\"comment\">// Empty buffer</span></div><div class=\"line\">\t\t}</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\t<span class=\"comment\">// Close channel on EOF, invalidates the key</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//读取结束后关闭通道，使key失效</span></div><div class=\"line\">\t\t\tsocketChannel.close();</div><div class=\"line\">\t\t}</div><div class=\"line\">\t}</div><div class=\"line\">\t<span class=\"comment\">// ----------------------------------------------------------</span></div><div class=\"line\">\t<span class=\"javadoc\">/**</span></div><div class=\"line\">\t* Spew a greeting to the incoming client connection.</div><div class=\"line\">\t*</div><div class=\"line\">\t*<span class=\"javadoctag\"> @param</span> channel</div><div class=\"line\">\t*</div><div class=\"line\">\tThe newly connected SocketChannel to say hello to.</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span>(SocketChannel channel) <span class=\"keyword\">throws</span> Exception </div><div class=\"line\">\t{</div><div class=\"line\">\t\tbuffer.clear();</div><div class=\"line\">\t\tbuffer.put(<span class=\"string\">\"Hi there!\\r\\n\"</span>.getBytes());</div><div class=\"line\">\t\tbuffer.flip();</div><div class=\"line\">\t\tchannel.write(buffer);</div><div class=\"line\">\t}</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"原理解释\">原理解释</h3>\n<p>上面这个例子实现了一个简单的服务器，它创建了 ServerSocketChannel 和 Selector 对象,并将通道注册到选择器上。我们不在注册的键中保存服务器 socket 的引用,因为它永远不会被注销。这个无限循环在最上面先调用了 select( ),这可能会无限期地阻塞。当选择结束时,就遍历选择键并检查已经就绪的通道。</p>\n<p>如果一个键指示与它相关的通道已经准备好执行一个 accecpt( )操作,我们就通过键获取关联的通道,并将它转换为 SeverSocketChannel 对象。我们都知道这么做是安全的,因为只有ServerSocketChannel 支持 OP_ACCEPT 操作。我们也知道我们的代码只把对一个单一的ServerSocketChannel 对象的 OP_ACCEPT 操作进行了注册。通过对服务器 socket 通道的引用,我 们调用了它 的 accept( )方法 ,来获取刚到达 的 socket 的句 柄。返回的 对象的类型 是<br>SocketChannel,也是一个可选择的通道类型。这时,与创建一个新线程来从新的连接中读取数据不同,我们只是简单地将 socket 同多注册到选择器上。我们通过传入 OP_READ 标记,告诉选择器我们关心新的 socket 通道什么时候可以准备好读取数据。</p>\n<p>如果键指示通道还没有准备好执行 accept( ),我们就检查它是否准备好执行 read( )。任何一个这么指示的 socket 通道一定是之前 ServerSocketChannel 创建的 SocketChannel 对象之一,并且被注册为只对读操作感兴趣。对于每个有数据需要读取的 socket 通道,我们调用一个公共的方法来读取并处理这个带有数据的 socket。需要注意的是这个公共方法需要准备好以非阻塞的方式处理 socket 上的不完整的数据。它需要迅速地返回,以其他带有后续输入的通道能够及时地得到处理。例 4-1 中只是简单地对数据进行响应,将数据写回 socket,传回给发送者。</p>\n<p>在循环的底部,我们通过调用 Iterator(迭代器)对象的 remove()方法,将键从已选择的键的集合中移除。键可以直接从 selectKeys()返回的 Set 中移除,但同时需要用 Iterator 来检查集合,您需要使用迭代器的 remove()方法来避免破坏迭代器内部的状态。</p>\n<h2 id=\"并发性\">并发性</h2>\n<p>选择器对象是线程安全的,但它们包含的键集合不是。通过 keys( )和 selectKeys( )返回的键的集合是 Selector 对象内部的私有的 Set 对象集合的直接引用。这些集合可能在任意时间被改变。已注册的键的集合是只读的。如果您试图修改它,那么您得到的奖品将是一个java.lang.UnsupportedOperationException,但是当您在观察它们的时候,它们可能发生了改变的话,您仍然会遇到麻烦。Iterator 对象是快速失败的(fail-fast):如果底层的 Set 被改变了,它们将会抛出 java.util.ConcurrentModificationException,因此如果您期望在多个线程间共享选择器和/或键,请对此做好准备。您可以直接修改选择键,但请注意您这么做时可能会彻底破坏另一个线程的 Iterator。</p>\n<p>如果在多个线程并发地访问一个选择器的键的集合的时候存在任何问题,您可以采取一些步骤来合理地同步访问。在执行选择操作时,选择器在 Selector 对象上进行同步,然后是已注册的键的集合,最后是已选择的键的集合,按照这样的顺序。已取消的键的集合也在选择过程的的第 1步和第 3 步之间保持同步(当与已取消的键的集合相关的通道被注销时)。</p>\n<p>在多线程的场景中,如果您需要对任何一个键的集合进行更改,不管是直接更改还是其他操作带来的副作用,您都需要首先以相同的顺序,在同一对象上进行同步。锁的过程是非常重要的。如果竞争的线程没有以相同的顺序请求锁,就将会有死锁的潜在隐患。如果您可以确保否其他线程不会同时访问选择器,那么就不必要进行同步了。</p>\n<p>Selector 类的 close( )方法与 slect( )方法的同步方式是一样的,因此也有一直阻塞的可能性。在选择过程还在进行的过程中,所有对 close( )的调用都会被阻塞,直到选择过程结束,或者执行选择的线程进入睡眠。在后面的情况下,执行选择的线程将会在执行关闭的线程获得锁时立即被唤醒,并关闭选择器。</p>\n<h2 id=\"选择过程的可扩展性\">选择过程的可扩展性</h2>\n<p>对于单CPU的系统用一个线程来为多个通道提供服务可能是个好主意，但是对于多个CPU的系统来说就可能不能使其他CPU高效发挥作用。  </p>\n<p>一个比较好的优化策略是对所有的可选择通道使用一个选择器,并将对就绪通道的服务委托给其他线程。根据部署的条件,线程池的大小是可以调整的(或者它自己进行动态的调整)。  </p>\n<p>另外，有些通道要求比其他通道有更高的响应速度，可以通过使用两个选择器来解决：一个为命令连接服务，另一个为普通连接服务。与将所有准备好的通道放到同一个线程池的做法不同,通道可以根据功能由不同的工作线程来处理。它们可能可以是日志线程池,命令/控制线程池,状态请求线程池,等等。</p>\n<h2 id=\"服务线程池服务器示例\">服务线程池服务器示例</h2>\n<p>这个例子是上一个简单服务器的一般性的选择循环的扩展。它覆写了 readDataFromSocket( )方法,并使用线程池来为准备好数据用于读取的通道提供服务。与在主线程中同步地读取数据不同,这个版本的实现将 SelectionKey 对象传递给为其服务的工作线程。</p>\n<h3 id=\"使用线程池来为通道提供服务\">使用线程池来为通道提供服务</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SelectionKey;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SocketChannel;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"javadoc\">/**</span></div><div class=\"line\">* Specialization of the SelectSockets class which uses a thread pool to service</div><div class=\"line\">* channels. The thread pool is an ad-hoc implementation quicky lashed togther</div><div class=\"line\">* in a few hours for demonstration purposes. It's definitely not production</div><div class=\"line\">* quality.</div><div class=\"line\">*</div><div class=\"line\">*<span class=\"javadoctag\"> @author</span> Ron Hitchens (ron@ronsoft.com)</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SelectSocketsThreadPool</span> <span class=\"keyword\">extends</span> <span class=\"title\">SelectSockets</span> </span></div><div class=\"line\">{</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_THREADS = <span class=\"number\">5</span>;</div><div class=\"line\">\t<span class=\"keyword\">private</span> ThreadPool pool = <span class=\"keyword\">new</span> ThreadPool(MAX_THREADS);</div><div class=\"line\">\t<span class=\"comment\">// -------------------------------------------------------------</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(String[] argv) <span class=\"keyword\">throws</span> Exception </div><div class=\"line\">\t{</div><div class=\"line\">\t\t<span class=\"keyword\">new</span> SelectSocketsThreadPool().go(argv);</div><div class=\"line\">\t}</div><div class=\"line\">\t<span class=\"comment\">// -------------------------------------------------------------</span></div><div class=\"line\">\t<span class=\"javadoc\">/**</span></div><div class=\"line\">\t* Sample data handler method for a channel with data ready to read. This</div><div class=\"line\">\t* method is invoked from(被调用) the go( ) method in the parent class. This handler</div><div class=\"line\">\t* delegates（委托） to a worker thread in a thread pool to service the channel,</div><div class=\"line\">\t* then returns immediately.</div><div class=\"line\">\t*</div><div class=\"line\">\t*<span class=\"javadoctag\"> @param</span> key</div><div class=\"line\">\t*</div><div class=\"line\">\tA SelectionKey object representing a channel determined by the</div><div class=\"line\">\t*</div><div class=\"line\">\tselector to be ready for reading. If the channel returns an</div><div class=\"line\">\t*</div><div class=\"line\">\tEOF condition, it is closed here, which automatically</div><div class=\"line\">\t*</div><div class=\"line\">\tinvalidates the associated key. The selector will then</div><div class=\"line\">\t*</div><div class=\"line\">\tde-register the channel on the next select call.</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">readDataFromSocket</span>(SelectionKey key) <span class=\"keyword\">throws</span> Exception </div><div class=\"line\">\t{</div><div class=\"line\">\t\tWorkerThread worker = pool.getWorker();</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (worker == <span class=\"keyword\">null</span>) </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\t<span class=\"comment\">// No threads available. Do nothing. The selection</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// loop will keep calling this method until a</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// thread becomes available. This design could</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// be improved.</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t}</div><div class=\"line\">\t\t<span class=\"comment\">// Invoking this wakes up the worker thread, then returns</span></div><div class=\"line\">\t\tworker.serviceChannel(key);</div><div class=\"line\">\t}</div><div class=\"line\">\t<span class=\"comment\">// ---------------------------------------------------------------</span></div><div class=\"line\">\t<span class=\"javadoc\">/**</span></div><div class=\"line\">\t* A very simple thread pool class. The pool size is set at construction</div><div class=\"line\">\t* time and remains fixed. Threads are cycled through a FIFO idle queue.</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPool</span></span></div><div class=\"line\">\t{</div><div class=\"line\">\t\tList idle = <span class=\"keyword\">new</span> LinkedList();</div><div class=\"line\">\t\tThreadPool(<span class=\"keyword\">int</span> poolSize) </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\t<span class=\"comment\">// Fill up the pool with worker threads</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; poolSize; i++)</div><div class=\"line\">\t\t\t{</div><div class=\"line\">\t\t\t\tWorkerThread thread = <span class=\"keyword\">new</span> WorkerThread(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t\t\t\t<span class=\"comment\">// Set thread name for debugging. Start it.</span></div><div class=\"line\">\t\t\t\tthread.setName(<span class=\"string\">\"Worker\"</span> + (i + <span class=\"number\">1</span>));</div><div class=\"line\">\t\t\t\tthread.start();</div><div class=\"line\">\t\t\t\tidle.add(thread);</div><div class=\"line\">\t\t\t}</div><div class=\"line\">\t\t}</div><div class=\"line\">\t\t<span class=\"javadoc\">/**</span></div><div class=\"line\">\t\t* Find an idle worker thread, if any. Could return null.</div><div class=\"line\">\t\t*/</div><div class=\"line\">\t\tWorkerThread getWorker() </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\tWorkerThread worker = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (idle) </div><div class=\"line\">\t\t\t{</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (idle.size() &gt; <span class=\"number\">0</span>) </div><div class=\"line\">\t\t\t\t{</div><div class=\"line\">\t\t\t\t\tworker = (WorkerThread) idle.remove(<span class=\"number\">0</span>);</div><div class=\"line\">\t\t\t\t}</div><div class=\"line\">\t\t\t}</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> (worker);</div><div class=\"line\">\t\t}</div><div class=\"line\">\t\t<span class=\"javadoc\">/**</span></div><div class=\"line\">\t\t* Called by the worker thread to return itself to the idle pool.</div><div class=\"line\">\t\t*/</div><div class=\"line\">\t\t<span class=\"keyword\">void</span> returnWorker(WorkerThread worker) </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (idle) </div><div class=\"line\">\t\t\t{</div><div class=\"line\">\t\t\t\tidle.add(worker);</div><div class=\"line\">\t\t\t}</div><div class=\"line\">\t\t}</div><div class=\"line\">\t}</div><div class=\"line\">\t<span class=\"javadoc\">/**</span></div><div class=\"line\">\t* A worker thread class which can drain（排空） channels and echo-back（回显） the input.</div><div class=\"line\">\t* Each instance is constructed with a reference（参考） to the owning thread pool</div><div class=\"line\">\t* object. When started, the thread loops forever waiting to be awakened to</div><div class=\"line\">\t* service the channel associated with a SelectionKey object. The worker is</div><div class=\"line\">\t* tasked by calling its serviceChannel( ) method with a SelectionKey</div><div class=\"line\">\t* object. The serviceChannel( ) method stores the key reference in the</div><div class=\"line\">\t* thread object then calls notify( ) to wake it up. When the channel has</div><div class=\"line\">\t* been drained, the worker thread returns itself to its parent pool.</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span></div><div class=\"line\">\t{</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> ThreadPool pool;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> SelectionKey key;</div><div class=\"line\">\t\tWorkerThread(ThreadPool pool) </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.pool = pool;</div><div class=\"line\">\t\t}</div><div class=\"line\">\t\t<span class=\"comment\">// Loop forever waiting for work to do</span></div><div class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>() </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"keyword\">this</span>.getName() + <span class=\"string\">\" is ready\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) </div><div class=\"line\">\t\t\t{</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> </div><div class=\"line\">\t\t\t\t{</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// Sleep and release object lock</span></div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">//休眠并且释放掉对象锁</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">this</span>.wait();</div><div class=\"line\">\t\t\t\t} </div><div class=\"line\">\t\t\t\t<span class=\"keyword\">catch</span> (InterruptedException e) </div><div class=\"line\">\t\t\t\t{</div><div class=\"line\">\t\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// Clear interrupt status</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">this</span>.interrupted();</div><div class=\"line\">\t\t\t\t}</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) </div><div class=\"line\">\t\t\t\t{</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>; <span class=\"comment\">// just in case</span></div><div class=\"line\">\t\t\t\t}</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"keyword\">this</span>.getName() + <span class=\"string\">\" has been awakened\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> </div><div class=\"line\">\t\t\t\t{</div><div class=\"line\">\t\t\t\t\tdrainChannel(key);</div><div class=\"line\">\t\t\t\t} </div><div class=\"line\">\t\t\t\t<span class=\"keyword\">catch</span> (Exception e) </div><div class=\"line\">\t\t\t\t{</div><div class=\"line\">\t\t\t\t\tSystem.out.println(<span class=\"string\">\"Caught '\"</span> + e + <span class=\"string\">\"' closing channel\"</span>);</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// Close channel and nudge selector</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">try</span> </div><div class=\"line\">\t\t\t\t\t{</div><div class=\"line\">\t\t\t\t\t\tkey.channel().close();</div><div class=\"line\">\t\t\t\t\t} </div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">catch</span> (IOException ex) </div><div class=\"line\">\t\t\t\t\t{</div><div class=\"line\">\t\t\t\t\t\tex.printStackTrace();</div><div class=\"line\">\t\t\t\t\t}</div><div class=\"line\">\t\t\t\t\tkey.selector().wakeup();</div><div class=\"line\">\t\t\t\t}</div><div class=\"line\">\t\t\t\tkey = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">// Done. Ready for more. Return to pool</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.pool.returnWorker(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t\t\t}</div><div class=\"line\">\t\t}</div><div class=\"line\">\t\t<span class=\"javadoc\">/**</span></div><div class=\"line\">\t\t* Called to initiate a unit of work by this worker thread on the</div><div class=\"line\">\t\t* provided SelectionKey object. This method is synchronized, as is the</div><div class=\"line\">\t\t* run( ) method, so only one key can be serviced at a given time.</div><div class=\"line\">\t\t* Before waking the worker thread, and before returning to the main</div><div class=\"line\">\t\t* selection loop, this key's interest set is updated to remove OP_READ.</div><div class=\"line\">\t\t* This will cause the selector to ignore read-readiness for this</div><div class=\"line\">\t\t* channel while the worker thread is servicing it.</div><div class=\"line\">\t\t* 通过一个被提供SelectionKey对象的工作线程来初始化一个工作集合，这个方法是同步的，所以</div><div class=\"line\">\t\t* 里面的run方法只有一个key能被服务在同一个时间，在唤醒工作线程和返回到主循环之前，这个key的</div><div class=\"line\">\t\t* 感兴趣的集合被更新来删除OP_READ，这将会引起工作线程在提供服务的时候选择器会忽略读就绪的通道</div><div class=\"line\">\t\t*/</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> serviceChannel(SelectionKey key) </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">\t\t\tkey.interestOps(key.interestOps() & (~SelectionKey.OP_READ));</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.notify(); <span class=\"comment\">// Awaken the thread</span></div><div class=\"line\">\t\t}</div><div class=\"line\">\t\t<span class=\"javadoc\">/**</span></div><div class=\"line\">\t\t* The actual code which drains the channel associated with the given</div><div class=\"line\">\t\t* key. This method assumes the key has been modified prior to</div><div class=\"line\">\t\t* invocation to turn off selection interest in OP_READ. When this</div><div class=\"line\">\t\t* method completes it re-enables OP_READ and calls wakeup( ) on the</div><div class=\"line\">\t\t* selector so the selector will resume watching this channel.</div><div class=\"line\">\t\t*/</div><div class=\"line\">\t\t<span class=\"keyword\">void</span> drainChannel(SelectionKey key) <span class=\"keyword\">throws</span> Exception </div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\tSocketChannel channel = (SocketChannel) key.channel();</div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> count;</div><div class=\"line\">\t\t\tbuffer.clear(); <span class=\"comment\">// 清空buffer</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// Loop while data is available; channel is nonblocking</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> ((count = channel.read(buffer)) &gt; <span class=\"number\">0</span>)</div><div class=\"line\">\t\t\t{</div><div class=\"line\">\t\t\t\tbuffer.flip(); <span class=\"comment\">// make buffer readable</span></div><div class=\"line\">\t\t\t\t<span class=\"comment\">// Send the data; may not go all at once</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (buffer.hasRemaining()) </div><div class=\"line\">\t\t\t\t{</div><div class=\"line\">\t\t\t\t\tchannel.write(buffer);</div><div class=\"line\">\t\t\t\t}</div><div class=\"line\">\t\t\t\t<span class=\"comment\">// WARNING: the above loop is evil.</span></div><div class=\"line\">\t\t\t\t<span class=\"comment\">// See comments in superclass.</span></div><div class=\"line\">\t\t\t\tbuffer.clear(); <span class=\"comment\">// Empty buffer</span></div><div class=\"line\">\t\t\t}</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) </div><div class=\"line\">\t\t\t{</div><div class=\"line\">\t\t\t\t<span class=\"comment\">// Close channel on EOF; invalidates the key</span></div><div class=\"line\">\t\t\t\tchannel.close();</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t}</div><div class=\"line\">\t\t\t<span class=\"comment\">// Resume interest in OP_READ</span></div><div class=\"line\">\t\t\tkey.interestOps(key.interestOps() | SelectionKey.OP_READ);</div><div class=\"line\">\t\t\t<span class=\"comment\">// Cycle the selector so this key is active again</span></div><div class=\"line\">\t\t\tkey.selector().wakeup();</div><div class=\"line\">\t\t}</div><div class=\"line\">\t}</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"原理解释-1\">原理解释</h3>\n<p>由于执行选择过程的线程将重新循环并几乎立即再次调用 select( ),键的 interest 集合将被修改,并将 interest(感兴趣的操作)从读取就绪(read-rreadiness)状态中移除。这将防止选择器重复地调用 readDataFromSocket( )(因为通道仍然会准备好读取数据,直到工作线程从它那里读取数据)。当工作线程结束为通道提供的服务时,它将再次更新键的 ready 集合,来将 interest 重新放到读取就绪集合中。它也会在选择器上显式地调用 wakeup( )。如果主线程在 select( )中被阻塞,这将使它继续执行。这个选择循环会再次执行一个轮回(可能什么也没做)并带着被更新的键重新进入select( )。</p>\n<h1 id=\"总结\">总结</h1>\n<p>对于java NIO的常见框架有Mina，Netty等，关于Mina和Netty到底哪个框架比较好，因为还未深入进行研究，<br>所以也不敢下定论，但个人还是倾向Netty框架吧。下一步准备好好研究一下Netty框架。</p>\n<p><strong>参考文献</strong>：<a href=\"http://book.douban.com/subject/1433583/\" target=\"_blank\" rel=\"external\">《java NIO》</a></p>\n","source":"_posts/NIO精粹.md","raw":"title: java NIO详解\ndate: 2014-09-17 15:39:00\ncategories: java\ntags: [NIO,java,非阻塞]\ndesctiption: 一篇自己对java NIO的理解\n\n---\n\n![javaNIO]({{BASE_PATH}}/image/javaboy.jpg)\n\n#前言\n\n我们在写java程序的时候，为了进行优化，把全部的精力用在了处理效率上，但是对IO的关注却很少。这也可能是由以前java早期时JVM在解释字节码时速度慢，运行速率大大低于本地编译代码，因此以前往往忽视了IO的优化。   \n\n但是现在[JVM](http://baike.baidu.com/view/160708.htm)在运行时优化已前进了一大步，现在的java应用程序更多的是受IO的束缚，也就是将时间花在等待数据传输上。现在有了[NIO](http://baike.baidu.com/view/1007976.htm?from_id=13029359&type=syn&fromtitle=java+nio&fr=aladdin)，就可以减少[IO](http://baike.baidu.com/subview/1142749/5362454.htm)的等待时间，从而提升IO的效率。\n\n<!--more-->\n##java NIO的思维导图: \n\n![javaNIO]({{BASE_PATH}}/image/javaNIO.png)\n\n\n###JVM利弊\nJVM 是把双刃剑。它提供了统一的操作环境,让 Java 程序员不用再为操作系统环境的区别而烦恼。与特定平台相关的细枝末节大都被隐藏了起来,因而代码写得又快又容易。但是隐藏操作系统的技术细节也意味着某些个性鲜明、功能强大的特性被挡在了门外。\n\n怎么办呢?如果您是程序员,可以使用 Java 本地接口([JNI](http://baike.baidu.com/view/1272329.htm))编写本地代码,直接使用操作系统特性。这样的话，不同的操作系统的局限性就体现出来了。为了解决这一问题,java.nio 软件包提供了新的抽象。具体地说,就是 Channel 和 Selector类。它们提供了使用 I/O 服务的通用 API,JDK 1.4 以前的版本是无法使用这些服务的。天下还是没有免费的午餐:您无法使用每一种操作系统的每一种特性,但是这些新类还是提供了强大的新框架,涵盖了当今商业操作系统普遍提供的高效 I/O 特性。不仅如此,java.nio.channels.spi还提供了新的服务提供接口(SPI),允许接入新型通道和选择器,同时又不违反规范的一致性。\n\n随着 NIO 的面世,Java 已经为严肃的商业、娱乐、科研和学术应用做好了准备。在这些领域,高性能 I/O 是必不可少的。\n\n#NIO原理\n\n##NIO与IO的区别\n首先来讲一下传统的IO和NIO的区别，传统的IO又称BIO，即阻塞式IO，NIO就是非阻塞IO了。还有一种[AIO](http://stevex.blog.51cto.com/4300375/1284437)就是异步IO，这里不加阐述了。\n\nJava IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。\n\n##缓冲区Buffer\n一个Buffer对象是固定数量的数据的容器。其作用是一个存储器,或者分段运输区,在这里数据可被存储并在之后用于检索。尽管缓冲区作用于它们存储的原始数据类型,但缓冲区十分倾向于处理字节。非字节缓冲区可以在后台执行从字节或到字节的转换,这取决于缓冲区是如何创建的。\n\n缓冲区的工作与通道紧密联系。通道是 I/O 传输发生时通过的入口,而缓冲区是这些数据传输的来源或目标。对于离开缓冲区的传输,您想传递出去的数据被置于一个缓冲区,被传送到通道。对于传回缓冲区的传输,一个通道将数据放置在您所提供的缓冲区中。这种在协同对象(通常是您所写的对象以及一到多个 Channel 对象)之间进行的缓冲区数据传递是高效数据处理的关键。\n\n以下是一个新创建的ByteBuffer:\n![ByteBuffer]({{BASE_PATH}}/image/Bytebuffer.png)\n\n位置被设为 0,而且容量和上界被设为 10,刚好经过缓冲区能够容纳的最后一个字节。标记最初未定义。容量是固定的,但另外的三个属性可以在使用缓冲区时改变。\n\n\n其中的四个属性的含义分别如下：\n\n* 容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。这一个容量在缓冲区创建时被设定，并且永远不能改变。\n* 上界(Limit)：缓冲区的第一个不能被读或写的元素。或者说,缓冲区中现存元素的计数。\n* 位置(Position)：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。\n* 标记(Mark)：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。\n\n\n**Buffer的常见方法**如下所示:\n\n* flip(): 写模式转换成读模式\n* rewind()：将 position 重置为 0 ，一般用于重复读。\n* clear() ：清空 buffer ，准备再次被写入 (position 变成 0 ， limit 变成 capacity) 。\n* compact(): 将未读取的数据拷贝到 buffer 的头部位。\n* mark(): reset():mark 可以标记一个位置， reset 可以重置到该位置。\n* Buffer 常见类型： ByteBuffer 、 MappedByteBuffer 、 CharBuffer 、 DoubleBuffer 、 FloatBuffer 、 IntBuffer 、 LongBuffer 、 ShortBuffer 。 \n\n##通道Channel\n通道(Channel)是 java.nio 的第二个主要创新。它们既不是一个扩展也不是一项增强,而是全新、极好的 Java I/O 示例,提供与 I/O 服务的直接连接。Channel 用于在字节缓冲区和位于通道另一侧的实体(通常是一个文件或套接字)之间有效地传输数据。\n\n通道是一种途径,借助该途径,可以用最小的总开销来访问操作系统本身的 I/O 服务。缓冲区则是通道内部用来发送和接收数据的端点。通道channel充当连接I/O服务的导管，入下图所示![channel]({{BASE_PATH}}/image/channel.png)\n\n###通道特性\n通道可以是单向或者双向的。一个 channel 类可能实现定义read( )方法的 ReadableByteChannel 接口,而另一个 channel 类也许实现 WritableByteChannel 接口以提供 write( )方法。实现这两种接口其中之一的类都是单向的,只能在一个方向上传输数据。如果一个类同时实现这两个接口,那么它是双向的,可以双向传输数据。\n\n每一个 file 或 socket 通道都实现全部三个接口。从类定义的角度而言,这意味着全部 file 和 socket 通道对象都是双向的。这对于 sockets 不是问题,因为它们一直都是双向的,不过对于 files 却是个问题了。我们知道,一个文件可以在不同的时候以不同的权限打开。从 FileInputStream 对象的getChannel( )方法获取的 FileChannel 对象是只读的,不过从接口声明的角度来看却是双向的,因为FileChannel 实现 ByteChannel 接口。在这样一个通道上调用 write( )方法将抛出未经检查的NonWritableChannelException 异常,因为 FileInputStream 对象总是以 read-only 的权限打开文件。\n\n通道会连接一个特定 I/O 服务且通道实例(channel instance)的性能受它所连接的 I/O 服务的特征限制,记住这很重要。一个连接到只读文件的 Channel 实例不能进行写操作,即使该实例所属的类可能有 write( )方法。基于此,程序员需要知道通道是如何打开的,避免试图尝试一个底层 I/O服务不允许的操作。\n\n通道可以以阻塞(blocking)或非阻塞(nonblocking)模式运行。非阻塞模式的通道永远不会让调用的线程休眠。请求的操作要么立即完成,要么返回一个结果表明未进行任何操作。只有面向流的(stream-oriented)的通道,如 sockets 和 pipes 才能使用非阻塞模式。\n\n\n##选择器Selector\n选择器提供选择执行已经就绪的任务的能力，这使得多元I/O成为可能，就绪选择和多元执行使得单线程能够有效率的同时管理多个I/O通道（channels），简单言之就是selector充当一个监视者，您需要将之前创建的一个或多个可选择的通道注册到选择器对象中。一个表示通道和选择器的键将会被返回。选择键会记住您关心的通道。它们也会追踪对应的通道是否已经就绪当您调用一个选择器对象的 select( )方法时,相关的键会被更新,用来检查所有被注册到该选择器的通道。您可以获取一个键的集合,从而找到当时已经就绪的通道。通过遍历这些键,您可以选择出每个从上次您调用 select( )开始直到现在,已经就绪的通道。\n\n###传统的socket监控\n传统的监控多个 socket 的 Java 解决方案是为每个 socket 创建一个线程并使得线程可以在 read( )调用中阻塞,直到数据可用。这事实上将每个被阻塞的线程当作了 socket 监控器,并将 Java 虚拟机的线程调度当作了通知机制。这两者本来都不是为了这种目的而设计的。程序员和 Java 虚拟机都为管理所有这些线程的复杂性和性能损耗付出了代价,这在线程数量的增长时表现得更为突出。\n\n###选择器属性\n* 选择器（Selector）  \n选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册的,并且使用选择器来更新通道的就绪状态。当这么做的时候,可以选择将被激发的线程挂起,直到有就绪的的通道。\n\n* 可选择通道(SelectableChannel)   \nSelectableChannel 可以被注册到 Selector 对象上,同时可以指定对那个选择器而言,那种操作是感兴趣的。一个通道可以被注册到多个选择器上,但对每个选择器而言只能被注册一次。\n\n* 选择键(SelectionKey)   \n选择键封装了特定的通道与特定的选择器的注册关系。选择键对象被SelectableChannel.register( ) 返回并提供一个表示这种注册关系的标记。选择键包含了两个比特集(以整数的形式进行编码),指示了该注册关系所关心的通道操作,以及通道已经准备好的操作。\n\n**下图体现了就绪选择注册和Selector的关系**\n![Selector]({{BASE_PATH}}/image/Selector.png)\n\n一个单独的通道对象可以被注册到多个选择器上。可以调用 isRegistered( )方法来检查一个通道是否被注册到任何一个选择器上。这个方法没有提供关于通道被注册到哪个选择器上的信息,而只能知道它至少被注册到了一个选择器上。此外,在一个键被取消之后,直到通道被注销为止,可能有时间上的延迟。这个方法只是一个提示,而不是确切的答案。\n\n###键对象\n键对象表示了一种特定的注册关系。当应该终结这种关系的时候,可以调用 SelectionKey对象的 cancel( )方法。可以通过调用 isValid( )方法来检查它是否仍然表示一种有效的关系。当键被取消时,它将被放在相关的选择器的已取消的键的集合里。注册不会立即被取消,但键会立即失效。当再次调用 select( )方法时(或者一个正在进行的 select()调用结束时),已取消的键的集合中的被取消的键将被清理掉,并且相应的注销也将完成。通道会被注销,而新的SelectionKey 将被返回。\n\nSelectionKey 类定义了四个便于使用的布尔方法来为您测试这些比特值:isReadable( ),isWritable( ),isConnectable( ), 和 isAcceptable( )。每一个方法都与使用特定掩码来测试 readyOps( )方法的结果的效果相同。例如：\n```java\nif (key.isWritable( ))\n等价于:\nif ((key.readyOps( ) & SelectionKey.OP_WRITE) != 0)\n```\n这四个方法在任意一个 SelectionKey 对象上都能安全地调用。不能在一个通道上注册一个它不支持的操作,这种操作也永远不会出现在 ready 集合中。调用一个不支持的操作将总是返回 false,因为这种操作在该通道上永远不会准备好。\n\n###停止选择过程\n有三种方式可以唤醒在select（）方法中睡眠的线程。\n\n1. 调用wakeup（）   \n调用 Selector 对象的 wakeup( )方法将使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有在进行中的选择,那么下一次对 select( )方法的一种形式的调用将立即返回。后续的选择操作将正常进行。在选择操作之间多次调用 wakeup( )方法与调用它一次没有什么不同。有时这种延迟的唤醒行为并不是您想要的。您可能只想唤醒一个睡眠中的线程,而使得后续的选择继续正常地进行。您可以通过在调用 wakeup( )方法后调用 selectNow( )方法来绕过这个问题。尽管如此,如果您将您的代码构造为合理地关注于返回值和执行选择集合,那么即使下一个 select( )方法的调用在没有通道就绪时就立即返回,也应该不会有什么不同。不管怎么说,您应该为可能发生的事件做好准备。\n\n2. 调用 close( )   \n如果选择器的 close( )方法被调用,那么任何一个在选择操作中阻塞的线程都将被唤醒,就像wakeup( )方法被调用了一样。与选择器相关的通道将被注销,而键将被取消。\n\n3. 调用 interrupt( )   \n如果睡眠中的线程的 interrupt( )方法被调用,它的返回状态将被设置。如果被唤醒的线程之后将试图在通道上执行 I/O 操作,通道将立即关闭,然后线程将捕捉到一个异常。这是由于在第三章中已经探讨过的通道的中断语义。使用 wakeup( )方法将会优雅地将一个在 select( )方法中睡眠的线程唤醒。如果您想让一个睡眠的线程在直接中断之后继续执行,需要执行一些步骤来清理中断状态\n\n\n\n##简单的NIO服务器\n下面是一个简单的NIO服务器的例子，使用select（）来为多个通道提供服务。\n```java\n\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\n\nimport javax.swing.text.html.HTMLDocument.Iterator;\n\n/**\n* Simple echo-back server which listens for incoming stream connections and\n* echoes back whatever it reads. A single Selector object is used to listen to\n* the server socket (to accept new connections) and all the active socket\n* channels.\n* @author zale (zalezone.cn)\n*/\npublic class SelectSockets {\n\tpublic static int PORT_NUMBER = 1234;\n\tpublic static void main(String[] argv) throws Exception \n\t{\n\t\tnew SelectSockets().go(argv);\n\t}\n\tpublic void go(String[] argv) throws Exception \n\t{\n\t\tint port = PORT_NUMBER;\n\t\tif (argv.length > 0) \n\t\t{ // 覆盖默认的监听端口\n\t\t\tport = Integer.parseInt(argv[0]);\n\t\t}\n\t\tSystem.out.println(\"Listening on port \" + port);\n\t\tServerSocketChannel serverChannel = ServerSocketChannel.open();// 打开一个未绑定的serversocketchannel\n\t\tServerSocket serverSocket = serverChannel.socket();// 得到一个ServerSocket去和它绑定\t\n\t\tSelector selector = Selector.open();// 创建一个Selector供下面使用\n\t\tserverSocket.bind(new InetSocketAddress(port));//设置server channel将会监听的端口\n\t\tserverChannel.configureBlocking(false);//设置非阻塞模式\n\t\tserverChannel.register(selector, SelectionKey.OP_ACCEPT);//将ServerSocketChannel注册到Selector\n\t\twhile (true) \n\t\t{\n\t\t\t// This may block for a long time. Upon returning, the\n\t\t\t// selected set contains keys of the ready channels.\n\t\t\tint n = selector.select();\n\t\t\tif (n == 0) \n\t\t\t{\n\t\t\t\tcontinue; // nothing to do\n\t\t\t}\t\t\t\n\t\t\tjava.util.Iterator<SelectionKey> it = selector.selectedKeys().iterator();// Get an iterator over the set of selected keys\n\t\t\t//在被选择的set中遍历全部的key\n\t\t\twhile (it.hasNext()) \n\t\t\t{\n\t\t\t\tSelectionKey key = (SelectionKey) it.next();\n\t\t\t\t// 判断是否是一个连接到来\n\t\t\t\tif (key.isAcceptable()) \n\t\t\t\t{\n\t\t\t\t\tServerSocketChannel server =(ServerSocketChannel) key.channel();\n\t\t\t\t\tSocketChannel channel = server.accept();\n\t\t\t\t\tregisterChannel(selector, channel,SelectionKey.OP_READ);//注册读事件\n\t\t\t\t\tsayHello(channel);//对连接进行处理\n\t\t\t\t}\n\t\t\t\t//判断这个channel上是否有数据要读\n\t\t\t\tif (key.isReadable()) \n\t\t\t\t{\n\t\t\t\t\treadDataFromSocket(key);\n\t\t\t\t}\n\t\t\t\t//从selected set中移除这个key，因为它已经被处理过了\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t}\n\t}\n\t// ----------------------------------------------------------\n\t/**\n\t* Register the given channel with the given selector for the given\n\t* operations of interest\n\t*/\n\tprotected void registerChannel(Selector selector,SelectableChannel channel, int ops) throws Exception\n\t{\n\t\tif (channel == null) \n\t\t{\n\t\t\treturn; // 可能会发生\n\t\t}\n\t\t// 设置通道为非阻塞\n\t\tchannel.configureBlocking(false);\n\t\t// 将通道注册到选择器上\n\t\tchannel.register(selector, ops);\n\t}\n\t// ----------------------------------------------------------\n\t// Use the same byte buffer for all channels. A single thread is\n\t// servicing all the channels, so no danger of concurrent acccess.\n\t//对所有的通道使用相同的缓冲区。单线程为所有的通道进行服务，所以并发访问没有风险\n\tprivate ByteBuffer buffer = ByteBuffer.allocateDirect(1024);\n\t/**\n\t* Sample data handler method for a channel with data ready to read.\n\t* 对于一个准备读入数据的通道的简单的数据处理方法\n\t* @param key\n\t*\n\tA SelectionKey object associated with a channel determined by\n\tthe selector to be ready for reading. If the channel returns\n\tan EOF condition, it is closed here, which automatically\n\tinvalidates the associated key. The selector will then\n\tde-register the channel on the next select call.\n\t\n\t一个选择器决定了和通道关联的SelectionKey object是准备读状态。如果通道返回EOF，通道将被关闭。\n\t并且会自动使相关的key失效，选择器然后会在下一次的select call时取消掉通道的注册\n\t*/\n\tprotected void readDataFromSocket(SelectionKey key) throws Exception \n\t{\n\t\tSocketChannel socketChannel = (SocketChannel) key.channel();\n\t\tint count;\n\t\tbuffer.clear(); // 清空Buffer\n\t\t// Loop while data is available; channel is nonblocking\n\t\t//当可以读到数据时一直循环，通道为非阻塞\n\t\twhile ((count = socketChannel.read(buffer)) > 0) \n\t\t{\n\t\t\tbuffer.flip(); // 将缓冲区置为可读\n\t\t\t// Send the data; don't assume it goes all at once\n\t\t\t//发送数据，不要期望能一次将数据发送完\n\t\t\twhile (buffer.hasRemaining()) \n\t\t\t{\n\t\t\t\tsocketChannel.write(buffer);\n\t\t\t}\n\t\t\t// WARNING: the above loop is evil. Because\n\t\t\t// it's writing back to the same nonblocking\n\t\t\t// channel it read the data from, this code can\n\t\t\t// potentially spin in a busy loop. In real life\n\t\t\t// you'd do something more useful than this.\n\t\t\t//这里的循环是无意义的，具体按实际情况而定\n\t\t\tbuffer.clear(); // Empty buffer\n\t\t}\n\t\tif (count < 0) \n\t\t{\n\t\t\t// Close channel on EOF, invalidates the key\n\t\t\t//读取结束后关闭通道，使key失效\n\t\t\tsocketChannel.close();\n\t\t}\n\t}\n\t// ----------------------------------------------------------\n\t/**\n\t* Spew a greeting to the incoming client connection.\n\t*\n\t* @param channel\n\t*\n\tThe newly connected SocketChannel to say hello to.\n\t*/\n\tprivate void sayHello(SocketChannel channel) throws Exception \n\t{\n\t\tbuffer.clear();\n\t\tbuffer.put(\"Hi there!\\r\\n\".getBytes());\n\t\tbuffer.flip();\n\t\tchannel.write(buffer);\n\t}\n}\n```\n---\n###原理解释\n上面这个例子实现了一个简单的服务器，它创建了 ServerSocketChannel 和 Selector 对象,并将通道注册到选择器上。我们不在注册的键中保存服务器 socket 的引用,因为它永远不会被注销。这个无限循环在最上面先调用了 select( ),这可能会无限期地阻塞。当选择结束时,就遍历选择键并检查已经就绪的通道。\n\n如果一个键指示与它相关的通道已经准备好执行一个 accecpt( )操作,我们就通过键获取关联的通道,并将它转换为 SeverSocketChannel 对象。我们都知道这么做是安全的,因为只有ServerSocketChannel 支持 OP_ACCEPT 操作。我们也知道我们的代码只把对一个单一的ServerSocketChannel 对象的 OP_ACCEPT 操作进行了注册。通过对服务器 socket 通道的引用,我 们调用了它 的 accept( )方法 ,来获取刚到达 的 socket 的句 柄。返回的 对象的类型 是\nSocketChannel,也是一个可选择的通道类型。这时,与创建一个新线程来从新的连接中读取数据不同,我们只是简单地将 socket 同多注册到选择器上。我们通过传入 OP_READ 标记,告诉选择器我们关心新的 socket 通道什么时候可以准备好读取数据。\n\n如果键指示通道还没有准备好执行 accept( ),我们就检查它是否准备好执行 read( )。任何一个这么指示的 socket 通道一定是之前 ServerSocketChannel 创建的 SocketChannel 对象之一,并且被注册为只对读操作感兴趣。对于每个有数据需要读取的 socket 通道,我们调用一个公共的方法来读取并处理这个带有数据的 socket。需要注意的是这个公共方法需要准备好以非阻塞的方式处理 socket 上的不完整的数据。它需要迅速地返回,以其他带有后续输入的通道能够及时地得到处理。例 4-1 中只是简单地对数据进行响应,将数据写回 socket,传回给发送者。\n\n在循环的底部,我们通过调用 Iterator(迭代器)对象的 remove()方法,将键从已选择的键的集合中移除。键可以直接从 selectKeys()返回的 Set 中移除,但同时需要用 Iterator 来检查集合,您需要使用迭代器的 remove()方法来避免破坏迭代器内部的状态。\n\n##并发性\n选择器对象是线程安全的,但它们包含的键集合不是。通过 keys( )和 selectKeys( )返回的键的集合是 Selector 对象内部的私有的 Set 对象集合的直接引用。这些集合可能在任意时间被改变。已注册的键的集合是只读的。如果您试图修改它,那么您得到的奖品将是一个java.lang.UnsupportedOperationException,但是当您在观察它们的时候,它们可能发生了改变的话,您仍然会遇到麻烦。Iterator 对象是快速失败的(fail-fast):如果底层的 Set 被改变了,它们将会抛出 java.util.ConcurrentModificationException,因此如果您期望在多个线程间共享选择器和/或键,请对此做好准备。您可以直接修改选择键,但请注意您这么做时可能会彻底破坏另一个线程的 Iterator。\n\n如果在多个线程并发地访问一个选择器的键的集合的时候存在任何问题,您可以采取一些步骤来合理地同步访问。在执行选择操作时,选择器在 Selector 对象上进行同步,然后是已注册的键的集合,最后是已选择的键的集合,按照这样的顺序。已取消的键的集合也在选择过程的的第 1步和第 3 步之间保持同步(当与已取消的键的集合相关的通道被注销时)。\n\n在多线程的场景中,如果您需要对任何一个键的集合进行更改,不管是直接更改还是其他操作带来的副作用,您都需要首先以相同的顺序,在同一对象上进行同步。锁的过程是非常重要的。如果竞争的线程没有以相同的顺序请求锁,就将会有死锁的潜在隐患。如果您可以确保否其他线程不会同时访问选择器,那么就不必要进行同步了。\n\nSelector 类的 close( )方法与 slect( )方法的同步方式是一样的,因此也有一直阻塞的可能性。在选择过程还在进行的过程中,所有对 close( )的调用都会被阻塞,直到选择过程结束,或者执行选择的线程进入睡眠。在后面的情况下,执行选择的线程将会在执行关闭的线程获得锁时立即被唤醒,并关闭选择器。\n\n##选择过程的可扩展性\n对于单CPU的系统用一个线程来为多个通道提供服务可能是个好主意，但是对于多个CPU的系统来说就可能不能使其他CPU高效发挥作用。  \n\n一个比较好的优化策略是对所有的可选择通道使用一个选择器,并将对就绪通道的服务委托给其他线程。根据部署的条件,线程池的大小是可以调整的(或者它自己进行动态的调整)。  \n\n另外，有些通道要求比其他通道有更高的响应速度，可以通过使用两个选择器来解决：一个为命令连接服务，另一个为普通连接服务。与将所有准备好的通道放到同一个线程池的做法不同,通道可以根据功能由不同的工作线程来处理。它们可能可以是日志线程池,命令/控制线程池,状态请求线程池,等等。\n\n##服务线程池服务器示例\n这个例子是上一个简单服务器的一般性的选择循环的扩展。它覆写了 readDataFromSocket( )方法,并使用线程池来为准备好数据用于读取的通道提供服务。与在主线程中同步地读取数据不同,这个版本的实现将 SelectionKey 对象传递给为其服务的工作线程。\n\n###使用线程池来为通道提供服务\n```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n* Specialization of the SelectSockets class which uses a thread pool to service\n* channels. The thread pool is an ad-hoc implementation quicky lashed togther\n* in a few hours for demonstration purposes. It's definitely not production\n* quality.\n*\n* @author Ron Hitchens (ron@ronsoft.com)\n*/\npublic class SelectSocketsThreadPool extends SelectSockets \n{\n\tprivate static final int MAX_THREADS = 5;\n\tprivate ThreadPool pool = new ThreadPool(MAX_THREADS);\n\t// -------------------------------------------------------------\n\tpublic static void main(String[] argv) throws Exception \n\t{\n\t\tnew SelectSocketsThreadPool().go(argv);\n\t}\n\t// -------------------------------------------------------------\n\t/**\n\t* Sample data handler method for a channel with data ready to read. This\n\t* method is invoked from(被调用) the go( ) method in the parent class. This handler\n\t* delegates（委托） to a worker thread in a thread pool to service the channel,\n\t* then returns immediately.\n\t*\n\t* @param key\n\t*\n\tA SelectionKey object representing a channel determined by the\n\t*\n\tselector to be ready for reading. If the channel returns an\n\t*\n\tEOF condition, it is closed here, which automatically\n\t*\n\tinvalidates the associated key. The selector will then\n\t*\n\tde-register the channel on the next select call.\n\t*/\n\tprotected void readDataFromSocket(SelectionKey key) throws Exception \n\t{\n\t\tWorkerThread worker = pool.getWorker();\n\t\tif (worker == null) \n\t\t{\n\t\t\t// No threads available. Do nothing. The selection\n\t\t\t// loop will keep calling this method until a\n\t\t\t// thread becomes available. This design could\n\t\t\t// be improved.\n\t\t\treturn;\n\t\t}\n\t\t// Invoking this wakes up the worker thread, then returns\n\t\tworker.serviceChannel(key);\n\t}\n\t// ---------------------------------------------------------------\n\t/**\n\t* A very simple thread pool class. The pool size is set at construction\n\t* time and remains fixed. Threads are cycled through a FIFO idle queue.\n\t*/\n\tprivate class ThreadPool\n\t{\n\t\tList idle = new LinkedList();\n\t\tThreadPool(int poolSize) \n\t\t{\n\t\t\t// Fill up the pool with worker threads\n\t\t\tfor (int i = 0; i < poolSize; i++)\n\t\t\t{\n\t\t\t\tWorkerThread thread = new WorkerThread(this);\n\t\t\t\t// Set thread name for debugging. Start it.\n\t\t\t\tthread.setName(\"Worker\" + (i + 1));\n\t\t\t\tthread.start();\n\t\t\t\tidle.add(thread);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t* Find an idle worker thread, if any. Could return null.\n\t\t*/\n\t\tWorkerThread getWorker() \n\t\t{\n\t\t\tWorkerThread worker = null;\n\t\t\tsynchronized (idle) \n\t\t\t{\n\t\t\t\tif (idle.size() > 0) \n\t\t\t\t{\n\t\t\t\t\tworker = (WorkerThread) idle.remove(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (worker);\n\t\t}\n\t\t/**\n\t\t* Called by the worker thread to return itself to the idle pool.\n\t\t*/\n\t\tvoid returnWorker(WorkerThread worker) \n\t\t{\n\t\t\tsynchronized (idle) \n\t\t\t{\n\t\t\t\tidle.add(worker);\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t* A worker thread class which can drain（排空） channels and echo-back（回显） the input.\n\t* Each instance is constructed with a reference（参考） to the owning thread pool\n\t* object. When started, the thread loops forever waiting to be awakened to\n\t* service the channel associated with a SelectionKey object. The worker is\n\t* tasked by calling its serviceChannel( ) method with a SelectionKey\n\t* object. The serviceChannel( ) method stores the key reference in the\n\t* thread object then calls notify( ) to wake it up. When the channel has\n\t* been drained, the worker thread returns itself to its parent pool.\n\t*/\n\tprivate class WorkerThread extends Thread \n\t{\n\t\tprivate ByteBuffer buffer = ByteBuffer.allocate(1024);\n\t\tprivate ThreadPool pool;\n\t\tprivate SelectionKey key;\n\t\tWorkerThread(ThreadPool pool) \n\t\t{\n\t\t\tthis.pool = pool;\n\t\t}\n\t\t// Loop forever waiting for work to do\n\t\tpublic synchronized void run() \n\t\t{\n\t\t\tSystem.out.println(this.getName() + \" is ready\");\n\t\t\twhile (true) \n\t\t\t{\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\t// Sleep and release object lock\n\t\t\t\t\t//休眠并且释放掉对象锁\n\t\t\t\t\tthis.wait();\n\t\t\t\t} \n\t\t\t\tcatch (InterruptedException e) \n\t\t\t\t{\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t// Clear interrupt status\n\t\t\t\t\tthis.interrupted();\n\t\t\t\t}\n\t\t\t\tif (key == null) \n\t\t\t\t{\n\t\t\t\t\tcontinue; // just in case\n\t\t\t\t}\n\t\t\t\tSystem.out.println(this.getName() + \" has been awakened\");\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tdrainChannel(key);\n\t\t\t\t} \n\t\t\t\tcatch (Exception e) \n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Caught '\" + e + \"' closing channel\");\n\t\t\t\t\t// Close channel and nudge selector\n\t\t\t\t\ttry \n\t\t\t\t\t{\n\t\t\t\t\t\tkey.channel().close();\n\t\t\t\t\t} \n\t\t\t\t\tcatch (IOException ex) \n\t\t\t\t\t{\n\t\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tkey.selector().wakeup();\n\t\t\t\t}\n\t\t\t\tkey = null;\n\t\t\t\t// Done. Ready for more. Return to pool\n\t\t\t\tthis.pool.returnWorker(this);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t* Called to initiate a unit of work by this worker thread on the\n\t\t* provided SelectionKey object. This method is synchronized, as is the\n\t\t* run( ) method, so only one key can be serviced at a given time.\n\t\t* Before waking the worker thread, and before returning to the main\n\t\t* selection loop, this key's interest set is updated to remove OP_READ.\n\t\t* This will cause the selector to ignore read-readiness for this\n\t\t* channel while the worker thread is servicing it.\n\t\t* 通过一个被提供SelectionKey对象的工作线程来初始化一个工作集合，这个方法是同步的，所以\n\t\t* 里面的run方法只有一个key能被服务在同一个时间，在唤醒工作线程和返回到主循环之前，这个key的\n\t\t* 感兴趣的集合被更新来删除OP_READ，这将会引起工作线程在提供服务的时候选择器会忽略读就绪的通道\n\t\t*/\n\t\tsynchronized void serviceChannel(SelectionKey key) \n\t\t{\n\t\t\tthis.key = key;\n\t\t\tkey.interestOps(key.interestOps() & (~SelectionKey.OP_READ));\n\t\t\tthis.notify(); // Awaken the thread\n\t\t}\n\t\t/**\n\t\t* The actual code which drains the channel associated with the given\n\t\t* key. This method assumes the key has been modified prior to\n\t\t* invocation to turn off selection interest in OP_READ. When this\n\t\t* method completes it re-enables OP_READ and calls wakeup( ) on the\n\t\t* selector so the selector will resume watching this channel.\n\t\t*/\n\t\tvoid drainChannel(SelectionKey key) throws Exception \n\t\t{\n\t\t\tSocketChannel channel = (SocketChannel) key.channel();\n\t\t\tint count;\n\t\t\tbuffer.clear(); // 清空buffer\n\t\t\t// Loop while data is available; channel is nonblocking\n\t\t\twhile ((count = channel.read(buffer)) > 0)\n\t\t\t{\n\t\t\t\tbuffer.flip(); // make buffer readable\n\t\t\t\t// Send the data; may not go all at once\n\t\t\t\twhile (buffer.hasRemaining()) \n\t\t\t\t{\n\t\t\t\t\tchannel.write(buffer);\n\t\t\t\t}\n\t\t\t\t// WARNING: the above loop is evil.\n\t\t\t\t// See comments in superclass.\n\t\t\t\tbuffer.clear(); // Empty buffer\n\t\t\t}\n\t\t\tif (count < 0) \n\t\t\t{\n\t\t\t\t// Close channel on EOF; invalidates the key\n\t\t\t\tchannel.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Resume interest in OP_READ\n\t\t\tkey.interestOps(key.interestOps() | SelectionKey.OP_READ);\n\t\t\t// Cycle the selector so this key is active again\n\t\t\tkey.selector().wakeup();\n\t\t}\n\t}\n}\n```\n---\n###原理解释\n由于执行选择过程的线程将重新循环并几乎立即再次调用 select( ),键的 interest 集合将被修改,并将 interest(感兴趣的操作)从读取就绪(read-rreadiness)状态中移除。这将防止选择器重复地调用 readDataFromSocket( )(因为通道仍然会准备好读取数据,直到工作线程从它那里读取数据)。当工作线程结束为通道提供的服务时,它将再次更新键的 ready 集合,来将 interest 重新放到读取就绪集合中。它也会在选择器上显式地调用 wakeup( )。如果主线程在 select( )中被阻塞,这将使它继续执行。这个选择循环会再次执行一个轮回(可能什么也没做)并带着被更新的键重新进入select( )。\n\n#总结\n对于java NIO的常见框架有Mina，Netty等，关于Mina和Netty到底哪个框架比较好，因为还未深入进行研究，\n所以也不敢下定论，但个人还是倾向Netty框架吧。下一步准备好好研究一下Netty框架。\n\n**参考文献**：[《java NIO》](http://book.douban.com/subject/1433583/)\n","slug":"NIO精粹","updated":1411645325000,"excerpt":"<p><img src=\"/image/javaboy.jpg\" alt=\"javaNIO\"></p>\n<h1 id=\"前言\">前言</h1>\n<p>我们在写java程序的时候，为了进行优化，把全部的精力用在了处理效率上，但是对IO的关注却很少。这也可能是由以前java早期时JVM在解释字节码时速度慢，运行速率大大低于本地编译代码，因此以前往往忽视了IO的优化。   </p>\n<p>但是现在<a href=\"http://baike.baidu.com/view/160708.htm\" target=\"_blank\" rel=\"external\">JVM</a>在运行时优化已前进了一大步，现在的java应用程序更多的是受IO的束缚，也就是将时间花在等待数据传输上。现在有了<a href=\"http://baike.baidu.com/view/1007976.htm?from_id=13029359&amp;type=syn&amp;fromtitle=java+nio&amp;fr=aladdin\" target=\"_blank\" rel=\"external\">NIO</a>，就可以减少<a href=\"http://baike.baidu.com/subview/1142749/5362454.htm\" target=\"_blank\" rel=\"external\">IO</a>的等待时间，从而提升IO的效率。</p>\n<p>","_id":"v0iex2kn3q70aeyg","comments":true,"layout":"post","photos":[],"link":""},{"title":"Git使用小记","date":1407921660000,"categories":["klheiemw6tkdcymi"],"tags":["9f9y6vaw8hxic410","lsp9noqi7o40u9is","37ipdvrpy8kllo3s"],"desctiption":"代码管理git使用教程","content":"<h2 id=\"前言：\">前言：</h2>\n<p>我们写代码写完后总要进行管理，以前写的很多代码虽然写的不是很好，但因为没有一个比较好的代码管理习惯，所以很多都遗失掉了，为此现在都还觉得很可惜，近来在学习使用git来进行代码管理，git是一个很强大的分布式版本控制系统。</p>\n<p><img src=\"/image/git流程.png\" alt=\"git\"></p>\n<h2 id=\"git工作流程\">git工作流程</h2>\n<p>了解git，首先要弄清楚对象在被git管理过程中所处的4个阶段，分别是：工作目录、index(又称为暂存区)、本地仓库和远程仓库。<a id=\"more\"></a></p>\n<p>从时间先后来讲，工作目录的内容是你当前看到的，也是最新的；index区标记了你当前工作目录中，哪些内容是被git管理的；而本地仓库保存了对象被提交过的各个版本，比起工作目录和暂存区的内容，它要更旧一些；远程仓库是本地仓库的异地备份，远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。</p>\n<p>任何对象都是在工作目录中诞生和被修改；任何修改都是从进入index区才开始被版本控制；只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；而要与协作者分享本地的修改，可以把它们push到远程仓库来共享。图最上方的add、commit、push等，展示了git仓库的产生过程。反过来，我们可以从远程历史仓库中获得本地仓库的最后一个版本，clone到本地，从本地检出对象的各个版本到index暂存区或工作目录中，从而实现任何对象或整个仓库的任意阶段状态的”回滚”。当正向和反向都能自由切换后，git就强大到无所不能了。</p>\n<h2 id=\"远程仓库操作命令\">远程仓库操作命令</h2>\n<ul>\n<li><p>从远程仓库克隆仓库到本地：$ git clone git://github.com/<strong>**</strong>.git</p>\n</li>\n<li><p>查看远程仓库别名以及地址：$ git remote -v</p>\n</li>\n<li><p>添加远程仓库：$ git remote add [name] [url]</p>\n</li>\n<li><p>删除远程仓库：$ git remote rm [name]</p>\n</li>\n<li><p>修改远程仓库：$ git remote set-url —push [name] [newUrl]</p>\n</li>\n<li><p>拉取远程仓库：$ git pull [remoteName] [localBranchName]</p>\n</li>\n<li><p>推送远程仓库：$ git push [remoteName] [localBranchName]</p>\n</li>\n<li><p>提交本地test分支作为远程的master分支：$git push origin test:master</p>\n</li>\n<li><p>提交本地test分支作为远程的test分支：$git push origin test:test</p>\n</li>\n</ul>\n<h2 id=\"分支操作命令—branch\">分支操作命令—branch</h2>\n<ul>\n<li><p>查看远程和本地所有分支：$ git branch -a</p>\n</li>\n<li><p>创建本地分支：$ git branch [name]</p>\n</li>\n<li><p>切换分支：$ git checkout [name]</p>\n</li>\n<li><p>创建新分支并且切换到新的分支：$ git check -b [name]</p>\n</li>\n<li><p>复制远程的分支并且以此来创建新分支：$ git check -t /remotes/origin/branch1  //这样就能在本地创建一个复制来自远程branch1分支</p>\n</li>\n<li><p>删除分支：$ git branch -d [name]  //-d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p>\n</li>\n<li><p>合并分支：$git merge [name]  //将名称为[name]的分支与当前的分支合并</p>\n</li>\n<li><p>创建远程分支：(本地分支push到远程)：$ git push origin [name]</p>\n</li>\n<li><p>删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]</p>\n</li>\n</ul>\n<h2 id=\"版本(tag)操作相关命令\">版本(tag)操作相关命令</h2>\n<ul>\n<li><p>查看版本：$ git tag</p>\n</li>\n<li><p>创建版本：$ git tag [name]</p>\n</li>\n<li><p>删除版本：$ git tag -d [name]</p>\n</li>\n<li><p>查看远程版本：$ git tag -r</p>\n</li>\n<li><p>创建远程版本(本地版本push到远程)：$ git push origin [name]</p>\n</li>\n<li><p>删除远程版本：$ git push origin :refs/tags/[name]</p>\n</li>\n<li><p>合并远程仓库的tag到本地：$ git pull origin —tags</p>\n</li>\n<li><p>上传本地tag到远程仓库：$ git push origin —tags</p>\n</li>\n<li><p>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</p>\n</li>\n</ul>\n<h2 id=\"子模块(submodule)相关操作命令\">子模块(submodule)相关操作命令</h2>\n<ul>\n<li><p>添加子模块：$ git submodule add [url] [path]</p>\n</li>\n<li><p>初始化子模块：$ git submodule init ——只在首次检出仓库时运行一次就行</p>\n</li>\n<li><p>更新子模块：$ git submodule update ——每次更新或切换分支后都需要运行一下</p>\n</li>\n<li><p>删除子模块：（分4步走哦）</p>\n<ol>\n<li><p>$ git rm —cached [path]</p>\n</li>\n<li><p>编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</p>\n</li>\n<li><p>编辑“ .git/config”文件，将子模块的相关配置节点删除掉</p>\n</li>\n<li><p>手动删除子模块残留的目录</p>\n</li>\n</ol>\n</li>\n<li><p>忽略一些文件、文件夹不提交</p>\n<ul>\n<li>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">target</span></div><div class=\"line\"></div><div class=\"line\">bin</div><div class=\"line\"></div><div class=\"line\"><span class=\"regexp\">*.db</span></div></pre></td></tr></table></figure>\n\n<ul>\n<li><p>删除缓存区的文件</p>\n<ul>\n<li>不怎么进行删除操作，所以就常用这一个命令：$ git rm -r —cached .</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"git撤销操作\">git撤销操作</h2>\n<h3 id=\"撤销已暂存的操作\">撤销已暂存的操作</h3>\n<p>对于一些已经被<strong>git add</strong>后的文件，如果想要撤销刚刚的操作，就要进行如下操作:</p>\n<ul>\n<li>首先查看一下本地有哪些已经被<strong>add</strong>但是还未<strong>commit</strong>的数据，</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">git</span> status</div></pre></td></tr></table></figure>\n\n<ul>\n<li>然后找到你要进行删掉的文件后，执行：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"operator\"><span class=\"keyword\">reset</span> HEAD filename</span></div></pre></td></tr></table></figure>\n\n<h3 id=\"撤销commit\">撤销commit</h3>\n<p>对于已经commit的数据，要回退的步骤为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">rm</span> <span class=\"literal\">-</span><span class=\"comment\">r</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">cached</span></div></pre></td></tr></table></figure>\n\n<h3 id=\"git_版本回退\">git 版本回退</h3>\n<p><strong>关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退</strong></p>\n<ol>\n<li>先来说说本地的好了，本地的话就依次执行一下操作即可。</li>\n</ol>\n<p>根据-soft,-mixed,-hard，会对working tree和index和HEAD进行重置：</p>\n<pre><code>1.git <span class=\"operator\"><span class=\"keyword\">reset</span> -mixed：这种为默认方式，不带任何参数的git <span class=\"keyword\">reset</span>，它回退到某个版本，只保留源码，回退<span class=\"keyword\">commit</span>和<span class=\"keyword\">index</span>信息\n\n<span class=\"number\">2.</span>git <span class=\"keyword\">reset</span> -soft: 回退到某个版本，只回退了<span class=\"keyword\">commit</span>信息，不会恢复到<span class=\"keyword\">index</span> file一级。如果还要提交的话，直接<span class=\"keyword\">commit</span>即可。\n\n<span class=\"number\">3.</span>git <span class=\"keyword\">reset</span> -hard:彻底回退到某个版本，本地的源码也会变成上一个版本的内容，操作需要谨慎！！\n\n\n示例：\n\n* HEAD是指向最新的提交的，上一次的提交是HEAD^,上上次是HEAD^^,也可以写成HEAD~<span class=\"number\">2</span>,其中的<span class=\"comment\">--hard表示放弃所有本地改动</span></span>\n</code></pre><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"operator\"><span class=\"keyword\">reset</span> <span class=\"comment\">--hard HEAD^</span></span></div></pre></td></tr></table></figure>\n\n\n<p> 或者也可以回退倒指定的版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"operator\"><span class=\"keyword\">reset</span> <span class=\"comment\">--hard &lt;哈希值&gt;</span></span></div></pre></td></tr></table></figure>\n\n\n<p>2.关于远程的话也得分情况了，如果远程仓库能够远程ssh上去的话那就比较简单了，方法和在本地一样了，但是如果ssh上不上去就不行了，这里我看到找到了两种方法：</p>\n<ul>\n<li><p><strong>第一种就是比较暴力的方法，就是直接强制提交，git push -f,但是这个非常不推荐，除非你是自己一个人开发的小项目。</strong></p>\n</li>\n<li><p><strong>第二种就是先将远程分支备份好以后直接删除，然后再将本地的回滚后的版本的push到远程分支上，这样就等于回退了版本。</strong></p>\n</li>\n</ul>\n<h2 id=\"git_merge解冲突\">git merge解冲突</h2>\n<p><strong>在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。</strong></p>\n<p>这里假设有两个分支，一个是develop分支，一个是developby分支，develop分支是主要分支，这时候，我们可以 在developby分支里面运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"operator\"><span class=\"keyword\">merge</span> develop</span></div></pre></td></tr></table></figure>\n\n<p>这样的话就将将develop中的内容merge到了developby分支中，如果没有冲突的话，merge完成，如果有冲突的话，运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">git</span> diff</div></pre></td></tr></table></figure>\n\n<p>这样的话git会列出有冲突的文件，比如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class=\"constant\">HEAD</span></div><div class=\"line\"></div><div class=\"line\">printf (“test1″);</div><div class=\"line\"></div><div class=\"line\">=======</div><div class=\"line\"></div><div class=\"line\"><span class=\"input\"><span class=\"prompt\">printf (“test2″);</span></span></div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop</div></pre></td></tr></table></figure>\n\n<p><strong>接下来我们来讲解一下里面的符号各代表什么意思。</strong></p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 标记冲突的开始，后面的内同是当前分支中的内容。</p>\n<p>HEAD 指向当前分支末梢的提交。</p>\n<p>=======之后，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之前 是从develop分支上面merge过来的代码。&gt;&gt;&gt;&gt;&gt;&gt;&gt;之后跟的是要合并过来的分支的名称。</p>\n<p><strong>然后我们就开始手动解冲突了</strong></p>\n<p>这时候根据你的需要选择你要保留的是哪个分支上的代码，你要删除哪个分支上的代码，想要删除的代码就直接删掉就可以了，最后将多余符号删掉保存就可以了。</p>\n<h2 id=\"一般的代码管理流程：\">一般的代码管理流程：</h2>\n<ol>\n<li><p>远程已经建完仓库后直接克隆到本地： $ git clone [仓库地址]</p>\n</li>\n<li><p>查看本地和远程的branch：$ git branch -a</p>\n</li>\n<li><p>如果远程的branch更新了的话运行：$ git fetch -p      //这样会将远程的分支列表重新拉取</p>\n</li>\n<li><p>将远程的branch复制到本地并且切换到这个分支下面：$ git checkout -t [远程分支名字]</p>\n</li>\n<li><p>这是看到自己已经在新建的branch下面了，然后看一下有没有文件。</p>\n</li>\n<li><p>若没有的话试一下：$ git pull</p>\n</li>\n<li><p>做完修改以后的话先add：$ git add .      //这样会将除了在.gitignore中写入的文件都加入进要提交的文件内</p>\n</li>\n<li><p>然后进行提交到本地仓库：$ git commit - m “提交”</p>\n</li>\n<li><p>可以查看状态：$ git status 或者 $git diff</p>\n</li>\n<li><p>如果没什么问题的话就进行提交到远程库： $ git push     //如果加入-f的话是强制提交。</p>\n</li>\n</ol>\n","source":"_posts/git使用小记.md","raw":"title: Git使用小记\ndate: 2014-08-13 17:21:00\ncategories: linux\ntags: [linux,git,代码管理]\ndesctiption: 代码管理git使用教程\n\n---\n\n##前言：\n\n我们写代码写完后总要进行管理，以前写的很多代码虽然写的不是很好，但因为没有一个比较好的代码管理习惯，所以很多都遗失掉了，为此现在都还觉得很可惜，近来在学习使用git来进行代码管理，git是一个很强大的分布式版本控制系统。\n\n![git]({{BASE_PATH}}/image/git流程.png)\n##git工作流程\n了解git，首先要弄清楚对象在被git管理过程中所处的4个阶段，分别是：工作目录、index(又称为暂存区)、本地仓库和远程仓库。<!--more-->\n   \n从时间先后来讲，工作目录的内容是你当前看到的，也是最新的；index区标记了你当前工作目录中，哪些内容是被git管理的；而本地仓库保存了对象被提交过的各个版本，比起工作目录和暂存区的内容，它要更旧一些；远程仓库是本地仓库的异地备份，远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。\n   \n任何对象都是在工作目录中诞生和被修改；任何修改都是从进入index区才开始被版本控制；只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；而要与协作者分享本地的修改，可以把它们push到远程仓库来共享。图最上方的add、commit、push等，展示了git仓库的产生过程。反过来，我们可以从远程历史仓库中获得本地仓库的最后一个版本，clone到本地，从本地检出对象的各个版本到index暂存区或工作目录中，从而实现任何对象或整个仓库的任意阶段状态的”回滚”。当正向和反向都能自由切换后，git就强大到无所不能了。\n\n##远程仓库操作命令\n\n* 从远程仓库克隆仓库到本地：$ git clone git://github.com/******.git\n\n* 查看远程仓库别名以及地址：$ git remote -v\n\n* 添加远程仓库：$ git remote add [name] [url]\n\n* 删除远程仓库：$ git remote rm [name]\n\n* 修改远程仓库：$ git remote set-url --push [name] [newUrl]\n\n* 拉取远程仓库：$ git pull [remoteName] [localBranchName]\n\n* 推送远程仓库：$ git push [remoteName] [localBranchName]\n\n* 提交本地test分支作为远程的master分支：$git push origin test:master\n\n* 提交本地test分支作为远程的test分支：$git push origin test:test\n\n\n##分支操作命令--branch\n\n* 查看远程和本地所有分支：$ git branch -a\n\n* 创建本地分支：$ git branch [name]\n\n* 切换分支：$ git checkout [name]\n\n* 创建新分支并且切换到新的分支：$ git check -b [name]\n\n* 复制远程的分支并且以此来创建新分支：$ git check -t /remotes/origin/branch1  //这样就能在本地创建一个复制来自远程branch1分支\n\n* 删除分支：$ git branch -d [name]  //-d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项\n\n* 合并分支：$git merge [name]  //将名称为[name]的分支与当前的分支合并\n\n* 创建远程分支：(本地分支push到远程)：$ git push origin [name]\n\n* 删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]\n\n\n##版本(tag)操作相关命令\n\n* 查看版本：$ git tag\n\n* 创建版本：$ git tag [name]\n\n* 删除版本：$ git tag -d [name]\n\n* 查看远程版本：$ git tag -r\n\n* 创建远程版本(本地版本push到远程)：$ git push origin [name]\n\n* 删除远程版本：$ git push origin :refs/tags/[name]\n\n* 合并远程仓库的tag到本地：$ git pull origin --tags\n\n* 上传本地tag到远程仓库：$ git push origin --tags\n\n* 创建带注释的tag：$ git tag -a [name] -m 'yourMessage'\n\n##子模块(submodule)相关操作命令\n\n* 添加子模块：$ git submodule add [url] [path]\n\n* 初始化子模块：$ git submodule init ----只在首次检出仓库时运行一次就行\n\n* 更新子模块：$ git submodule update ----每次更新或切换分支后都需要运行一下\n\n* 删除子模块：（分4步走哦）\n\n    1. $ git rm --cached [path]\n\n    2. 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉\n\n    3. 编辑“ .git/config”文件，将子模块的相关配置节点删除掉\n\n    4. 手动删除子模块残留的目录\n\n* 忽略一些文件、文件夹不提交\n\n    * 在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如\n\n```shell\n        target\n        \n        bin\n        \n        *.db\n```\n\n* 删除缓存区的文件\n\n    * 不怎么进行删除操作，所以就常用这一个命令：$ git rm -r --cached .\n\n##git撤销操作\n\n###撤销已暂存的操作\n对于一些已经被**git add**后的文件，如果想要撤销刚刚的操作，就要进行如下操作:\n\n* 首先查看一下本地有哪些已经被**add**但是还未**commit**的数据，\n\n\n```shell\ngit status\n```\n\n* 然后找到你要进行删掉的文件后，执行：\n\n```shell\ngit reset HEAD filename\n```\n\n###撤销commit\n\n对于已经commit的数据，要回退的步骤为：\n\n```shell\n$ git rm -r --cached\n```\n\n###git 版本回退\n\n**关于版本回退略微有点小复杂，因为回退的版本涉及到两种情况，一种就是本地的版本回退，另一种则是本地和远程仓库都提交后的版本回退**\n\n1. 先来说说本地的好了，本地的话就依次执行一下操作即可。\n\n根据-soft,-mixed,-hard，会对working tree和index和HEAD进行重置：\n\n\t1.git reset -mixed：这种为默认方式，不带任何参数的git reset，它回退到某个版本，只保留源码，回退commit和index信息\n\n\t2.git reset -soft: 回退到某个版本，只回退了commit信息，不会恢复到index file一级。如果还要提交的话，直接commit即可。\n\n\t3.git reset -hard:彻底回退到某个版本，本地的源码也会变成上一个版本的内容，操作需要谨慎！！\n\n\n\t示例：\n\n    * HEAD是指向最新的提交的，上一次的提交是HEAD^,上上次是HEAD^^,也可以写成HEAD~2,其中的--hard表示放弃所有本地改动\n    ```shell\n    git reset --hard HEAD^  \n    ```\n   \n 或者也可以回退倒指定的版本\n   \n   \n    ```shell\n    git reset --hard <哈希值>\n    ```\n    \n2.关于远程的话也得分情况了，如果远程仓库能够远程ssh上去的话那就比较简单了，方法和在本地一样了，但是如果ssh上不上去就不行了，这里我看到找到了两种方法：\n\n* **第一种就是比较暴力的方法，就是直接强制提交，git push -f,但是这个非常不推荐，除非你是自己一个人开发的小项目。**\n    \n* **第二种就是先将远程分支备份好以后直接删除，然后再将本地的回滚后的版本的push到远程分支上，这样就等于回退了版本。**\n\n##git merge解冲突\n**在进行git管理时在对两个分支进行merge时难免会产生冲突，这时候就要对两个分支进行解冲突。**\n\n这里假设有两个分支，一个是develop分支，一个是developby分支，develop分支是主要分支，这时候，我们可以 在developby分支里面运行\n```shell\ngit merge develop\n```\n这样的话就将将develop中的内容merge到了developby分支中，如果没有冲突的话，merge完成，如果有冲突的话，运行\n```shell\ngit diff\n```\n这样的话git会列出有冲突的文件，比如：\n\n```shell\n<<<<<<< HEAD\n\nprintf (“test1″);\n\n=======\n\nprintf (“test2″);\n\n>>>>>>> develop\n```\n\n**接下来我们来讲解一下里面的符号各代表什么意思。**\n\n<<<<<<< 标记冲突的开始，后面的内同是当前分支中的内容。\n\nHEAD 指向当前分支末梢的提交。\n\n=======之后，>>>>>>>之前 是从develop分支上面merge过来的代码。>>>>>>>之后跟的是要合并过来的分支的名称。\n\n**然后我们就开始手动解冲突了**\n\n这时候根据你的需要选择你要保留的是哪个分支上的代码，你要删除哪个分支上的代码，想要删除的代码就直接删掉就可以了，最后将多余符号删掉保存就可以了。\n\n\n##一般的代码管理流程：\n\n\n1. 远程已经建完仓库后直接克隆到本地： $ git clone [仓库地址]\n\n2. 查看本地和远程的branch：$ git branch -a\n\n3. 如果远程的branch更新了的话运行：$ git fetch -p      //这样会将远程的分支列表重新拉取\n\n4. 将远程的branch复制到本地并且切换到这个分支下面：$ git checkout -t [远程分支名字]\n\n5. 这是看到自己已经在新建的branch下面了，然后看一下有没有文件。\n\n6. 若没有的话试一下：$ git pull\n\n7. 做完修改以后的话先add：$ git add .      //这样会将除了在.gitignore中写入的文件都加入进要提交的文件内\n\n8. 然后进行提交到本地仓库：$ git commit - m \"提交\"\n\n9. 可以查看状态：$ git status 或者 $git diff\n\n10. 如果没什么问题的话就进行提交到远程库： $ git push     //如果加入-f的话是强制提交。\n\n","slug":"git使用小记","updated":1423024773000,"excerpt":"<h2 id=\"前言：\">前言：</h2>\n<p>我们写代码写完后总要进行管理，以前写的很多代码虽然写的不是很好，但因为没有一个比较好的代码管理习惯，所以很多都遗失掉了，为此现在都还觉得很可惜，近来在学习使用git来进行代码管理，git是一个很强大的分布式版本控制系统。</p>\n<p><img src=\"/image/git流程.png\" alt=\"git\"></p>\n<h2 id=\"git工作流程\">git工作流程</h2>\n<p>了解git，首先要弄清楚对象在被git管理过程中所处的4个阶段，分别是：工作目录、index(又称为暂存区)、本地仓库和远程仓库。","_id":"socbgx7zyq5msdh5","comments":true,"layout":"post","photos":[],"link":""},{"title":"java垃圾回收机制","date":1426423500000,"categories":["ul6daxntcjqe0xkn"],"tags":["yzou6ohxuwbhfjes","o0v31j4s662upxe2","hwhqb4elsoskerku"],"desctiption":"java来及回收机制与内存管理","content":"<h2 id=\"简介\">简介</h2>\n<p>垃圾回收机制主要完成下面两件事情。</p>\n<ul>\n<li>跟踪并监控每个java对象，当某个对象处于不可达状态是，回收所占用内存</li>\n<li>清理内存分配，回收过程中产生的内存碎片</li>\n</ul>\n<p><a id=\"more\"></a><br>垃圾回收机制需要完成以上两个工作，所以工作量不算太小，因此垃圾回收算法成为限制java程序运行效率的重要因素。一个高效的垃圾回收机制既能保证垃圾回收的快速运行，避免内存的分配回收成为性能瓶颈以及导致应用程序产生停顿。</p>\n<h2 id=\"垃圾回收器的基本算法\">垃圾回收器的基本算法</h2>\n<h3 id=\"可供选择的设计\">可供选择的设计</h3>\n<ul>\n<li><strong><em>串行(Serial)回收和并向(Parallel)回收</em></strong>：串行回收就是不管有多少个CPU，都只用一个CPU来执行垃圾回收操作，而并行回收就是吧整个工作拆分给多个CPU进行回收。效率高但是复杂度增加，另有一些副作用入内存碎片增加。</li>\n<li><strong><em>并发执行(Concurrent)和应用程序停止(Stop-the-world)</em></strong>：(S)这种方式在回收时会导致应用程序暂停。并发执行的垃圾回收虽然不会导致应用程序暂停，但是由于并发执行垃圾回收需要解决和应用程序的执行冲突，因此并发执行的开销要高并且也需要更多的堆内存。</li>\n<li><strong><em>压缩(Compacting)/不压缩(Non-compacting)和复制(Copying)</em></strong>：为了减少内存碎片，支持压缩的垃圾回收器会吧所有的活的对象搬到一起，然后将之前占用的内存全部回收，不要锁的垃圾回收器只是回收内存，这样回收来的内存不可能是连续的，会有较多的内存碎片，不压缩的机制回收快但分配内存时就会慢，而且不能解决内存碎片的问题。复制垃圾回收机制会将所有可达的对象复制到另一块内存中，这种方式的优点是垃圾回收时不会产生内存碎片，缺点是需要复制数据和额外的内存。</li>\n</ul>\n<h3 id=\"具体的回收方式\">具体的回收方式</h3>\n<ul>\n<li><strong><em>复制</em></strong>：将对内存分为两份，从根处开始遍历每个关联的可达对象，将空间A中的可达对象复制到B中，然后回收整个A。这种方式遍历空间的成本小，但是需要巨大的空间和内存</li>\n<li><strong><em>标记清除</em></strong>：也就是不压缩回收方式，垃圾回收器先从根开始访问所有的可达对象，并将它们标记为可达状态，然后遍历一次整个内存区域，对所有的没有标记为可达对象进行回收处理。这种方式无需大规模复制操作，且内存利用率高。但是需要两次遍历内存空间，遍历成本大，造成应用程序暂停的时间随着堆空间的大小线性增大。而且容易产生内存碎片。</li>\n<li><strong><em>标记压缩</em></strong>：压缩的回收方式，这种方式在上一种的基础上会另外将标记的活动对象搬迁到一起，也称为内存压缩，减少了内存碎片。</li>\n</ul>\n<h2 id=\"堆内存的分代回收\">堆内存的分代回收</h2>\n<p>可以看出上述的方式都各有利弊，现行的来及回收器采用分代的方式来采用不同的回收设计。分代的基本思路是根据对象生存的时间长短，把堆内存分为三个代：Young,Old,Permanent</p>\n<p>这种“分代回收“基于如下两个事实：</p>\n<ol>\n<li>绝大多数的对象不会被长时间引用，这些对象在其Young期间就会被回收。</li>\n<li>生存时间长的对象和短的对象之间很少存在相互引用的情况。</li>\n</ol>\n<p>上面两种情况不仅在java中如此，在其他面向对象的编程语言中也是这样。</p>\n<p>下面介绍一下三个代：</p>\n<ul>\n<li><strong><em>Young代</em></strong>: 对于Young代采用复制算法只需遍历那些处于可达状态的对象，而这些对象的数量比较少，复制成本也不大，因此能充分发挥复制算法的优点。</li>\n<li><strong><em>Old代</em></strong>: 如果Young代中的对象经过数次垃圾回收依然没有被回收掉，就会被转移到Old代，Old代的空间比Young代的空间更大。</li>\n<li><strong><em>Permanent代</em></strong>: Permanent代主要用于装载Class，方法等信息，默认为64M，垃圾回收器通常不会回收这里面的对象。</li>\n</ul>\n<h2 id=\"常见的垃圾回收器\">常见的垃圾回收器</h2>\n<p>这里列举一些常见的垃圾回收器，考虑到篇幅就只列一下名字好了。</p>\n<ul>\n<li><strong><em>串行回收器(Serial Collector)</em></strong></li>\n<li><strong><em>并行回收器(Parallel Collector)</em></strong></li>\n<li><strong><em>并行压缩回收器(Parallel Compacting Collector)</em></strong></li>\n<li><strong><em>并发标识-清理(Mark-Sweep)回收器(CMS)</em></strong></li>\n</ul>\n<h2 id=\"内存管理小技巧\">内存管理小技巧</h2>\n<p>更好的管理java虚拟机的内存才能提高java程序的运行性能。下面列出一些小技巧：</p>\n<ul>\n<li><strong><em>尽量使用直接量</em></strong>  ：当需要使用基本类型的数据时，不应该采用new的方式来创建对象，而应该用直接量来创建，如String str = ”test“,这样的话JVM会将这个字符串放在缓冲池中，如果用new的话不仅会放在缓冲池中还会在堆内存中开辟一个数组来保存它。</li>\n<li><strong><em>使用StirngBuilder和StringBuffer进行字符串连接</em></strong>  : 这个的话就是减少运行时生成的临时变量。</li>\n<li><strong><em>尽早释放无用的对象的引用</em></strong>  ： 大部分时候方法的局部变量是不需要手动去设置为null的，但是在一些方法后还要运行耗时操作时可能就需要手动去释放了。</li>\n<li><strong><em>尽量少的使用静态变量</em></strong>  ： 静态变量很有肯能会存入Permanent代，可能会使垃圾回收器不能回收此对象。</li>\n<li><strong><em>避免在经常调用的方法，循环中创建java对象</em></strong>  ：可能会导致不断地分配内存空间导致程序的性能受到影响。</li>\n<li><strong><em>缓存经常使用的对象</em></strong>  ：比如缓存一些数据库连接啊之类的。</li>\n<li><strong><em>尽量不要使用finalize方法</em></strong>  ：这样会家中垃圾回收器的负担，造成程序暂停之类的。</li>\n<li><strong><em>考虑使用SoftReference</em></strong> ：当内存足够时，它的功能等同与普通引用，当内存不够时，他会牺牲自己，释放引用所引用的对象。</li>\n</ul>\n","source":"_posts/java垃圾回收机制.md","raw":"title: java垃圾回收机制\ndate: 2015-03-15 20:45:00\ncategories: java\ntags: [java,垃圾回收,内存管理]\ndesctiption: java来及回收机制与内存管理\n\n---\n\n##简介\n垃圾回收机制主要完成下面两件事情。\n\n- 跟踪并监控每个java对象，当某个对象处于不可达状态是，回收所占用内存\n- 清理内存分配，回收过程中产生的内存碎片\n\n\n<!--more -->\n垃圾回收机制需要完成以上两个工作，所以工作量不算太小，因此垃圾回收算法成为限制java程序运行效率的重要因素。一个高效的垃圾回收机制既能保证垃圾回收的快速运行，避免内存的分配回收成为性能瓶颈以及导致应用程序产生停顿。\n\n\n##垃圾回收器的基本算法\n\n###可供选择的设计\n- ***串行(Serial)回收和并向(Parallel)回收***：串行回收就是不管有多少个CPU，都只用一个CPU来执行垃圾回收操作，而并行回收就是吧整个工作拆分给多个CPU进行回收。效率高但是复杂度增加，另有一些副作用入内存碎片增加。\n- ***并发执行(Concurrent)和应用程序停止(Stop-the-world)***：(S)这种方式在回收时会导致应用程序暂停。并发执行的垃圾回收虽然不会导致应用程序暂停，但是由于并发执行垃圾回收需要解决和应用程序的执行冲突，因此并发执行的开销要高并且也需要更多的堆内存。\n- ***压缩(Compacting)/不压缩(Non-compacting)和复制(Copying)***：为了减少内存碎片，支持压缩的垃圾回收器会吧所有的活的对象搬到一起，然后将之前占用的内存全部回收，不要锁的垃圾回收器只是回收内存，这样回收来的内存不可能是连续的，会有较多的内存碎片，不压缩的机制回收快但分配内存时就会慢，而且不能解决内存碎片的问题。复制垃圾回收机制会将所有可达的对象复制到另一块内存中，这种方式的优点是垃圾回收时不会产生内存碎片，缺点是需要复制数据和额外的内存。\n\n###具体的回收方式\n\n- ***复制***：将对内存分为两份，从根处开始遍历每个关联的可达对象，将空间A中的可达对象复制到B中，然后回收整个A。这种方式遍历空间的成本小，但是需要巨大的空间和内存\n- ***标记清除***：也就是不压缩回收方式，垃圾回收器先从根开始访问所有的可达对象，并将它们标记为可达状态，然后遍历一次整个内存区域，对所有的没有标记为可达对象进行回收处理。这种方式无需大规模复制操作，且内存利用率高。但是需要两次遍历内存空间，遍历成本大，造成应用程序暂停的时间随着堆空间的大小线性增大。而且容易产生内存碎片。\n- ***标记压缩***：压缩的回收方式，这种方式在上一种的基础上会另外将标记的活动对象搬迁到一起，也称为内存压缩，减少了内存碎片。\n\n##堆内存的分代回收\n可以看出上述的方式都各有利弊，现行的来及回收器采用分代的方式来采用不同的回收设计。分代的基本思路是根据对象生存的时间长短，把堆内存分为三个代：Young,Old,Permanent\n\n这种“分代回收“基于如下两个事实：\n\n1. 绝大多数的对象不会被长时间引用，这些对象在其Young期间就会被回收。\n2. 生存时间长的对象和短的对象之间很少存在相互引用的情况。\n\n上面两种情况不仅在java中如此，在其他面向对象的编程语言中也是这样。\n\n下面介绍一下三个代：\n\n- ***Young代***: 对于Young代采用复制算法只需遍历那些处于可达状态的对象，而这些对象的数量比较少，复制成本也不大，因此能充分发挥复制算法的优点。\n- ***Old代***: 如果Young代中的对象经过数次垃圾回收依然没有被回收掉，就会被转移到Old代，Old代的空间比Young代的空间更大。\n- ***Permanent代***: Permanent代主要用于装载Class，方法等信息，默认为64M，垃圾回收器通常不会回收这里面的对象。\n\n\n##常见的垃圾回收器\n这里列举一些常见的垃圾回收器，考虑到篇幅就只列一下名字好了。\n\n- ***串行回收器(Serial Collector)***\n- ***并行回收器(Parallel Collector)***\n- ***并行压缩回收器(Parallel Compacting Collector)***\n- ***并发标识-清理(Mark-Sweep)回收器(CMS)***\n\n\n##内存管理小技巧\n更好的管理java虚拟机的内存才能提高java程序的运行性能。下面列出一些小技巧：\n\n- ***尽量使用直接量***  ：当需要使用基本类型的数据时，不应该采用new的方式来创建对象，而应该用直接量来创建，如String str = ”test“,这样的话JVM会将这个字符串放在缓冲池中，如果用new的话不仅会放在缓冲池中还会在堆内存中开辟一个数组来保存它。\n- ***使用StirngBuilder和StringBuffer进行字符串连接***  : 这个的话就是减少运行时生成的临时变量。\n- ***尽早释放无用的对象的引用***  ： 大部分时候方法的局部变量是不需要手动去设置为null的，但是在一些方法后还要运行耗时操作时可能就需要手动去释放了。\n- ***尽量少的使用静态变量***  ： 静态变量很有肯能会存入Permanent代，可能会使垃圾回收器不能回收此对象。\n- ***避免在经常调用的方法，循环中创建java对象***  ：可能会导致不断地分配内存空间导致程序的性能受到影响。\n- ***缓存经常使用的对象***  ：比如缓存一些数据库连接啊之类的。\n- ***尽量不要使用finalize方法***  ：这样会家中垃圾回收器的负担，造成程序暂停之类的。\n- ***考虑使用SoftReference*** ：当内存足够时，它的功能等同与普通引用，当内存不够时，他会牺牲自己，释放引用所引用的对象。\n","slug":"java垃圾回收机制","updated":1426427491000,"excerpt":"<h2 id=\"简介\">简介</h2>\n<p>垃圾回收机制主要完成下面两件事情。</p>\n<ul>\n<li>跟踪并监控每个java对象，当某个对象处于不可达状态是，回收所占用内存</li>\n<li>清理内存分配，回收过程中产生的内存碎片</li>\n</ul>\n<p>","_id":"08s984skupwf687w","comments":true,"layout":"post","photos":[],"link":""},{"title":"java自制线程池","date":1414338960000,"categories":["ul6daxntcjqe0xkn"],"tags":["yzou6ohxuwbhfjes","4j3aiolvlxo6aorc","23ole3glifkru081","v84gnje2wesl3tnm","ba7y88r56j7guybp"],"desctiption":"介绍了JDK自带的常用线程池以及自己动手写一个java线程池","content":"<h1 id=\"简介\">简介</h1>\n<h2 id=\"线程池\">线程池</h2>\n<p>线程池的基本思想是一种对象池的思想，先开辟一块内存空间，开许多等待任务的线程，一旦有任务出现就直接使用线程池中的线程来进行任务，等到任务结束后再将这个线程放入线程池中，池中的执行调度由线程池管理器来管理。</p>\n<h2 id=\"线程池作用\">线程池作用</h2>\n<p>线程池的作用就是更好的对系统中的线程进行管理，根据系统的环境，可以自动或者手动的设置线程数量，达到运行的最佳效果。</p>\n<p><a id=\"more\"></a></p>\n<h2 id=\"线程池优点\">线程池优点</h2>\n<p>相对于不使用线程池来说，使用线程池有什么优点呢？</p>\n<ol>\n<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，用完以后可以再用。</li>\n<li>可以根据系统的能力，自由的控制线程池的大小，防止在没有使用线程池的且对线程没有进行很好的管理的条件下服务器消耗过多的内存而宕机</li>\n</ol>\n<h2 id=\"JDK自带线程池\">JDK自带线程池</h2>\n<p>自从JDK1.5之后加入java.util.concurrent包后，线程池得到了极大的优化，现在只要按照提供的API来使用，我们就可以非常容易的使用JDK自带的线程池，为我们在写自己的程序时提供了极大的方便。</p>\n<p>ThreadPoolExecutor<br>先来看看ThreadPoolExecutor的完整构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ThreadPoolExecutor(<span class=\"keyword\">int</span> corePoolSize, <span class=\"keyword\">int</span> maximumPoolSize, <span class=\"keyword\">long</span> keepAliveTime, </div><div class=\"line\">        TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,</div><div class=\"line\">        ThreadFactory threadFactory, RejectedExecutionHandler handler)</div></pre></td></tr></table></figure>\n\n<p>对于里面的参数含义如下：</p>\n<p><strong>corePoolSize - 池中所保存的线程数，包括空闲线程。</strong><br><strong>maximumPoolSize - 池中允许的最大线程数。</strong><br><strong>keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</strong><br><strong>unit - keepAliveTime 参数的时间单位。</strong><br><strong>workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。</strong><br><strong>threadFactory - 执行程序创建新线程时使用的工厂。</strong><br><strong>handler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。</strong></p>\n<p><strong>下面介绍一些常用的线程池：</strong></p>\n<ul>\n<li><strong>newSingleThreadExecutor</strong>：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 </li>\n</ul>\n<p><strong>对应的构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span>() {  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService  </div><div class=\"line\">        (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,  </div><div class=\"line\">                                <span class=\"number\">0</span>L, TimeUnit.MILLISECONDS,  </div><div class=\"line\">                                <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));  </div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n\n\n<p><strong>使用方法示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个单线程的线程池</span></div><div class=\"line\">ExecutorService pool = Executors.newSingleThreadExecutor();</div><div class=\"line\"><span class=\"comment\">//创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口</span></div><div class=\"line\">Thread t1 = <span class=\"keyword\">new</span> MyThread();</div><div class=\"line\"><span class=\"comment\">//将线程放入池中进行执行</span></div><div class=\"line\">pool.execute(t1);</div><div class=\"line\"><span class=\"comment\">//关闭线程池</span></div><div class=\"line\">pool.shutdown();</div></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>newFixedThreadPool</strong>：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 </li>\n</ul>\n<p><strong>对应的构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span>(<span class=\"keyword\">int</span> nThreads) {  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,  </div><div class=\"line\">                                  <span class=\"number\">0</span>L, TimeUnit.MILLISECONDS,  </div><div class=\"line\">                                  <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());  </div><div class=\"line\">    }</div></pre></td></tr></table></figure>\n\n<p><strong>使用方法示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个可重用固定线程数的线程池</span></div><div class=\"line\">ExecutorService pool = Executors.newFixedThreadPool(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"comment\">//创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口</span></div><div class=\"line\">Thread t1 = <span class=\"keyword\">new</span> MyThread();</div><div class=\"line\"><span class=\"comment\">//将线程放入池中进行执行</span></div><div class=\"line\">pool.execute(t1);</div><div class=\"line\"><span class=\"comment\">//关闭线程池</span></div><div class=\"line\">pool.shutdown();</div></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>newCachedThreadPool</strong>：创建一个可缓存的无界线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>\n</ul>\n<p><strong>对应的构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span>() {  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,  </div><div class=\"line\">                                      <span class=\"number\">60</span>L, TimeUnit.SECONDS,  </div><div class=\"line\">                                      <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());  </div><div class=\"line\">    }</div></pre></td></tr></table></figure>\n\n\n<p><strong>使用方法示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们</span></div><div class=\"line\">ExecutorService pool = Executors.newCachedThreadPool(); </div><div class=\"line\"><span class=\"comment\">//创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口</span></div><div class=\"line\">Thread t1 = <span class=\"keyword\">new</span> MyThread();</div><div class=\"line\"><span class=\"comment\">//将线程放入池中进行执行</span></div><div class=\"line\">pool.execute(t1);</div><div class=\"line\"><span class=\"comment\">//关闭线程池</span></div><div class=\"line\">pool.shutdown();</div></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>newScheduledThreadPool</strong>：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>\n</ul>\n<p><strong>使用方法示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">////创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。 </span></div><div class=\"line\">ExecutorService pool = Executors.newScheduledThreadPool(<span class=\"number\">2</span>);  </div><div class=\"line\"><span class=\"comment\">//创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口</span></div><div class=\"line\">Thread t1 = <span class=\"keyword\">new</span> MyThread();</div><div class=\"line\">Thread t2 = <span class=\"keyword\">new</span> MyThread();</div><div class=\"line\"><span class=\"comment\">//将线程放入池中进行执行</span></div><div class=\"line\">pool.execute(t1);</div><div class=\"line\"><span class=\"comment\">//使用延迟执行风格的方法</span></div><div class=\"line\">pool.schedule(t2, <span class=\"number\">10</span>, TimeUnit.MILLISECONDS); </div><div class=\"line\"><span class=\"comment\">//关闭线程池</span></div><div class=\"line\">pool.shutdown();</div></pre></td></tr></table></figure>\n\n<h1 id=\"自制线程池\">自制线程池</h1>\n<p>现在让我们来自己动手写一个线程池。这只是一个简单的线程池，有助于我们更好的了解线程池的原理。</p>\n<h2 id=\"线程池主体类\">线程池主体类</h2>\n<p><strong>MyThread.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</div><div class=\"line\"></div><div class=\"line\"><span class=\"javadoc\">/**</span></div><div class=\"line\"> * </div><div class=\"line\"> *<span class=\"javadoctag\"> @author</span> zlk</div><div class=\"line\"> *    线程池，继承ThreadGroup，ThreadGroup用于处理一组线程的类，它是一种树状结构，它的下层节点还是可以是ThreadGroup对象</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadPool</span> <span class=\"keyword\">extends</span> <span class=\"title\">ThreadGroup</span></span>{</div><div class=\"line\"></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isAlive;<span class=\"comment\">//标志线程池是否开启</span></div><div class=\"line\">    <span class=\"keyword\">private</span> LinkedList taskQueue;<span class=\"comment\">//线程池中的任务队列</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threadID;<span class=\"comment\">//线程池中的线程ID</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> threadPoolID;<span class=\"comment\">//线程池ID</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"javadoc\">/**</span></div><div class=\"line\">     * 创建新的线程池，numThreads是池中的线程数</div><div class=\"line\">     *<span class=\"javadoctag\"> @param</span> numThreads</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title\">MyThreadPool</span>(<span class=\"keyword\">int</span> numThreads) {</div><div class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">\"ThreadPool-\"</span>+(threadPoolID++));</div><div class=\"line\">        <span class=\"comment\">//设置该线程池是daemon属性为true，表示当该线程池中所有的线程都被销毁时，该线程池会被自动销毁。</span></div><div class=\"line\">        <span class=\"keyword\">super</span>.setDaemon(<span class=\"keyword\">true</span>);</div><div class=\"line\">        <span class=\"keyword\">this</span>.isAlive = <span class=\"keyword\">true</span>;</div><div class=\"line\">        <span class=\"comment\">//新建一个任务队列</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.taskQueue = <span class=\"keyword\">new</span> LinkedList();</div><div class=\"line\">        <span class=\"comment\">//启动numThreads个工作线程</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numThreads; i++) {</div><div class=\"line\">            <span class=\"keyword\">new</span> PooledThread().start();</div><div class=\"line\">        }</div><div class=\"line\">    }</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"javadoc\">/**</span></div><div class=\"line\">     * 添加新任务</div><div class=\"line\">     *<span class=\"javadoctag\"> @param</span> task</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">performTask</span>(Task task)</div><div class=\"line\">    {</div><div class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.isAlive)</div><div class=\"line\">        {</div><div class=\"line\">            <span class=\"comment\">//线程池被关则抛出IllegalStateException异常</span></div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</div><div class=\"line\">        }</div><div class=\"line\">        <span class=\"keyword\">if</span> (task != <span class=\"keyword\">null</span>) {</div><div class=\"line\">            <span class=\"comment\">//将任务放到任务队列的尾部</span></div><div class=\"line\">            <span class=\"keyword\">this</span>.taskQueue.add(task);</div><div class=\"line\">            <span class=\"comment\">//通知工作线程取任务</span></div><div class=\"line\">            notify();</div><div class=\"line\">        }</div><div class=\"line\">    }</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"javadoc\">/**</span></div><div class=\"line\">     * 获取任务</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> Task <span class=\"title\">getTask</span>()<span class=\"keyword\">throws</span> InterruptedException {</div><div class=\"line\">        <span class=\"comment\">//如果任务列表为空，而且线程池没有被关闭,则继续等待任务</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>.taskQueue.size() == <span class=\"number\">0</span>) {</div><div class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.isAlive) {</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">            }</div><div class=\"line\">            wait();</div><div class=\"line\">        }</div><div class=\"line\">        <span class=\"comment\">//取任务列表中的第一个任务</span></div><div class=\"line\">        <span class=\"keyword\">return</span> (Task)<span class=\"keyword\">this</span>.taskQueue.removeFirst();</div><div class=\"line\">    }</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"javadoc\">/**</span></div><div class=\"line\">     * 关闭线程池，所有线程停止，不再执行任务</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">forceclose</span>()</div><div class=\"line\">    {</div><div class=\"line\">        <span class=\"keyword\">if</span> (isAlive) {</div><div class=\"line\">            <span class=\"keyword\">this</span>.isAlive = <span class=\"keyword\">false</span>;</div><div class=\"line\">            <span class=\"comment\">//清除任务</span></div><div class=\"line\">            <span class=\"keyword\">this</span>.taskQueue.clear();</div><div class=\"line\">            <span class=\"comment\">//终止线程池中的所有线程</span></div><div class=\"line\">            <span class=\"keyword\">this</span>.interrupt();</div><div class=\"line\">        }</div><div class=\"line\">    }</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"javadoc\">/**</span></div><div class=\"line\">     * 关闭线程池，并且等待线程池中的所有任务被运行完毕，但是不能接受新的任务</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span>(){</div><div class=\"line\">        <span class=\"comment\">//通知其他等待线程“该线程池已关闭“的消息</span></div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {</div><div class=\"line\">            isAlive = <span class=\"keyword\">false</span>;</div><div class=\"line\">            notify();</div><div class=\"line\">        }</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//等待所有线程完成</span></div><div class=\"line\">        <span class=\"comment\">//首先建立一个新的线程数组。activeCount方法获取线程池中活动线程的估计数</span></div><div class=\"line\">        Thread[] threads = <span class=\"keyword\">new</span> Thread[<span class=\"keyword\">this</span>.activeCount()];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//将线程池中的活动线程拷贝到新创建的线程数组中</span></div><div class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"keyword\">this</span>.enumerate(threads);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) {</div><div class=\"line\">            <span class=\"keyword\">try</span> {</div><div class=\"line\">                <span class=\"comment\">//等待线程运行结束</span></div><div class=\"line\">                threads[i].join();</div><div class=\"line\">            } <span class=\"keyword\">catch</span> (InterruptedException e) {</div><div class=\"line\">                e.printStackTrace();</div><div class=\"line\">            }</div><div class=\"line\">        }</div><div class=\"line\">    }</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"javadoc\">/**</span></div><div class=\"line\">     * 内部类，用于执行任务的工作线程</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PooledThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>{</div><div class=\"line\">        <span class=\"comment\">//构造方法</span></div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title\">PooledThread</span>()</div><div class=\"line\">        {</div><div class=\"line\">            <span class=\"comment\">//第一个参数为该线程所在的线程组的对象，即当前线程池的对象</span></div><div class=\"line\">            <span class=\"comment\">//第二个参数为线程名字</span></div><div class=\"line\">            <span class=\"keyword\">super</span>(MyThreadPool.<span class=\"keyword\">this</span>,<span class=\"string\">\"PooledThread-\"</span>+(threadID++));</div><div class=\"line\">        }</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>()</div><div class=\"line\">        {</div><div class=\"line\">            <span class=\"comment\">//如果线程没有被终止</span></div><div class=\"line\">            <span class=\"keyword\">while</span> (!isInterrupted()) {</div><div class=\"line\">                <span class=\"comment\">//获取任务</span></div><div class=\"line\">                Task task = <span class=\"keyword\">null</span>;</div><div class=\"line\">                <span class=\"keyword\">try</span> {</div><div class=\"line\">                    task = getTask();</div><div class=\"line\">                } <span class=\"keyword\">catch</span> (InterruptedException e) {</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                }</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"comment\">//只要线程池的任务列表不为空，getTask方法总能够得到一个任务。</span></div><div class=\"line\">                <span class=\"comment\">//若getTask()返回null，则表示线程池中已经没有任务了，而且线程池已被关闭。</span></div><div class=\"line\">                <span class=\"keyword\">if</span>(task == <span class=\"keyword\">null</span>){</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                }</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"comment\">//运行任务，吸收异常</span></div><div class=\"line\">                <span class=\"keyword\">try</span> {</div><div class=\"line\">                    task.perform();</div><div class=\"line\">                } <span class=\"keyword\">catch</span> (Throwable t) {</div><div class=\"line\">                    <span class=\"comment\">//当线程组中的线程有未被捕获的异常发生时，JVM就回去调用uncaughtException方法</span></div><div class=\"line\">                    uncaughtException(<span class=\"keyword\">this</span>, t);</div><div class=\"line\">                }</div><div class=\"line\">            }</div><div class=\"line\">        }</div><div class=\"line\">    }</div><div class=\"line\">    </div><div class=\"line\"></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<h2 id=\"任务类\">任务类</h2>\n<p><strong>Task.java</strong> //作为执行任务的总接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Task</span> </span>{</div><div class=\"line\">    <span class=\"javadoc\">/**</span></div><div class=\"line\">     * 执行任务</div><div class=\"line\">     * throws Exception 执行过程中可能出现的异常 </div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">perform</span>()<span class=\"keyword\">throws</span> Exception;</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>MyTask.java</strong> //实现了任务接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Task</span></span>{</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> taskID = <span class=\"number\">0</span>; <span class=\"comment\">//任务的ID</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title\">MyTask</span>(<span class=\"keyword\">int</span> id) {</div><div class=\"line\">        <span class=\"keyword\">this</span>.taskID = id;</div><div class=\"line\">    }</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"javadoc\">/**</span></div><div class=\"line\">     * 实现Task接口的perform方法</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"annotation\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">perform</span>() <span class=\"keyword\">throws</span> Exception {</div><div class=\"line\">        System.out.println(<span class=\"string\">\"MyTask\"</span>+ taskID + <span class=\"string\">\":start\"</span>);</div><div class=\"line\">        <span class=\"comment\">//休眠一秒</span></div><div class=\"line\">        <span class=\"keyword\">try</span> {</div><div class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">        } <span class=\"keyword\">catch</span> (Exception e) {</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        }</div><div class=\"line\">        System.out.println(<span class=\"string\">\"MyTask\"</span> + taskID + <span class=\"string\">\":end\"</span>);</div><div class=\"line\">    }</div><div class=\"line\"></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<h2 id=\"测试类\">测试类</h2>\n<p><strong>PoolTest.java</strong> //测试自制线程池</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> com.zale.threadpool.MyTask;</div><div class=\"line\"><span class=\"keyword\">import</span> com.zale.threadpool.MyThreadPool;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoolTest</span> </span>{</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(String[] args)</div><div class=\"line\">    {</div><div class=\"line\">        <span class=\"keyword\">int</span> numThreads = <span class=\"number\">3</span>; <span class=\"comment\">//线程池中的线程数</span></div><div class=\"line\">        MyThreadPool threadPool = <span class=\"keyword\">new</span> MyThreadPool(numThreads);<span class=\"comment\">//生成线程池</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">int</span> numTasks = <span class=\"number\">10</span>;  <span class=\"comment\">//任务数</span></div><div class=\"line\">        <span class=\"comment\">//运行任务</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numTasks; i++) {</div><div class=\"line\">            threadPool.performTask(<span class=\"keyword\">new</span> MyTask(i));</div><div class=\"line\">        }</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//关闭线程池并等待所有任务完成</span></div><div class=\"line\">        threadPool.shutdown();</div><div class=\"line\">    }</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n","source":"_posts/java自制线程池.md","raw":"title: java自制线程池\ndate: 2014-10-26 23:56:00\ncategories: java\ntags: [java,线程池,JDK,性能,DIY]\ndesctiption: 介绍了JDK自带的常用线程池以及自己动手写一个java线程池\n\n---\n   \n#简介\n##线程池\n线程池的基本思想是一种对象池的思想，先开辟一块内存空间，开许多等待任务的线程，一旦有任务出现就直接使用线程池中的线程来进行任务，等到任务结束后再将这个线程放入线程池中，池中的执行调度由线程池管理器来管理。\n\n##线程池作用\n线程池的作用就是更好的对系统中的线程进行管理，根据系统的环境，可以自动或者手动的设置线程数量，达到运行的最佳效果。\n\n\n<!-- more -->\n##线程池优点\n相对于不使用线程池来说，使用线程池有什么优点呢？\n\n1. 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，用完以后可以再用。\n2. 可以根据系统的能力，自由的控制线程池的大小，防止在没有使用线程池的且对线程没有进行很好的管理的条件下服务器消耗过多的内存而宕机\n\n##JDK自带线程池\n自从JDK1.5之后加入java.util.concurrent包后，线程池得到了极大的优化，现在只要按照提供的API来使用，我们就可以非常容易的使用JDK自带的线程池，为我们在写自己的程序时提供了极大的方便。\n\nThreadPoolExecutor\n先来看看ThreadPoolExecutor的完整构造方法\n```java\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n        TimeUnit unit, BlockingQueue<Runnable> workQueue,\n        ThreadFactory threadFactory, RejectedExecutionHandler handler) \n```\n对于里面的参数含义如下：\n\n**corePoolSize - 池中所保存的线程数，包括空闲线程。**\n**maximumPoolSize - 池中允许的最大线程数。**\n**keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。**\n**unit - keepAliveTime 参数的时间单位。**\n**workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。**\n**threadFactory - 执行程序创建新线程时使用的工厂。**\n**handler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。**\n    \n**下面介绍一些常用的线程池：**\n\n- **newSingleThreadExecutor**：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 \n\n**对应的构造方法**\n    ```java\n    public static ExecutorService newSingleThreadExecutor() {  \n        return new FinalizableDelegatedExecutorService  \n            (new ThreadPoolExecutor(1, 1,  \n                                    0L, TimeUnit.MILLISECONDS,  \n                                    new LinkedBlockingQueue<Runnable>()));  \n    }  \n    ```\n   \n\n**使用方法示例**\n   \n\n    ```java\n    //创建一个单线程的线程池\n    ExecutorService pool = Executors.newSingleThreadExecutor();\n    //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n    Thread t1 = new MyThread();\n    //将线程放入池中进行执行\n    pool.execute(t1);\n    //关闭线程池\n    pool.shutdown(); \n    ```\n\n- **newFixedThreadPool**：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 \n\n**对应的构造方法**\n    ```java\n    public static ExecutorService newFixedThreadPool(int nThreads) {  \n        return new ThreadPoolExecutor(nThreads, nThreads,  \n                                      0L, TimeUnit.MILLISECONDS,  \n                                      new LinkedBlockingQueue<Runnable>());  \n        }  \n    ```\n\n**使用方法示例**\n\n    ```java\n    //创建一个可重用固定线程数的线程池\n    ExecutorService pool = Executors.newFixedThreadPool(2);\n    //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n    Thread t1 = new MyThread();\n    //将线程放入池中进行执行\n    pool.execute(t1);\n    //关闭线程池\n    pool.shutdown(); \n    ```\n\n- **newCachedThreadPool**：创建一个可缓存的无界线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。\n\n**对应的构造方法**\n    ```java\n    public static ExecutorService newCachedThreadPool() {  \n            return new ThreadPoolExecutor(0, Integer.MAX_VALUE,  \n                                          60L, TimeUnit.SECONDS,  \n                                          new SynchronousQueue<Runnable>());  \n        }  \n    ```\n    \n**使用方法示例**\n\n    ```java\n    //创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们\n    ExecutorService pool = Executors.newCachedThreadPool(); \n    //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n    Thread t1 = new MyThread();\n    //将线程放入池中进行执行\n    pool.execute(t1);\n    //关闭线程池\n    pool.shutdown(); \n    ```\n\n- **newScheduledThreadPool**：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n**使用方法示例**\n\n    ```java\n    ////创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。 \n    ExecutorService pool = Executors.newScheduledThreadPool(2);  \n    //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n    Thread t1 = new MyThread();\n    Thread t2 = new MyThread();\n    //将线程放入池中进行执行\n    pool.execute(t1);\n    //使用延迟执行风格的方法\n    pool.schedule(t2, 10, TimeUnit.MILLISECONDS); \n    //关闭线程池\n    pool.shutdown(); \n    ```\n\n#自制线程池\n现在让我们来自己动手写一个线程池。这只是一个简单的线程池，有助于我们更好的了解线程池的原理。\n##线程池主体类\n**MyThread.java**\n```java\nimport java.util.LinkedList;\n\n/**\n * \n * @author zlk\n *    线程池，继承ThreadGroup，ThreadGroup用于处理一组线程的类，它是一种树状结构，它的下层节点还是可以是ThreadGroup对象\n */\npublic class MyThreadPool extends ThreadGroup{\n\n    \n    private boolean isAlive;//标志线程池是否开启\n    private LinkedList taskQueue;//线程池中的任务队列\n    private int threadID;//线程池中的线程ID\n    private static int threadPoolID;//线程池ID\n    \n    /**\n     * 创建新的线程池，numThreads是池中的线程数\n     * @param numThreads\n     */\n    public MyThreadPool(int numThreads) {\n        super(\"ThreadPool-\"+(threadPoolID++));\n        //设置该线程池是daemon属性为true，表示当该线程池中所有的线程都被销毁时，该线程池会被自动销毁。\n        super.setDaemon(true);\n        this.isAlive = true;\n        //新建一个任务队列\n        this.taskQueue = new LinkedList();\n        //启动numThreads个工作线程\n        for (int i = 0; i < numThreads; i++) {\n            new PooledThread().start();\n        }\n    }\n    \n    /**\n     * 添加新任务\n     * @param task\n     */\n    public synchronized void performTask(Task task)\n    {\n        if(!this.isAlive)\n        {\n            //线程池被关则抛出IllegalStateException异常\n            throw new IllegalStateException();\n        }\n        if (task != null) {\n            //将任务放到任务队列的尾部\n            this.taskQueue.add(task);\n            //通知工作线程取任务\n            notify();\n        }\n    }\n    \n    /**\n     * 获取任务\n     */\n    protected synchronized Task getTask()throws InterruptedException {\n        //如果任务列表为空，而且线程池没有被关闭,则继续等待任务\n        while (this.taskQueue.size() == 0) {\n            if (!this.isAlive) {\n                return null;\n            }\n            wait();\n        }\n        //取任务列表中的第一个任务\n        return (Task)this.taskQueue.removeFirst();\n    }\n    \n    /**\n     * 关闭线程池，所有线程停止，不再执行任务\n     */\n    \n    public synchronized void forceclose()\n    {\n        if (isAlive) {\n            this.isAlive = false;\n            //清除任务\n            this.taskQueue.clear();\n            //终止线程池中的所有线程\n            this.interrupt();\n        }\n    }\n    \n    /**\n     * 关闭线程池，并且等待线程池中的所有任务被运行完毕，但是不能接受新的任务\n     */\n    \n    public void shutdown(){\n        //通知其他等待线程“该线程池已关闭“的消息\n        synchronized (this) {\n            isAlive = false;\n            notify();\n        }\n        \n        //等待所有线程完成\n        //首先建立一个新的线程数组。activeCount方法获取线程池中活动线程的估计数\n        Thread[] threads = new Thread[this.activeCount()];\n        \n        //将线程池中的活动线程拷贝到新创建的线程数组中\n        int count = this.enumerate(threads);\n        for (int i = 0; i < count; i++) {\n            try {\n                //等待线程运行结束\n                threads[i].join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    /**\n     * 内部类，用于执行任务的工作线程\n     */\n    private class PooledThread extends Thread{\n        //构造方法\n        public PooledThread()\n        {\n            //第一个参数为该线程所在的线程组的对象，即当前线程池的对象\n            //第二个参数为线程名字\n            super(MyThreadPool.this,\"PooledThread-\"+(threadID++));\n        }\n        \n        public void run()\n        {\n            //如果线程没有被终止\n            while (!isInterrupted()) {\n                //获取任务\n                Task task = null;\n                try {\n                    task = getTask();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                \n                //只要线程池的任务列表不为空，getTask方法总能够得到一个任务。\n                //若getTask()返回null，则表示线程池中已经没有任务了，而且线程池已被关闭。\n                if(task == null){\n                    return;\n                }\n                \n                //运行任务，吸收异常\n                try {\n                    task.perform();\n                } catch (Throwable t) {\n                    //当线程组中的线程有未被捕获的异常发生时，JVM就回去调用uncaughtException方法\n                    uncaughtException(this, t);\n                }\n            }\n        }\n    }\n    \n\n}\n```\n##任务类\n**Task.java** //作为执行任务的总接口\n```java\npublic interface Task {\n    /**\n     * 执行任务\n     * throws Exception 执行过程中可能出现的异常 \n     */\n    public void  perform()throws Exception;\n}\n```\n\n**MyTask.java** //实现了任务接口\n```java\npublic class MyTask implements Task{\n\n    private int taskID = 0; //任务的ID\n    \n    public MyTask(int id) {\n        this.taskID = id;\n    }\n    \n    /**\n     * 实现Task接口的perform方法\n     */\n    @Override\n    public void perform() throws Exception {\n        System.out.println(\"MyTask\"+ taskID + \":start\");\n        //休眠一秒\n        try {\n            Thread.sleep(1000);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"MyTask\" + taskID + \":end\");\n    }\n\n}\n```\n\n##测试类\n**PoolTest.java** //测试自制线程池\n```java\nimport com.zale.threadpool.MyTask;\nimport com.zale.threadpool.MyThreadPool;\n\npublic class PoolTest {\n    \n    public static void main(String[] args)\n    {\n        int numThreads = 3; //线程池中的线程数\n        MyThreadPool threadPool = new MyThreadPool(numThreads);//生成线程池\n        \n        int numTasks = 10;  //任务数\n        //运行任务\n        for (int i = 0; i < numTasks; i++) {\n            threadPool.performTask(new MyTask(i));\n        }\n        \n        //关闭线程池并等待所有任务完成\n        threadPool.shutdown();\n    }\n}\n\n```","slug":"java自制线程池","updated":1414340326000,"excerpt":"<h1 id=\"简介\">简介</h1>\n<h2 id=\"线程池\">线程池</h2>\n<p>线程池的基本思想是一种对象池的思想，先开辟一块内存空间，开许多等待任务的线程，一旦有任务出现就直接使用线程池中的线程来进行任务，等到任务结束后再将这个线程放入线程池中，池中的执行调度由线程池管理器来管理。</p>\n<h2 id=\"线程池作用\">线程池作用</h2>\n<p>线程池的作用就是更好的对系统中的线程进行管理，根据系统的环境，可以自动或者手动的设置线程数量，达到运行的最佳效果。</p>\n<p>","_id":"8ybnrk1eedp9pvlg","comments":true,"layout":"post","photos":[],"link":""},{"title":"linux翻墙攻略","date":1410191040000,"categories":["klheiemw6tkdcymi"],"tags":["9f9y6vaw8hxic410","u7clg3k5aw2o5rtt","9tdtm2q014xhqy6l","4qnntf6fxvp34rx6"],"desctiption":"翻墙攻略","content":"<p><img src=\"/image/google.png\" alt=\"google\"></p>\n<h2 id=\"前言\">前言</h2>\n<p>如今，我们中国网民的眼界基本已经被<strong><a href=\"http://baike.baidu.com/link?url=JuSDS8C5xp-kz0sSEBBQ8-l6eNMu4-evhNaNB90e9n65oAtGC8dwQnhHw2KCJ8Gk5Nn9J6E1R1XtnpIxH4bdtnDyaCXFYN8wMvrEfKrsnra\" target=\"_blank\" rel=\"external\">GFW</a></strong>所成功禁锢，但是无论有多么强大的GFW或者金盾，即使被关在果壳之中，中国的网络还是以它自己的方式适应种种压力顽强地发展。而想要冲破那枷锁，在浩瀚的网络海洋中自由翱翔，就需要我们去进行<a href=\"http://baike.baidu.com/subview/883663/9171160.htm?fr=aladdin\" target=\"_blank\" rel=\"external\"><strong>翻墙</strong></a>。<br><a id=\"more\"></a></p>\n<h2 id=\"翻墙起由\">翻墙起由</h2>\n<p>虽说GFW确实很强大，但是它也屏蔽了很多并没有危害性内容的健康网站，例如我们最熟悉的<strong>Google</strong>,我认为谷歌可以说是最强大的搜索引擎了，其搜索的准确度是百度之类所不能比的，尤其是在搜索一些国外的先进技术时其优劣一用就知道了，还记得在去年google搜索引擎还能正常使用，现在在浏览器中已经打不开谷歌的网址了，很多谷歌的服务都不能用了，于是就不得不去翻墙了。</p>\n<h2 id=\"翻墙途径\">翻墙途径</h2>\n<p>要说翻墙的途径的话有很多，有很多翻墙软件可已下载，比如说：   </p>\n<blockquote>\n<p>—-更新于2014年12月29日<br><strong>最新方法推荐，linux下直接更改/etc/hosts文件中的设置，将一大段Ip地址复制进来，根本不用其他复杂的设置就能完成轻松翻墙！！强烈推荐！！可以无视下面方法了！！</strong></p>\n</blockquote>\n<ul>\n<li>免费翻墙软件<strong><a href=\"https://s3.amazonaws.com/fqtools/index.html\" target=\"_blank\" rel=\"external\">墙内下载</a></strong>，支持各平台。</li>\n<li><a href=\"https://developers.google.com/appengine/\" target=\"_blank\" rel=\"external\">GAE</a>（Google App Engine） 包括：<a href=\"https://code.google.com/p/goagent/\" target=\"_blank\" rel=\"external\">GoAgent</a> ，是使用跨平台语言Python 开发的代理软件，利用GAE的服务器充当代理，帮助用户浏览被封锁的内容。</li>\n<li><a href=\"http://www.vpngate.net/cn/\" target=\"_blank\" rel=\"external\">VPN Gate</a>  由全世界志愿者提供的公共 VPN 服务器获得自由访问互联网</li>\n<li><a href=\"dongtaiwang.com\">动态网</a> （<a href=\"dongtaiwang.com/loc/download.php\">自由门下载</a> 有安卓版）调查显示最多人使用这个翻墙软件，建议和其他软件一并使用防止失效，注意更新。</li>\n<li><a href=\"www.wujieliulan.com\">无界浏览</a> （<a href=\"www.wujieliulan.com/download.php\">下载</a>  有安卓版，在首页右上角） 目前仍有较多人使用的翻墙软件，建议和其他软件一并使用防止失效，注意更新。</li>\n</ul>\n<p>除此以外还有很多中方法此处不一一细说。但是虽然知道有这些方法，但是这些网址大部分都是已经被墙了，连网址都访问不了，更别说下载工具了。不急，待到下边慢慢说来。</p>\n<h2 id=\"我的翻墙之路\">我的翻墙之路</h2>\n<p>我采用的是上述的第2中也就是利用了goagent这个工具来进行翻墙的。以前在windows中使用过，windows中使用这个工具相对来说还是比较方便的，网上教程已经很详备了，现在我要在linux下来使用这个工具，其实大体的流程是差不多的。</p>\n<p>首先我们需要准备好以下几个工具：   </p>\n<ol>\n<li>火狐浏览器firefox的插件AutoProxy，这里我使用的浏览器是火狐，可在附加组件下载到插件。</li>\n<li>goagent软件，因为是通用版，都可用，网上很多地方都可以下。</li>\n<li>python的环境，如果没有的话<strong>apt-get install python</strong>一下应该就可以跳出相关提示了。</li>\n<li>一个谷歌的AppID。获取方法下面会讲到。</li>\n</ol>\n<p>然后就开始具体实现步骤了。   </p>\n<ol>\n<li>首先，去<a href=\"http://appengine.google.com\" target=\"_blank\" rel=\"external\">http://appengine.google.com</a> 这个网址去注册谷歌的AppID，这里一开始就遇到麻烦了，因为现在的<br>封锁比较严，凡是跟**.google.com挂钩的基本都不能访问，所以这个页面也打不开，需要翻墙才能打开，于是没办法，<br>我就只能切到win7系统下，上网搜了一个VPN代理软件，里面有免费的试用账号，于是我就利用这个试用账号火速<br>注册了一个AppID，因为试用账号每10分钟短线一次，但已经够了。   </li>\n<li>进入goagent目录下的local文件夹找到并编辑proxy.ini，在[gae]的appid处填写刚才注册的application identifier，如果有多个用 | 隔开。<br><img src=\"/image/proxy.png\" alt=\"proxy.ini\">   </li>\n<li>进入goagent目录下找到server目录里面的uploader.zip，右键打开终端输入命令 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">sudo</span> python uploader.zip</div></pre></td></tr></table></figure>\n\n\n<ol>\n<li>之后就是填写gmail邮箱和密码了，按照提示填写，等待上传成功的提示上传成功后，每次使用代理前，进local目录，执行命令  </li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo <span class=\"keyword\">python</span> proxy.<span class=\"keyword\">py</span></div></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：这里面的我的python版本为2.7，如果是3以后出现错误的话可以尝试这么解决   :</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">sudo</span> python2.<span class=\"number\">7</span> proxy.xy</div></pre></td></tr></table></figure>\n\n\n<p>5.此时大功马上告成，只差最后一步最后配置firefox 插件autoproxy ，选择工具-&gt;附加组建右上角搜索autoproxy安装 autoproxy 也就是那个福，安装完成后，重启浏览器重启之后，点击右上角福字的倒三角，选择首选项点击 代理规则-&gt; 代理规则订阅之后勾选gfwList并点击订阅，设置 默认代理 为 goagent，确定那个 福 字 有三种状态  灰色-禁用代理；红色-自动模式；绿色-全局模式。（gfwlist中都是被GFW所禁止访问的网站）    </p>\n<hr>\n<p>至此，所有配置完毕，在执行了上边的 sudo python proxy.py命令 后 就可以访问youtube，facebook，google等网站啦</p>\n<h2 id=\"题外话\">题外话</h2>\n<p>一部GFW简史同时也是中国网络化简史。网络化既是技术变革，也是文化变革。网络的确是意识形态完全的敌人，因为网络多元化文化要求取消意识形态的中心地位；但意识形态不是网络的敌人，事实上网络没有敌人，因为网络只有解构对象。因此对于执政者来说，意识形态的中心地位与网络化发展趋势两者只能选择其一。实际情况是，执政者选择了前者，而把大刀挥向了Web 2.0。于是网络用它一贯调侃的风格模仿意识形态话语进行了如下讽刺：”我们对你陈旧的政权概念和意识形态烂腌菜毫不感兴趣。你无法理解在人类网络化的历史潮流之前宏大叙事为何而消解，你也无法理解国家和民族概念为何将分崩离析，你无法改变你对互联网的无知。你的政权无法成为我们真正的敌人。”其实,《2009匿名网民宣言》只是过早的预言，cyberpunk式的谜语。</p>\n<h4 id=\"参考文献\">参考文献</h4>\n<ul>\n<li>维基百科 <a href=\"http://en.wikipedia.org/wiki/Main_Page\" target=\"_blank\" rel=\"external\">http://en.wikipedia.org/wiki/Main_Page</a></li>\n<li>翻墙后看什么 <a href=\"http://fanqianghou.com\" target=\"_blank\" rel=\"external\">http://fanqianghou.com</a></li>\n</ul>\n","source":"_posts/linux翻墙攻略.md","raw":"title: linux翻墙攻略\ndate: 2014-09-08 23:44:00\ncategories: linux\ntags: [linux,goagent,GFW,翻墙]\ndesctiption: 翻墙攻略\n\n---\n![google]({{BASE_PATH}}/image/google.png)\n\n\n##前言\n如今，我们中国网民的眼界基本已经被**[GFW](http://baike.baidu.com/link?url=JuSDS8C5xp-kz0sSEBBQ8-l6eNMu4-evhNaNB90e9n65oAtGC8dwQnhHw2KCJ8Gk5Nn9J6E1R1XtnpIxH4bdtnDyaCXFYN8wMvrEfKrsnra)**所成功禁锢，但是无论有多么强大的GFW或者金盾，即使被关在果壳之中，中国的网络还是以它自己的方式适应种种压力顽强地发展。而想要冲破那枷锁，在浩瀚的网络海洋中自由翱翔，就需要我们去进行[**翻墙**](http://baike.baidu.com/subview/883663/9171160.htm?fr=aladdin)。\n<!--more-->\n\n##翻墙起由\n虽说GFW确实很强大，但是它也屏蔽了很多并没有危害性内容的健康网站，例如我们最熟悉的**Google**,我认为谷歌可以说是最强大的搜索引擎了，其搜索的准确度是百度之类所不能比的，尤其是在搜索一些国外的先进技术时其优劣一用就知道了，还记得在去年google搜索引擎还能正常使用，现在在浏览器中已经打不开谷歌的网址了，很多谷歌的服务都不能用了，于是就不得不去翻墙了。\n\n\n##翻墙途径\n要说翻墙的途径的话有很多，有很多翻墙软件可已下载，比如说：   \n\n>---更新于2014年12月29日    \n**最新方法推荐，linux下直接更改/etc/hosts文件中的设置，将一大段Ip地址复制进来，根本不用其他复杂的设置就能完成轻松翻墙！！强烈推荐！！可以无视下面方法了！！**\n\n* 免费翻墙软件**[墙内下载](https://s3.amazonaws.com/fqtools/index.html)**，支持各平台。\n* [GAE](https://developers.google.com/appengine/)（Google App Engine） 包括：[GoAgent](https://code.google.com/p/goagent/) ，是使用跨平台语言Python 开发的代理软件，利用GAE的服务器充当代理，帮助用户浏览被封锁的内容。\n* [VPN Gate](http://www.vpngate.net/cn/)  由全世界志愿者提供的公共 VPN 服务器获得自由访问互联网\n* [动态网](dongtaiwang.com) （[自由门下载](dongtaiwang.com/loc/download.php) 有安卓版）调查显示最多人使用这个翻墙软件，建议和其他软件一并使用防止失效，注意更新。\n* [无界浏览](www.wujieliulan.com) （[下载](www.wujieliulan.com/download.php)  有安卓版，在首页右上角） 目前仍有较多人使用的翻墙软件，建议和其他软件一并使用防止失效，注意更新。\n\n除此以外还有很多中方法此处不一一细说。但是虽然知道有这些方法，但是这些网址大部分都是已经被墙了，连网址都访问不了，更别说下载工具了。不急，待到下边慢慢说来。\n\n##我的翻墙之路\n我采用的是上述的第2中也就是利用了goagent这个工具来进行翻墙的。以前在windows中使用过，windows中使用这个工具相对来说还是比较方便的，网上教程已经很详备了，现在我要在linux下来使用这个工具，其实大体的流程是差不多的。\n\n首先我们需要准备好以下几个工具：   \n\n1. 火狐浏览器firefox的插件AutoProxy，这里我使用的浏览器是火狐，可在附加组件下载到插件。\n2. goagent软件，因为是通用版，都可用，网上很多地方都可以下。\n3. python的环境，如果没有的话**apt-get install python**一下应该就可以跳出相关提示了。\n4. 一个谷歌的AppID。获取方法下面会讲到。\n\n然后就开始具体实现步骤了。   \n1. 首先，去http://appengine.google.com 这个网址去注册谷歌的AppID，这里一开始就遇到麻烦了，因为现在的\n封锁比较严，凡是跟**.google.com挂钩的基本都不能访问，所以这个页面也打不开，需要翻墙才能打开，于是没办法，\n我就只能切到win7系统下，上网搜了一个VPN代理软件，里面有免费的试用账号，于是我就利用这个试用账号火速\n注册了一个AppID，因为试用账号每10分钟短线一次，但已经够了。   \n2. 进入goagent目录下的local文件夹找到并编辑proxy.ini，在[gae]的appid处填写刚才注册的application identifier，如果有多个用 | 隔开。   \n![proxy.ini]({{BASE_PATH}}/image/proxy.png)   \n3. 进入goagent目录下找到server目录里面的uploader.zip，右键打开终端输入命令 \n```shell \nsudo python uploader.zip\n```   \n4. 之后就是填写gmail邮箱和密码了，按照提示填写，等待上传成功的提示上传成功后，每次使用代理前，进local目录，执行命令  \n```shell\nsudo python proxy.py   \n```\n**注意**：这里面的我的python版本为2.7，如果是3以后出现错误的话可以尝试这么解决   :\n```shell\nsudo python2.7 proxy.xy\n```   \n5.此时大功马上告成，只差最后一步最后配置firefox 插件autoproxy ，选择工具->附加组建右上角搜索autoproxy安装 autoproxy 也就是那个福，安装完成后，重启浏览器重启之后，点击右上角福字的倒三角，选择首选项点击 代理规则-> 代理规则订阅之后勾选gfwList并点击订阅，设置 默认代理 为 goagent，确定那个 福 字 有三种状态  灰色-禁用代理；红色-自动模式；绿色-全局模式。（gfwlist中都是被GFW所禁止访问的网站）    \n\n\n---\n至此，所有配置完毕，在执行了上边的 sudo python proxy.py命令 后 就可以访问youtube，facebook，google等网站啦\n\n\n##题外话\n一部GFW简史同时也是中国网络化简史。网络化既是技术变革，也是文化变革。网络的确是意识形态完全的敌人，因为网络多元化文化要求取消意识形态的中心地位；但意识形态不是网络的敌人，事实上网络没有敌人，因为网络只有解构对象。因此对于执政者来说，意识形态的中心地位与网络化发展趋势两者只能选择其一。实际情况是，执政者选择了前者，而把大刀挥向了Web 2.0。于是网络用它一贯调侃的风格模仿意识形态话语进行了如下讽刺：\"我们对你陈旧的政权概念和意识形态烂腌菜毫不感兴趣。你无法理解在人类网络化的历史潮流之前宏大叙事为何而消解，你也无法理解国家和民族概念为何将分崩离析，你无法改变你对互联网的无知。你的政权无法成为我们真正的敌人。\"其实,《2009匿名网民宣言》只是过早的预言，cyberpunk式的谜语。\n\n\n####参考文献\n* 维基百科 http://en.wikipedia.org/wiki/Main_Page\n* 翻墙后看什么 http://fanqianghou.com\n","slug":"linux翻墙攻略","updated":1419857336000,"excerpt":"<p><img src=\"/image/google.png\" alt=\"google\"></p>\n<h2 id=\"前言\">前言</h2>\n<p>如今，我们中国网民的眼界基本已经被<strong><a href=\"http://baike.baidu.com/link?url=JuSDS8C5xp-kz0sSEBBQ8-l6eNMu4-evhNaNB90e9n65oAtGC8dwQnhHw2KCJ8Gk5Nn9J6E1R1XtnpIxH4bdtnDyaCXFYN8wMvrEfKrsnra\" target=\"_blank\" rel=\"external\">GFW</a></strong>所成功禁锢，但是无论有多么强大的GFW或者金盾，即使被关在果壳之中，中国的网络还是以它自己的方式适应种种压力顽强地发展。而想要冲破那枷锁，在浩瀚的网络海洋中自由翱翔，就需要我们去进行<a href=\"http://baike.baidu.com/subview/883663/9171160.htm?fr=aladdin\" target=\"_blank\" rel=\"external\"><strong>翻墙</strong></a>。<br>","_id":"x4dxwqu7l30yd6wo","comments":true,"layout":"post","photos":[],"link":""},{"layout":"false","title":"再见2014，你好2015","date":1420041600000,"categories":["uw37i2o0tlv7fezh"],"desctiption":"再见2014,你好2015,新的一年，改变世界，改变自己","content":"<p><a id=\"more\"></a></p>\n<html><br><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"><link href=\"http://img.chinaz.com/max-templates/passport/styles/topbar.css\" type=\"text/css\" rel=\"Stylesheet\"><link href=\"/style/style_kj.css\" type=\"text/css\" rel=\"stylesheet\"><script type=\"text/javascript\" src=\"/style/js/jquery-1.2.pack.js\"></script><script type=\"text/javascript\" src=\"/style/js/mainutf8.js\"></script><script language=\"javascript\"><br>    var iframeHeight = function () {<br>        var _height = jq(window).height() - 71;<br>        jq(‘#content’).height(_height);<br>    }<br>    window.onresize = iframeHeight;<br>    jq(function () {<br>        iframeHeight();<br>    });</script></head><br><body><div style=\"background:#2684C2; width:100%; height:100%; line-height:500px; font-size:100px; text-align:center; color:#FFFFFF\"><strong>再见2014 你好2015</strong></div><embed src=\"http://www.xiami.com/widget/41521033_1769907929,1771959082,1772692461,1771889375,143399,137794,3478385,395234,1769907904,68110,379364,2070230,228,378646,382620,1771686953,1771889373,2138604,379327,1771948940,3075078,376455,143408,3373245,53866,146898,1769902385,1769845026,143391,1773430479,1771269774,87855,76280,2067235,1770579751,87633,147045,378181,1770109081,1770155401,1770201852,1769009754,3381903,1771462656,1771783887,388176,1770700059,53885,1773565730,1771939336,_999_300_5695c1_457cb4_1/multiPlayer.swf\" type=\"application/x-shockwave-flash\" width=\"999\" height=\"300\" wmode=\"opaque\"><script type=\"text/javascript\" src=\"http://demo.sc.chinaz.com/Files/DownLoad/webjs1/201403/jiaoben2103/snow.src.js\"></script><br><br><br><br></body><br></html>\n\n\n\n","source":"_posts/newStart.md","raw":"layout: false\ntitle: 再见2014，你好2015\ndate: 2015-1-1 00:00:00\ncategories: 人生轨迹\ndesctiption:  再见2014,你好2015,新的一年，改变世界，改变自己\n---\n<!--more-->\n<html>\n<head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /><link href=\"http://img.chinaz.com/max-templates/passport/styles/topbar.css\" type=\"text/css\" rel=\"Stylesheet\" /><link href=\"/style/style_kj.css\" type=\"text/css\" rel=\"stylesheet\" /><script type=\"text/javascript\" src=\"/style/js/jquery-1.2.pack.js\"></script><script type=\"text/javascript\" src=\"/style/js/mainutf8.js\"></script><script language=\"javascript\">\n    var iframeHeight = function () {\n        var _height = jq(window).height() - 71;\n        jq('#content').height(_height);\n    }\n    window.onresize = iframeHeight;\n    jq(function () {\n        iframeHeight();\n    });</script></head>\n<body><div style=\"background:#2684C2; width:100%; height:100%; line-height:500px; font-size:100px; text-align:center; color:#FFFFFF\"><strong>再见2014 你好2015</strong></div><embed src=\"http://www.xiami.com/widget/41521033_1769907929,1771959082,1772692461,1771889375,143399,137794,3478385,395234,1769907904,68110,379364,2070230,228,378646,382620,1771686953,1771889373,2138604,379327,1771948940,3075078,376455,143408,3373245,53866,146898,1769902385,1769845026,143391,1773430479,1771269774,87855,76280,2067235,1770579751,87633,147045,378181,1770109081,1770155401,1770201852,1769009754,3381903,1771462656,1771783887,388176,1770700059,53885,1773565730,1771939336,_999_300_5695c1_457cb4_1/multiPlayer.swf\" type=\"application/x-shockwave-flash\" width=\"999\" height=\"300\" wmode=\"opaque\"></embed><script type=\"text/javascript\" src=\"http://demo.sc.chinaz.com/Files/DownLoad/webjs1/201403/jiaoben2103/snow.src.js\"></script>\n\n\n\n</body>\n</html>\n\n\n\n","slug":"newStart","updated":1420105035000,"excerpt":"<p>","_id":"nbcib5xb70bov7bk","tags":[],"comments":true,"photos":[],"link":""},{"title":"不要怪老天不公平","date":1411977300000,"categories":["uw37i2o0tlv7fezh"],"tags":["i0y36d03vky1k3b6","woo957svw5n66n1y"],"desctiption":"不要怪老天不公平,要去接受然后改变它","content":"<p><img src=\"/image/gongp1.png\" alt=\"gongp1\"></p>\n<p><strong>生活是不公平的，你要去接受，然后，改变它。</strong></p>\n<a id=\"more\"></a>\n\n<p><strong>生活不是一场辩论，在这里，没有公平的法官出席。也许，它给别人的全是玫瑰花，而给你的则是刺人的荆棘。能够理解并热爱生活的人绝不会强求生活给自己玫瑰，而是把自己手中的荆棘变成玫瑰。在这个过程中，有挣扎却没有痛苦，有呻吟却不会有眼泪。</strong></p>\n<p><strong>世界本来就是不公平的，怎么可能公平？但是有一点是公平的，比尔·盖茨一天24小时，你一天也是24小时。没有人是完美的，社会也不可能完美，因为社会由所有不完美的人组成。你的职责是比别人多勤奋一点、多努力一点、多有一点理想。人的心态决定姿态，从而决定你的生活状态，心态好一切自然会好起来的。从这个角度来说，学会如何面对不公平，远比学会如何评价不公平更重要。不公平是我们生命中的契机，是生命提供给我们，让我们自己和世界变得更加美好的机会。</strong></p>\n<p><img src=\"/image/gongp2.png\" alt=\"gongp2\"></p>\n<p><strong>如果这个世界到处都是不公平，那么你应该找到那个能让你改变的不公平，然后用你的方式去影响它们。</strong></p>\n<p><strong>抱怨不公平的根结是不愿改变自我，如果总抱怨不公平，就会被彻底淘汰。只要能重新审视自我，就能重新站起来，继续跟着社会的前进步伐。</strong></p>\n<p><img src=\"/image/gongp3.png\" alt=\"gongp3\"></p>\n<p><strong>人生就是一段从青涩逐步走向成熟的旅程。真正的成熟、厚重、坚强、自信，是从正视不公平、改善自我开始的。深处经济社会，面对各种压力，只有正视现实，调整好心态，才会找到属于自己的那份公平，把不公平甩在身后。</strong></p>\n<p><strong>个人之于人类，不过一滴血液；人类之于地球, 不过小草一棵；地球之于宇宙，不过是一点尘埃……人是这么渺小，倘心胸再窄小，将小为何物? 然而人虽渺小，心若宽阔，则能装得下整个宇宙。</strong></p>\n<p><img src=\"/image/gongp4.jpg\" alt=\"gongp4\"></p>\n<p><strong>很多时候，人们面对同一件事，主动去迎接挑战的人能获得更大的收获，我们很容易被别人左右，但是我们要知道，很多事，我们不去亲生经历而只听信他人的话，是很难真正发现自己的潜力的。大三了，很多人都不愿做班长，认为这是个苦差，很多事都要班长去做，会很烦。但是这是谁说的呢？是班长本人还是其他人呢？他们自己有没有自己亲生体验过呢？</strong></p>\n<p><strong>最后用一句话作为结尾</strong></p>\n<blockquote>\n<p><strong>成功的人做别人不愿做的事，做别人敢做的事，做别人做不到的事,私底下的每一分的努力都会在公众面前表现出来。</strong></p>\n</blockquote>\n<p><br><br><br><br><br></p>\n<embed src=\"http://www.xiami.com/widget/41521033_3410275,_235_200_FF8719_494949_1/multiPlayer.swf\" type=\"application/x-shockwave-flash\" width=\"235\" height=\"200\" wmode=\"opaque\">","source":"_posts/不要怪老天不公平.md","raw":"title: 不要怪老天不公平\ndate: 2014-09-29 15:55:00\ncategories: 人生轨迹\ntags: [不公平,心态]\ndesctiption: 不要怪老天不公平,要去接受然后改变它\n\n---\n\n\n![gongp1]({{BASE_PATH}}/image/gongp1.png)\n\n\n**生活是不公平的，你要去接受，然后，改变它。**\n\n<!--more-->\n\n**生活不是一场辩论，在这里，没有公平的法官出席。也许，它给别人的全是玫瑰花，而给你的则是刺人的荆棘。能够理解并热爱生活的人绝不会强求生活给自己玫瑰，而是把自己手中的荆棘变成玫瑰。在这个过程中，有挣扎却没有痛苦，有呻吟却不会有眼泪。**\n\n**世界本来就是不公平的，怎么可能公平？但是有一点是公平的，比尔·盖茨一天24小时，你一天也是24小时。没有人是完美的，社会也不可能完美，因为社会由所有不完美的人组成。你的职责是比别人多勤奋一点、多努力一点、多有一点理想。人的心态决定姿态，从而决定你的生活状态，心态好一切自然会好起来的。从这个角度来说，学会如何面对不公平，远比学会如何评价不公平更重要。不公平是我们生命中的契机，是生命提供给我们，让我们自己和世界变得更加美好的机会。**\n\n\n![gongp2]({{BASE_PATH}}/image/gongp2.png)\n\n**如果这个世界到处都是不公平，那么你应该找到那个能让你改变的不公平，然后用你的方式去影响它们。**\n\n**抱怨不公平的根结是不愿改变自我，如果总抱怨不公平，就会被彻底淘汰。只要能重新审视自我，就能重新站起来，继续跟着社会的前进步伐。**\n\n\n![gongp3]({{BASE_PATH}}/image/gongp3.png)\n\n**人生就是一段从青涩逐步走向成熟的旅程。真正的成熟、厚重、坚强、自信，是从正视不公平、改善自我开始的。深处经济社会，面对各种压力，只有正视现实，调整好心态，才会找到属于自己的那份公平，把不公平甩在身后。**\n\n**个人之于人类，不过一滴血液；人类之于地球, 不过小草一棵；地球之于宇宙，不过是一点尘埃......人是这么渺小，倘心胸再窄小，将小为何物? 然而人虽渺小，心若宽阔，则能装得下整个宇宙。**\n\n\n![gongp4]({{BASE_PATH}}/image/gongp4.jpg)\n\n\n**很多时候，人们面对同一件事，主动去迎接挑战的人能获得更大的收获，我们很容易被别人左右，但是我们要知道，很多事，我们不去亲生经历而只听信他人的话，是很难真正发现自己的潜力的。大三了，很多人都不愿做班长，认为这是个苦差，很多事都要班长去做，会很烦。但是这是谁说的呢？是班长本人还是其他人呢？他们自己有没有自己亲生体验过呢？**\n\n**最后用一句话作为结尾**\n\n> **成功的人做别人不愿做的事，做别人敢做的事，做别人做不到的事,私底下的每一分的努力都会在公众面前表现出来。**\n\n\n\n</br></br></br></br></br>\n<embed src=\"http://www.xiami.com/widget/41521033_3410275,_235_200_FF8719_494949_1/multiPlayer.swf\" type=\"application/x-shockwave-flash\" width=\"235\" height=\"200\" wmode=\"opaque\"></embed>","slug":"不要怪老天不公平","updated":1411979444000,"excerpt":"<p><img src=\"/image/gongp1.png\" alt=\"gongp1\"></p>\n<p><strong>生活是不公平的，你要去接受，然后，改变它。</strong></p>\n","_id":"dvul5yz7lg9zdglr","comments":true,"layout":"post","photos":[],"link":""},{"title":"单例模式","date":1416114720000,"categories":["d62md6j57kws527n"],"tags":["bjlcejhx2acoinoo","xlmff9lxnv3ufe2j","wzlv8caqikjwx6ww"],"desctiption":"设计模式之单例模式","content":"<h2 id=\"定义\">定义</h2>\n<p><strong>单例模式</strong>：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例</p>\n<h2 id=\"类型\">类型</h2>\n<p><strong>创建类模式</strong>。</p>\n<h2 id=\"类图\">类图</h2>\n<p><img src=\"/image/danlimoshi.png\" alt=\"danlimoshi\"></p>\n<p><a id=\"more\"></a></p>\n<h2 id=\"应用背景\">应用背景</h2>\n<p>单例模式主要运用于以下场景：</p>\n<ul>\n<li>需要频繁实例化然后销毁的对象。</li>\n<li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</li>\n<li>有状态的工具类对象。</li>\n<li>频繁访问数据库或文件的对象。</li>\n<li>要求只有一个对象的场景。</li>\n</ul>\n<h2 id=\"代码实现\">代码实现</h2>\n<h3 id=\"饿汉式\">饿汉式</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton1</span></span></div><div class=\"line\">{</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton1 instance = <span class=\"keyword\">new</span> Singleton1();</div><div class=\"line\">    <span class=\"comment\">//private代表不能被实例化，不可继承</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title\">Singleton1</span>()</div><div class=\"line\">    {</div><div class=\"line\">    </div><div class=\"line\">    }</div><div class=\"line\">    <span class=\"keyword\">public</span> Singleton1 <span class=\"title\">getInstance</span>()</div><div class=\"line\">    {</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    }</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>饿汉式优缺点</strong></p>\n<ul>\n<li><strong>优点:</strong><ol>\n<li>线程安全</li>\n<li>在类加载的同时已经创建好一个静态对象，调用时反应速度快</li>\n</ol>\n</li>\n<li><strong>缺点:</strong><ol>\n<li>资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"懒汉式\">懒汉式</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton2</span>()</span></div><div class=\"line\">{</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton2 instance = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title\">Singleton2</span>()</div><div class=\"line\">    {</div><div class=\"line\">    </div><div class=\"line\">    }</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton2 <span class=\"title\">getInstance</span>()</div><div class=\"line\">    {</div><div class=\"line\">        <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)</div><div class=\"line\">        {</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton2();</div><div class=\"line\">        }</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    }</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>懒汉式优缺点</strong></p>\n<ul>\n<li><strong>优点:</strong><ol>\n<li>资源利用率高，不执行getInstance()就不会被实例化，可以执行该类的其他静态方法</li>\n</ol>\n</li>\n<li><strong>缺点:</strong><ol>\n<li>第一次加载时不够快，多线程同步使性能降低</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"静态内部类方式\">静态内部类方式</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Singleton5 {</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title\">Singleton5</span>() {</div><div class=\"line\">\t}</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHelp</span> </span>{</div><div class=\"line\">\t\t<span class=\"keyword\">static</span> Singleton5 instance = <span class=\"keyword\">new</span> Singleton5();</div><div class=\"line\">\t}</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton5 <span class=\"title\">getInstance</span>() {</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> SingletonHelp.instance;</div><div class=\"line\">\t}</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>懒汉式优缺点</strong></p>\n<ul>\n<li><strong>优点:</strong><ol>\n<li>静态内部类有饿汉式和懒汉式的优点，资源利用率高，不执行getInstance()就不会被实例化，可以执行该类的其他静态方法</li>\n</ol>\n</li>\n<li><strong>缺点:</strong><ol>\n<li>第一次加载时不够快</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"单例模式注意事项\">单例模式注意事项</h2>\n<ul>\n<li>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</li>\n<li>不要做断开单例类对象与类中静态引用的危险操作。</li>\n<li>多线程使用单例使用共享资源时，注意线程安全问题。</li>\n</ul>\n<h2 id=\"单例类继承问题\">单例类继承问题</h2>\n<p>饿汉式单例和懒汉式单例由于构造方法是private的，所以他们都是不可继承的，但是其他很多单例模式是可以继承的，例如登记式单例。</p>\n<h2 id=\"总结\">总结</h2>\n<p>形象的来说饿汉式就是等于以空间换时间，懒汉式和静态内部类式就是以时间换空间，一般来说推荐使用饿汉式，没有理由，速度是王道！</p>\n","source":"_posts/单例模式.md","raw":"title: 单例模式\ndate: 2014-11-16 13:12:00\ncategories: 设计模式\ntags: [设计模式,创建类模式,单例模式]\ndesctiption: 设计模式之单例模式\n\n---\n\n##定义\n**单例模式**：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例\n\n##类型\n**创建类模式**。\n\n##类图\n![danlimoshi]({{BASE_PATH}}/image/danlimoshi.png)\n\n<!--more-->\n##应用背景\n单例模式主要运用于以下场景：\n\n* 需要频繁实例化然后销毁的对象。\n* 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。\n* 有状态的工具类对象。\n* 频繁访问数据库或文件的对象。\n* 要求只有一个对象的场景。\n\n\n##代码实现\n###饿汉式\n```java\npublic class Singleton1\n{\n    public static Singleton1 instance = new Singleton1();\n    //private代表不能被实例化，不可继承\n    private Singleton1()\n    {\n    \n    }\n    public Singleton1 getInstance()\n    {\n        return instance;\n    }\n}\n```\n**饿汉式优缺点**\n\n* **优点:**\n    1. 线程安全\n    2. 在类加载的同时已经创建好一个静态对象，调用时反应速度快\n* **缺点:**\n    1. 资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化\n\n###懒汉式\n```java\npublic class Singleton2()\n{\n    public static Singleton2 instance = null;\n    private Singleton2()\n    {\n    \n    }\n    public static synchronized Singleton2 getInstance()\n    {\n        if(instance == null)\n        {\n            instance = new Singleton2();\n        }\n        return instance;\n    }\n}\n```\n**懒汉式优缺点**\n* **优点:**\n    1. 资源利用率高，不执行getInstance()就不会被实例化，可以执行该类的其他静态方法\n* **缺点:**\n    1. 第一次加载时不够快，多线程同步使性能降低\n\n###静态内部类方式\n```java\nclass Singleton5 {\n    private Singleton5() {\n\t}\n\n\tprivate static class SingletonHelp {\n\t\tstatic Singleton5 instance = new Singleton5();\n\t}\n\n\tpublic static Singleton5 getInstance() {\n\t\treturn SingletonHelp.instance;\n\t}\n}\n```\n**懒汉式优缺点**\n* **优点:**\n    1. 静态内部类有饿汉式和懒汉式的优点，资源利用率高，不执行getInstance()就不会被实例化，可以执行该类的其他静态方法\n* **缺点:**\n    1. 第一次加载时不够快\n\n##单例模式注意事项\n* 只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。\n* 不要做断开单例类对象与类中静态引用的危险操作。\n* 多线程使用单例使用共享资源时，注意线程安全问题。\n\n\n##单例类继承问题\n饿汉式单例和懒汉式单例由于构造方法是private的，所以他们都是不可继承的，但是其他很多单例模式是可以继承的，例如登记式单例。\n\n##总结\n形象的来说饿汉式就是等于以空间换时间，懒汉式和静态内部类式就是以时间换空间，一般来说推荐使用饿汉式，没有理由，速度是王道！","slug":"单例模式","updated":1416115212000,"excerpt":"<h2 id=\"定义\">定义</h2>\n<p><strong>单例模式</strong>：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例</p>\n<h2 id=\"类型\">类型</h2>\n<p><strong>创建类模式</strong>。</p>\n<h2 id=\"类图\">类图</h2>\n<p><img src=\"/image/danlimoshi.png\" alt=\"danlimoshi\"></p>\n<p>","_id":"1ola4tvw75ou1nwh","comments":true,"layout":"post","photos":[],"link":""},{"layout":"photo","title":"暑假之末","date":1408895580000,"categories":["uw37i2o0tlv7fezh"],"tags":["m97v9igubxl9plss"],"desctiption":"感悟.","content":"<p><img src=\"/image/haitan2.jpg\" alt=\"haitan2\"></p>\n<ul>\n<li>目及之处，海天一色，夏去秋来，炎炎不在！<a id=\"more\"></a></li>\n<li>快乐的时光总是如此短暂，转眼两个多月的暑假马上就过去了，这个暑假相比往年的暑假都要长，所以将这个暑假划分成两个暑假来过，刚放学后回家将驾<br>照考了，然后回到学校，待到了今天，然后再回家过完剩余不多的暑假，感觉这样才不会过于无聊吧，能使一个暑假体会到两次防暑假的新鲜感。</li>\n<li>但是现在能明显感觉到现在的暑假已经和以往的暑假已经不能比了，童年时在河中与小伙伴们打闹的记忆犹存，<br>至少三五个小伙伴总能凑到一起玩耍，而现在则难再相聚，这让我想起了电影《后会无期》的<br>一句台词  <blockquote>\n<p>“告别的时候一定要用力一点，多说一句，说不定就成了最后一句;多看一眼，弄不好就是最后一眼”</p>\n</blockquote>\n</li>\n</ul>\n<embed src=\"http://www.xiami.com/widget/41521033_1773346501,_235_200_FF8719_494949_1/multiPlayer.swf\" type=\"application/x-shockwave-flash\" width=\"235\" height=\"200\" wmode=\"opaque\">","source":"_posts/暑假之末.md","raw":"layout: photo\ntitle: 暑假之末\ndate: 2014-08-24 23:53:00\ncategories: 人生轨迹\ntags: [life]\ndesctiption: 感悟.\n---\n\n![haitan2]({{BASE_PATH}}/image/haitan2.jpg)\n* 目及之处，海天一色，夏去秋来，炎炎不在！\n<!--more-->\n* 快乐的时光总是如此短暂，转眼两个多月的暑假马上就过去了，这个暑假相比往年的暑假都要长，所以将这个暑假划分成两个暑假来过，刚放学后回家将驾\n照考了，然后回到学校，待到了今天，然后再回家过完剩余不多的暑假，感觉这样才不会过于无聊吧，能使一个暑假体会到两次防暑假的新鲜感。\n* 但是现在能明显感觉到现在的暑假已经和以往的暑假已经不能比了，童年时在河中与小伙伴们打闹的记忆犹存，\n至少三五个小伙伴总能凑到一起玩耍，而现在则难再相聚，这让我想起了电影《后会无期》的\n一句台词  \n>“告别的时候一定要用力一点，多说一句，说不定就成了最后一句;多看一眼，弄不好就是最后一眼”\n\n\n<embed src=\"http://www.xiami.com/widget/41521033_1773346501,_235_200_FF8719_494949_1/multiPlayer.swf\" type=\"application/x-shockwave-flash\" width=\"235\" height=\"200\" wmode=\"opaque\"></embed>","slug":"暑假之末","updated":1411307745000,"excerpt":"<p><img src=\"/image/haitan2.jpg\" alt=\"haitan2\"></p>\n<ul>\n<li>目及之处，海天一色，夏去秋来，炎炎不在！","_id":"rdjztuauarfhs0h9","comments":true,"photos":[],"link":""},{"title":"正则表达式基础","date":1407921660000,"categories":["ul6daxntcjqe0xkn"],"tags":["cvtl2cvj7tzlad6o","yzou6ohxuwbhfjes"],"desctiption":"正则表达式基础及java的使用","content":"<p><img src=\"/image/regex示例.jpg\" alt=\"regex\"></p>\n<h2 id=\"前言\">前言</h2>\n<p>正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本，<br>许多程序设计语言都支持利用正则表达式进行字符串操作，因此正则表达式还是非常强大的，它对于一些文本的处理非常简洁从而能有效缩短代码的长度。</p>\n<p><a id=\"more\"></a></p>\n<h2 id=\"简单的转义字符\">简单的转义字符</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">普通字符：字母，数字，汉子，下划线以及没有特殊定义的标点符号都是“普通字符”。   </div><div class=\"line\">表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符</div><div class=\"line\"></div><div class=\"line\">简单的转义字符：</div><div class=\"line\"></div><div class=\"line\"><span class=\"command\">\\n</span> ：代表换行符</div><div class=\"line\"></div><div class=\"line\"><span class=\"command\">\\t</span> ：代表制表符</div><div class=\"line\"></div><div class=\"line\"><span class=\"command\">\\\\</span> ：代表<span class=\"command\">\\本</span>身</div><div class=\"line\"></div><div class=\"line\"><span class=\"command\">\\^</span> ......  ：代表匹配这字符本身</div></pre></td></tr></table></figure>\n\n<h2 id=\"标准字符集合\">标准字符集合</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">标准字符集合：</div><div class=\"line\"></div><div class=\"line\">能够与多种字符匹配的表达式</div><div class=\"line\"></div><div class=\"line\">注意区分大小写，大写是相反的意思</div><div class=\"line\"></div><div class=\"line\"><span class=\"command\">\\d</span> ：任意一个数字，0～9中的任意一个</div><div class=\"line\"></div><div class=\"line\"><span class=\"command\">\\w</span>：任意一个字母或者下划线或者汉字，也就是A～Z，a～z，0～9中的任意一个</div><div class=\"line\"></div><div class=\"line\"><span class=\"command\">\\s</span> ：包括空格，制表符，换行符等空白符中的任意一个。</div><div class=\"line\"></div><div class=\"line\">.   ：小数点可以匹配任意一个字符</div></pre></td></tr></table></figure>\n\n<h2 id=\"自定义字符集合\">自定义字符集合</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">自定义字符集合：</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr_selector\">[ ]</span>方括号匹配方式，能够匹配方括号中任意一个字符</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr_selector\">[ab5@]</span>： 匹配方括号中的任意一个字符</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr_selector\">[^abc]</span>： 匹配除了<span class=\"tag\">abc</span>以外的任意一个字符</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr_selector\">[f-k]</span>： 匹配“<span class=\"tag\">f</span>”<span class=\"tag\">-</span>“<span class=\"tag\">k</span>”之间的任意一个字符</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr_selector\">[^A-F0-3]</span>： 匹配非<span class=\"tag\">A-F</span>和非0<span class=\"tag\">-3</span>的任意一个字符</div></pre></td></tr></table></figure>\n\n<h2 id=\"修饰匹配次数的特殊符号\">修饰匹配次数的特殊符号</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">修饰匹配次数的特殊符号</div><div class=\"line\"></div><div class=\"line\"><span class=\"list\">{n}</span>： 表达式重复n次</div><div class=\"line\"></div><div class=\"line\"><span class=\"list\">{m，n}</span>： 表达式至少重复m次，最多重复n次</div><div class=\"line\"></div><div class=\"line\"><span class=\"list\">{m，}</span>： 表达式至少重复m次</div><div class=\"line\"></div><div class=\"line\">？： 匹配表达式<span class=\"number\">0</span>次或者<span class=\"number\">1</span>次，相当于<span class=\"list\">{0,1}</span></div><div class=\"line\"></div><div class=\"line\"> + ： 表达式至少出现<span class=\"number\">1</span>次，相当于<span class=\"list\">{1,}</span></div><div class=\"line\"></div><div class=\"line\"> *  ： 表达式不出现或者出现任意次，相当于<span class=\"list\">{0,}</span></div><div class=\"line\"></div><div class=\"line\"> 匹配次数中的贪婪模式，（匹配字符愈多愈好，默认）</div><div class=\"line\"></div><div class=\"line\"> 匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个“？“号）。例子：\\d<span class=\"list\">{2,4}</span>?，这样就将模式改为非贪婪</div></pre></td></tr></table></figure>\n\n<h2 id=\"字符边界\">字符边界</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">字符边界（本组标记匹配的不是字符而是位置，符合某种条件的位置）</div><div class=\"line\"></div><div class=\"line\">^： 与字符串开始的位置匹配（以一行来算）</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">$：</span> 与字符串结束的地方匹配</div></pre></td></tr></table></figure>\n\n<h2 id=\"java中使用正则表达式示例\">java中使用正则表达式示例</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestRegex</span> </span>{  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(String []args)  </div><div class=\"line\">    {  </div><div class=\"line\">        <span class=\"comment\">//Pattern p = Pattern.compile(\"^\\\\d{4}\");  //在java中的反斜杠要用两个前面一个转义，因为\\d中的\\做反义用  </span></div><div class=\"line\">        Pattern p = Pattern.compile(<span class=\"string\">\"(\\\\d{4})([a-z]{2})\"</span>);  </div><div class=\"line\">        Matcher m = p.matcher(<span class=\"string\">\"asdfsadfsafd2342314asdfsadf2342asdfsaf\"</span>);  </div><div class=\"line\">          </div><div class=\"line\">        System.out.println(m.matches());        <span class=\"comment\">//匹配整个目标字符串  </span></div><div class=\"line\">        System.out.println(m.find());           <span class=\"comment\">//查找字符串  </span></div><div class=\"line\">          </div><div class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();        <span class=\"comment\">//用来存储找到的group  </span></div><div class=\"line\">        <span class=\"keyword\">while</span>(m.find())                     <span class=\"comment\">//m.find()找到一个后就去找下一个了  </span></div><div class=\"line\">        {  </div><div class=\"line\">            System.out.println(m.group());      <span class=\"comment\">//group(),group(0)的作用是一样的  </span></div><div class=\"line\">            System.out.println(m.group(<span class=\"number\">0</span>));  </div><div class=\"line\">            System.out.println(m.group(<span class=\"number\">1</span>));  </div><div class=\"line\">            System.out.println(m.group(<span class=\"number\">2</span>));     <span class=\"comment\">//如果写3的话会超出范围  </span></div><div class=\"line\">            list.add(m.group());  </div><div class=\"line\">        }  </div><div class=\"line\">          </div><div class=\"line\">        String []str = <span class=\"string\">\"aa33fdf55cc\"</span>.split(<span class=\"string\">\"\\\\d{2}\"</span>);       <span class=\"comment\">//按照两个整数来切分  </span></div><div class=\"line\">        String str2 =<span class=\"string\">\"asd2dsfdfds\"</span>.replaceAll(<span class=\"string\">\"\\\\ds\"</span>, <span class=\"string\">\"**\"</span>);        <span class=\"comment\">//将ds替换掉，生成新的字符串，因为前面是常量不可变  </span></div><div class=\"line\">        System.out.println(<span class=\"string\">\"asdfsdf\"</span>.matches(<span class=\"string\">\"\\\\w+\"</span>));      <span class=\"comment\">//匹配字符串  </span></div><div class=\"line\">    }  </div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<h2 id=\"总结\">总结</h2>\n<p>本文只列出了正则表达式的基本使用方法，能够进行一些基本的处理了， 还有更加高级的语法有兴趣可以点<br><a href=\"http://msdn.microsoft.com/zh-cn/library/ae5bf541%28VS.80%29.aspx\" target=\"_blank\" rel=\"external\">这里</a></p>\n","source":"_posts/正则表达式基础.md","raw":"title: 正则表达式基础\ndate: 2014-08-13 17:21:00\ncategories: java\ntags: [正则表达式,java]\ndesctiption: 正则表达式基础及java的使用\n\n---\n\n![regex]({{BASE_PATH}}/image/regex示例.jpg)\n\n##前言\n正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本，\n许多程序设计语言都支持利用正则表达式进行字符串操作，因此正则表达式还是非常强大的，它对于一些文本的处理非常简洁从而能有效缩短代码的长度。\n\n<!--more-->\n##简单的转义字符\n```shell\n    普通字符：字母，数字，汉子，下划线以及没有特殊定义的标点符号都是“普通字符”。   \n    表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符\n\n    简单的转义字符：\n\n    \\n ：代表换行符\n\n    \\t ：代表制表符\n\n    \\\\ ：代表\\本身\n\n    \\^ ......  ：代表匹配这字符本身\n```\n\n##标准字符集合\n```shell\n    标准字符集合：\n\n    能够与多种字符匹配的表达式\n\n    注意区分大小写，大写是相反的意思\n\n    \\d ：任意一个数字，0～9中的任意一个\n\n    \\w：任意一个字母或者下划线或者汉字，也就是A～Z，a～z，0～9中的任意一个\n\n    \\s ：包括空格，制表符，换行符等空白符中的任意一个。\n\n    .   ：小数点可以匹配任意一个字符\n```\n\n##自定义字符集合\n```shell\n    自定义字符集合：\n\n    [ ]方括号匹配方式，能够匹配方括号中任意一个字符\n\n    [ab5@]： 匹配方括号中的任意一个字符\n\n    [^abc]： 匹配除了abc以外的任意一个字符\n\n    [f-k]： 匹配“f”-“k”之间的任意一个字符\n\n    [^A-F0-3]： 匹配非A-F和非0-3的任意一个字符 \n```\n\n##修饰匹配次数的特殊符号\n```shell\n    修饰匹配次数的特殊符号\n\n    {n}： 表达式重复n次\n\n    {m，n}： 表达式至少重复m次，最多重复n次\n\n    {m，}： 表达式至少重复m次\n\n    ？： 匹配表达式0次或者1次，相当于{0,1}\n\n     + ： 表达式至少出现1次，相当于{1,}\n\n     *  ： 表达式不出现或者出现任意次，相当于{0,}\n\n     匹配次数中的贪婪模式，（匹配字符愈多愈好，默认）\n\n     匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个“？“号）。例子：\\d{2,4}?，这样就将模式改为非贪婪\n```\n\n##字符边界\n```shell\n    字符边界（本组标记匹配的不是字符而是位置，符合某种条件的位置）\n\n    ^： 与字符串开始的位置匹配（以一行来算）\n\n    $： 与字符串结束的地方匹配\n```\n##java中使用正则表达式示例\n```java\n    public class TestRegex {  \n        public static void main(String []args)  \n        {  \n            //Pattern p = Pattern.compile(\"^\\\\d{4}\");  //在java中的反斜杠要用两个前面一个转义，因为\\d中的\\做反义用  \n            Pattern p = Pattern.compile(\"(\\\\d{4})([a-z]{2})\");  \n            Matcher m = p.matcher(\"asdfsadfsafd2342314asdfsadf2342asdfsaf\");  \n              \n            System.out.println(m.matches());        //匹配整个目标字符串  \n            System.out.println(m.find());           //查找字符串  \n              \n            List<String> list = new ArrayList<String>();        //用来存储找到的group  \n            while(m.find())                     //m.find()找到一个后就去找下一个了  \n            {  \n                System.out.println(m.group());      //group(),group(0)的作用是一样的  \n                System.out.println(m.group(0));  \n                System.out.println(m.group(1));  \n                System.out.println(m.group(2));     //如果写3的话会超出范围  \n                list.add(m.group());  \n            }  \n              \n            String []str = \"aa33fdf55cc\".split(\"\\\\d{2}\");       //按照两个整数来切分  \n            String str2 =\"asd2dsfdfds\".replaceAll(\"\\\\ds\", \"**\");        //将ds替换掉，生成新的字符串，因为前面是常量不可变  \n            System.out.println(\"asdfsdf\".matches(\"\\\\w+\"));      //匹配字符串  \n        }  \n    }  \n\n```\n##总结\n本文只列出了正则表达式的基本使用方法，能够进行一些基本的处理了， 还有更加高级的语法有兴趣可以点\n[这里](http://msdn.microsoft.com/zh-cn/library/ae5bf541%28VS.80%29.aspx)","slug":"正则表达式基础","updated":1410339550000,"excerpt":"<p><img src=\"/image/regex示例.jpg\" alt=\"regex\"></p>\n<h2 id=\"前言\">前言</h2>\n<p>正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本，<br>许多程序设计语言都支持利用正则表达式进行字符串操作，因此正则表达式还是非常强大的，它对于一些文本的处理非常简洁从而能有效缩短代码的长度。</p>\n<p>","_id":"5ya2xti44vlx3etz","comments":true,"layout":"post","photos":[],"link":""},{"title":"观察者模式","date":1415803020000,"categories":["d62md6j57kws527n"],"tags":["bjlcejhx2acoinoo","j5aukb7bzf04bxzu","jz5lf65dm6fm5m8x"],"desctiption":"各类设计模式总结","content":"<h2 id=\"定义\">定义</h2>\n<p><strong>观察者模式</strong>定义对象间一种一对一的依赖关系，使得当每一个对象改变状态是，则所有依赖于它的对象都会得到通知并自动更新。</p>\n<h2 id=\"类型\">类型</h2>\n<p><strong>行为类模式</strong>。</p>\n<h2 id=\"类图\">类图</h2>\n<p><img src=\"/image/observer.png\" alt=\"观察者模式\"></p>\n<a id=\"more\"></a>\n\n\n<h2 id=\"应用背景\">应用背景</h2>\n<p>在软件系统中经常有这样的需求：如果一个对象的状态的改变能对某些与它相关联的对象也要随之做出变化，这有点类似与一些界面中的按钮的监听事件，触发相应的事件后就能做出相对应的动作。实现这一点的方案很多，用观察者模式是一个主流的选择。</p>\n<h2 id=\"结构\">结构</h2>\n<p>在最基础的观察者模式中，有以下四个角色：</p>\n<ul>\n<li>被观察者</li>\n</ul>\n<p>结构中有一个存放观察者对象的vector容器（之所以使用vector而不用list是因为在多线程操作中，vector是线程安全的，而list是不安全的），这个vector容器是被观察者类的核心。</p>\n<p>另外还有三个方法：attach方法是向这个容器中添加观察者对象：detach方法是从容器中移除观察者对象：notify方法是以此调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。</p>\n<ul>\n<li>观察者</li>\n</ul>\n<p>观察者角色一般是一个接口，它只有一个update方法，在被观察者发生变化时，这个方法就会被触发调用。</p>\n<ul>\n<li>具体的被观察者</li>\n</ul>\n<p>使用这个角色是为了便于扩展，可以在此角色中定义具体的业务逻辑，</p>\n<ul>\n<li>具体的观察者</li>\n</ul>\n<p>观察者接口的具体实现，定义观察者在被观察者状态发生改变时的业务逻辑。</p>\n<h2 id=\"代码实现\">代码实现</h2>\n<p><strong>观察者接口Observer</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface Observer {</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span>();</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>被观察者抽象类Subject</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.Vector;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">abstract</span> class Subject {</div><div class=\"line\">    <span class=\"keyword\">private</span> Vector&lt;Observer&gt; obs = <span class=\"keyword\">new</span> Vector&lt;Observer&gt;();</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span>(Observer obs)</div><div class=\"line\">\t{</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.obs.add(obs);</div><div class=\"line\">\t}</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delObserver</span>(Observer obs)</div><div class=\"line\">\t{</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.obs.remove(obs);</div><div class=\"line\">\t}</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObserver</span>() {</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Observer o :obs)</div><div class=\"line\">\t\t{</div><div class=\"line\">\t\t\to.update();</div><div class=\"line\">\t\t}</div><div class=\"line\">\t}</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span>();</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>观察者接口实现类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteObserver1</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span></span>{</div><div class=\"line\"></div><div class=\"line\">    <span class=\"annotation\">@Override</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span>() {</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"the observer1 receives the message\"</span>);</div><div class=\"line\">\t}</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteObserver2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span></span>{</div><div class=\"line\"></div><div class=\"line\">    <span class=\"annotation\">@Override</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span>() {</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"the observer2 receives the message\"</span>);</div><div class=\"line\">\t}</div><div class=\"line\"></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>被观察者实现类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcerteSubject</span> <span class=\"keyword\">extends</span> <span class=\"title\">Subject</span></span>{</div><div class=\"line\"></div><div class=\"line\">    <span class=\"annotation\">@Override</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span>() {</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"sonething has happened\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.notifyObserver();</div><div class=\"line\">\t}</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>主方法client</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">client</span> </span>{</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(String[] args) {</div><div class=\"line\">\t\tSubject sub = <span class=\"keyword\">new</span> ConcerteSubject();</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsub.addObserver(<span class=\"keyword\">new</span> ConcreteObserver1());</div><div class=\"line\">\t\tsub.addObserver(<span class=\"keyword\">new</span> ConcreteObserver2());</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsub.doSomething();</div><div class=\"line\">\t}</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>测试运行后发现我们只是调用了Subject的方法，但同时两个观察者的相关方法都被同时调用了。因为在Subject类中关联了Observer类，并且在doSomething中遍历了Observer的update方法。</p>\n<h2 id=\"优点与缺点\">优点与缺点</h2>\n<h3 id=\"优点\">优点</h3>\n<p>观察者与被观察者之间是属于轻度的关联关系，并且都是抽象耦合的，这样，对于两者来说都比较容易进行扩展。</p>\n<p>观察者模式是一种常用的出发机制，它形成一条触发链，依次对各个观察者的方法进行处理。</p>\n<h3 id=\"缺点\">缺点</h3>\n<p>形成的触发链也是观察者模式的一个缺点，由于是链式出发，当观察者比较多的时候，性能问题是比较令人担忧的。并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。</p>\n<h2 id=\"总结\">总结</h2>\n<p>在java中，有一个接口Observer，以及它的实现类Observable，对观察者角色进行了实现，可以参考jdk的api文档来查看这两个类的使用方法。</p>\n<p>如果要设计一个事件触发处理机制的功能，使用观察者模式是一个不错的选择。</p>\n","source":"_posts/观察者模式.md","raw":"title: 观察者模式\ndate: 2014-11-12 22:37:00\ncategories: 设计模式\ntags: [设计模式,观察者模式,行为类模式]\ndesctiption: 各类设计模式总结\n\n---\n\n##定义\n**观察者模式**定义对象间一种一对一的依赖关系，使得当每一个对象改变状态是，则所有依赖于它的对象都会得到通知并自动更新。\n\n##类型\n**行为类模式**。\n\n##类图\n\n![观察者模式]({{BASE_PATH}}/image/observer.png)\n\n\n<!-- more -->\n\n\n##应用背景\n在软件系统中经常有这样的需求：如果一个对象的状态的改变能对某些与它相关联的对象也要随之做出变化，这有点类似与一些界面中的按钮的监听事件，触发相应的事件后就能做出相对应的动作。实现这一点的方案很多，用观察者模式是一个主流的选择。\n\n\n##结构\n在最基础的观察者模式中，有以下四个角色：\n\n* 被观察者\n \n结构中有一个存放观察者对象的vector容器（之所以使用vector而不用list是因为在多线程操作中，vector是线程安全的，而list是不安全的），这个vector容器是被观察者类的核心。\n\n另外还有三个方法：attach方法是向这个容器中添加观察者对象：detach方法是从容器中移除观察者对象：notify方法是以此调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。\n\n* 观察者\n\n观察者角色一般是一个接口，它只有一个update方法，在被观察者发生变化时，这个方法就会被触发调用。\n\n* 具体的被观察者\n\n使用这个角色是为了便于扩展，可以在此角色中定义具体的业务逻辑，\n\n* 具体的观察者\n\n观察者接口的具体实现，定义观察者在被观察者状态发生改变时的业务逻辑。\n\n\n##代码实现\n\n**观察者接口Observer**\n```java\ninterface Observer {\n    public void update();\n}\n```\n**被观察者抽象类Subject**\n```java\nimport java.util.Vector;\n\nabstract class Subject {\n    private Vector<Observer> obs = new Vector<Observer>();\n\t\n\tpublic void addObserver(Observer obs)\n\t{\n\t\tthis.obs.add(obs);\n\t}\n\t\n\tpublic void delObserver(Observer obs)\n\t{\n\t\tthis.obs.remove(obs);\n\t}\n\t\n\tprotected void notifyObserver() {\n\t\tfor(Observer o :obs)\n\t\t{\n\t\t\to.update();\n\t\t}\n\t}\n\t\n\tpublic abstract void doSomething();\n}\n```\n**观察者接口实现类**\n```java\npublic class ConcreteObserver1 implements Observer{\n\n    @Override\n\tpublic void update() {\n\t\tSystem.out.println(\"the observer1 receives the message\");\n\t}\n}\n\npublic class ConcreteObserver2 implements Observer{\n\n    @Override\n\tpublic void update() {\n\t\tSystem.out.println(\"the observer2 receives the message\");\n\t}\n\n}\n```\n**被观察者实现类**\n```java\npublic class ConcerteSubject extends Subject{\n\n    @Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(\"sonething has happened\");\n\t\tthis.notifyObserver();\n\t}\n}\n```\n**主方法client**\n```java\npublic class client {\n\n    public static void main(String[] args) {\n\t\tSubject sub = new ConcerteSubject();\n\t\t\n\t\tsub.addObserver(new ConcreteObserver1());\n\t\tsub.addObserver(new ConcreteObserver2());\n\t\t\n\t\tsub.doSomething();\n\t}\n}\n```\n\n测试运行后发现我们只是调用了Subject的方法，但同时两个观察者的相关方法都被同时调用了。因为在Subject类中关联了Observer类，并且在doSomething中遍历了Observer的update方法。\n\n##优点与缺点\n###优点\n观察者与被观察者之间是属于轻度的关联关系，并且都是抽象耦合的，这样，对于两者来说都比较容易进行扩展。\n\n观察者模式是一种常用的出发机制，它形成一条触发链，依次对各个观察者的方法进行处理。\n\n###缺点\n形成的触发链也是观察者模式的一个缺点，由于是链式出发，当观察者比较多的时候，性能问题是比较令人担忧的。并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。\n\n##总结\n在java中，有一个接口Observer，以及它的实现类Observable，对观察者角色进行了实现，可以参考jdk的api文档来查看这两个类的使用方法。\n\n如果要设计一个事件触发处理机制的功能，使用观察者模式是一个不错的选择。","slug":"观察者模式","updated":1416115180000,"excerpt":"<h2 id=\"定义\">定义</h2>\n<p><strong>观察者模式</strong>定义对象间一种一对一的依赖关系，使得当每一个对象改变状态是，则所有依赖于它的对象都会得到通知并自动更新。</p>\n<h2 id=\"类型\">类型</h2>\n<p><strong>行为类模式</strong>。</p>\n<h2 id=\"类图\">类图</h2>\n<p><img src=\"/image/observer.png\" alt=\"观察者模式\"></p>\n","_id":"mukwirk7jsh2805p","comments":true,"layout":"post","photos":[],"link":""},{"title":"适配器模式","date":1423962420000,"categories":["d62md6j57kws527n"],"tags":["odb22aticq9sihxn","glqtgamciem49e61"],"desctiption":"各类设计模式总结","content":"<h2 id=\"定义\">定义</h2>\n<p><strong>适配器模式</strong></p>\n<p>将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>\n<h2 id=\"类型\">类型</h2>\n<p><strong>结构型模式</strong>。</p>\n<h2 id=\"类图\">类图</h2>\n<p><img src=\"/image/AdapterMode.jpg\" alt=\"适配器模式\"></p>\n<a id=\"more\"></a>\n\n\n<h2 id=\"适用性\">适用性</h2>\n<ol>\n<li>你想使用一个已经存在的类，而它的接口不符合你的要求。</li>\n<li>你想创建一个可以复用的类，该类可以与其他不相关的类或者不可预见的类（即那些接口可能不一定兼容的类）协同工作</li>\n<li>（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li>\n</ol>\n<h2 id=\"结构\">结构</h2>\n<ol>\n<li><p>Target</p>\n<p> 定义Client使用的与特定领域相关的接口</p>\n</li>\n<li><p>Client</p>\n<p> 与符合的Target接口的对象协同</p>\n</li>\n<li><p>Adaptee</p>\n<p> 定义一个已经存在的接口，这个接口需要适配</p>\n</li>\n<li><p>Adapter</p>\n<p> 对Adaptee的接口与Target接口进行适配</p>\n</li>\n</ol>\n<h2 id=\"代码实现\">代码实现</h2>\n<p><strong>Target接口</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Target</span></span>{</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">void</span> adapteeMethod();</div><div class=\"line\">    <span class=\"keyword\">void</span> adapterMethod();</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>Adaptee类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee</span></span>{</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">adapteeMethod</span>(){</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Adaptee method\"</span>);</div><div class=\"line\">    }</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>Adapter实现Target接口类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Target</span></span>{</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">private</span> Adaptee adaptee;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title\">Adapter</span>(Adaptee adaptee){</div><div class=\"line\">        <span class=\"keyword\">this</span>.adaptee = adaptee;</div><div class=\"line\">    }</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">adapteeMethod</span>(){</div><div class=\"line\">        adaptee.adapteeMethod();</div><div class=\"line\">    }</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">adapterMethod</span>(){</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Adapter method!\"</span>);</div><div class=\"line\">    }</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>主方法类Test</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>{</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(String[] args) {</div><div class=\"line\">        Target target = <span class=\"keyword\">new</span> Adapter(<span class=\"keyword\">new</span> Adaptee());</div><div class=\"line\">        </div><div class=\"line\">        target.adapteeMethod();</div><div class=\"line\">        target.adapterMethod();</div><div class=\"line\">    </div><div class=\"line\">    }</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>运行结果</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Adaptee method</div><div class=\"line\">Adapter method</div></pre></td></tr></table></figure>\n\n<h2 id=\"总结\">总结</h2>\n<p><strong>优点</strong></p>\n<ul>\n<li><p>通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。</p>\n</li>\n<li><p>复用了现存的类，解决了现存类和复用环境要求不一致的问题。</p>\n</li>\n<li><p>将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。</p>\n</li>\n<li><p>一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</p>\n</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>对于对象适配器来说，更换适配器的实现过程比较复杂。</li>\n</ul>\n","source":"_posts/适配器模式.md","raw":"title: 适配器模式\ndate: 2015-02-15 09:07:00\ncategories: 设计模式\ntags: [设计模式，适配器模式,结构性模式]\ndesctiption: 各类设计模式总结\n\n---\n\n##定义\n**适配器模式**\n\n将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n\n##类型\n**结构型模式**。\n\n##类图\n\n![适配器模式]({{BASE_PATH}}/image/AdapterMode.jpg)\n\n\n<!-- more -->\n\n\n##适用性\n1. 你想使用一个已经存在的类，而它的接口不符合你的要求。\n2. 你想创建一个可以复用的类，该类可以与其他不相关的类或者不可预见的类（即那些接口可能不一定兼容的类）协同工作\n3. （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。\n\n\n##结构\n\n1. Target\n\n    定义Client使用的与特定领域相关的接口\n2. Client\n\n    与符合的Target接口的对象协同\n3. Adaptee\n\n    定义一个已经存在的接口，这个接口需要适配\n4. Adapter\n    \n    对Adaptee的接口与Target接口进行适配\n\n\n##代码实现\n\n**Target接口**\n```java\npublic interface Target{\n\n    void adapteeMethod();\n    void adapterMethod();\n}\n```\n**Adaptee类**\n```java\npublic class Adaptee{\n    public void adapteeMethod(){\n        System.out.println(\"Adaptee method\");\n    }\n}\n\n```\n**Adapter实现Target接口类**\n```java\npublic class Adapter implements Target{\n    \n    private Adaptee adaptee;\n    \n    public Adapter(Adaptee adaptee){\n        this.adaptee = adaptee;\n    }\n    \n    public void adapteeMethod(){\n        adaptee.adapteeMethod();\n    }\n    \n    public void adapterMethod(){\n        System.out.println(\"Adapter method!\");\n    }\n}\n```\n**主方法类Test**\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        Target target = new Adapter(new Adaptee());\n        \n        target.adapteeMethod();\n        target.adapterMethod();\n    \n    }\n}\n```\n\n**运行结果**\n```java\nAdaptee method\nAdapter method\n```\n\n##总结\n**优点**\n\n* 通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。\n\n* 复用了现存的类，解决了现存类和复用环境要求不一致的问题。\n\n* 将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。\n\n* 一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。\n\n**缺点**\n\n* 对于对象适配器来说，更换适配器的实现过程比较复杂。\n","slug":"适配器模式","updated":1423964578000,"excerpt":"<h2 id=\"定义\">定义</h2>\n<p><strong>适配器模式</strong></p>\n<p>将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>\n<h2 id=\"类型\">类型</h2>\n<p><strong>结构型模式</strong>。</p>\n<h2 id=\"类图\">类图</h2>\n<p><img src=\"/image/AdapterMode.jpg\" alt=\"适配器模式\"></p>\n","_id":"m5c3vnkf5ukpo1yz","comments":true,"layout":"post","photos":[],"link":""},{"title":"Android侧拉菜单SlidingMenu的配置和使用","date":1411640220000,"categories":["pmcyb6oshop5size"],"tags":["hf98yxietusc8sh7","ygr0yetsrvmoz7ig","mr5es4hbw6jf08st","rqmwgs849rzhlauj","bmdj4v9n7r7bxuzf"],"desctiption":"使用开源项目SlidingMenu侧拉菜单","content":"<p><img src=\"/image/demo.gif\" alt=\"demo\"></p>\n<h1 id=\"前言\">前言</h1>\n<p>很多<strong>android菜单</strong>都做的很炫，其中用的做多的就数<strong>侧拉菜单</strong>了，比如说唱吧，以前的人人，当然也有很多客户端改版后可能用其他的了，但是<strong>SlidingMenu</strong>的确是一个很强大的工具。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"环境配置\">环境配置</h1>\n<p>很多工具有炫丽的效果来吸引用户的眼球，但是这些炫丽的效果肯定需要一些代价，那就是很多代码的支持，这个项目页不例外，在配置环境时很有可能会遇到一系列问题，下面就写一下具体<strong>配置的步骤</strong>和<strong>可能遇到的问题</strong>。</p>\n<h2 id=\"准备工作\">准备工作</h2>\n<ul>\n<li>首先去网上下载相应的依赖工程，这里主要下载在<strong>github</strong>上面的两个项目，一个是<a href=\"https://github.com/jfeinstein10/SlidingMenu\" target=\"_blank\" rel=\"external\"><strong>SlidingMenu</strong></a>，另外一个是<a href=\"https://github.com/JakeWharton/ActionBarSherlock\" target=\"_blank\" rel=\"external\"><strong>ActionBarSherlock</strong></a>。把这两个工程导入eclipse，其中在SlidingMenu导入eclipse后可以得到两个项目，一个是<strong>exampleListActivity</strong>，另外一个是<strong>library</strong>，这个library是作为前面一个工程的依赖包的。</li>\n<li>具体如何将一个项目作为另一个项目的依赖呢？可以右击这个项目，然后选择属性，在android那一栏有一个<strong>is Library</strong>选项，勾选以后这个项目就能作为其他项目的依赖了。</li>\n<li>然后将下载的<strong>ActionBarSherlock</strong>这个工程也添加到eclipse中来，将添加进来的工程也配置成一个<strong>Library</strong>，然后在<strong>exampleListActivity</strong>中添加这个依赖。</li>\n</ul>\n<h2 id=\"依赖和版本统一\">依赖和版本统一</h2>\n<ul>\n<li>如果你的各个导入的项目的<strong>API等级</strong>不同的话在加载的时候就会报错，因此这时候最好将每个导入的文件的API等级换成一样的就行了。</li>\n<li>如果你的各个导入的项目的<strong>android-support-v4.jar</strong>的版本不同的话也会报错，这时就需要手动将各个版本的jar包换成统一的。</li>\n</ul>\n<h2 id=\"修改代码\">修改代码</h2>\n<ul>\n<li>打开在<strong>Library</strong>项目中的<strong>SlidingFragmentActivity</strong>这个类，并且添加以下的代码来声明这个类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> com.actionbarsherlock.app.SherlockFragmentActivity;</div></pre></td></tr></table></figure>\n\n<ul>\n<li>然后进行替换代码，将这个文件内的</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SlidingFragmentActivity extends FragmentActivity implements SlidingActivityBase</div></pre></td></tr></table></figure>\n\n<ul>\n<li>替换成下面这行</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SlidingFragmentActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">SherlockFragmentActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">SlidingActivityBase</span></span></div></pre></td></tr></table></figure>\n\n<h2 id=\"测试\">测试</h2>\n<p>如果不出意外的话，现在就可以运行侧拉菜单的示例程序了，示例程序只是一个大体的轮廓，具体的配置需要你手动去调整，下面这幅图就是一个使用SlidingMenu的应用的截图</p>\n<p><img src=\"/image/android_demo.png\" alt=\"demo\"></p>\n<h1 id=\"使用方法\">使用方法</h1>\n<h2 id=\"SlidingMenu常用属性设置\">SlidingMenu常用属性设置</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">menu.setMode(SlidingMenu.LEFT);<span class=\"comment\">//设置左滑菜单</span></div><div class=\"line\">menu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);<span class=\"comment\">//设置滑动的屏幕范围，该设置为全屏区域都可以滑动</span></div><div class=\"line\">menu.setShadowDrawable(R.drawable.shadow);<span class=\"comment\">//设置阴影图片</span></div><div class=\"line\">menu.setShadowWidthRes(R.dimen.shadow_width);<span class=\"comment\">//设置阴影图片的宽度</span></div><div class=\"line\">menu.setBehindOffsetRes(R.dimen.slidingmenu_offset);<span class=\"comment\">//SlidingMenu划出时主页面显示的剩余宽度</span></div><div class=\"line\">menu.setBehindWidth(<span class=\"number\">400</span>);<span class=\"comment\">//设置SlidingMenu菜单的宽度</span></div><div class=\"line\">menu.setFadeDegree(<span class=\"number\">0.35</span>f);<span class=\"comment\">//SlidingMenu滑动时的渐变程度</span></div><div class=\"line\">menu.attachToActivity(<span class=\"keyword\">this</span>, SlidingMenu.SLIDING_CONTENT);<span class=\"comment\">//使SlidingMenu附加在Activity上</span></div><div class=\"line\">menu.setMenu(R.layout.menu_layout);<span class=\"comment\">//设置menu的布局文件</span></div><div class=\"line\">menu.toggle();<span class=\"comment\">//动态判断自动关闭或开启SlidingMenu</span></div><div class=\"line\">menu.showMenu();<span class=\"comment\">//显示SlidingMenu</span></div><div class=\"line\">menu.showContent();<span class=\"comment\">//显示内容</span></div><div class=\"line\">menu.setOnOpenListener(onOpenListener);<span class=\"comment\">//监听slidingmenu打开</span></div><div class=\"line\"><span class=\"comment\">//关于关闭menu有两个监听，简单的来说，对于menu close事件，一个是when,一个是after</span></div><div class=\"line\">menu.OnClosedListener(OnClosedListener);<span class=\"comment\">//监听slidingmenu关闭时事件</span></div><div class=\"line\">menu.OnClosedListener(OnClosedListener);<span class=\"comment\">//监听slidingmenu关闭后事件</span></div><div class=\"line\"><span class=\"comment\">//左右都可以划出SlidingMenu菜单只需要设置</span></div><div class=\"line\">menu.setMode(SlidingMenu.LEFT_RIGHT);属性，然后设置右侧菜单的布局文件</div><div class=\"line\">menu.setSecondaryShadowDrawable(R.drawable.shadowright);<span class=\"comment\">//右侧菜单的阴影图片</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"使用Fragment实现SlidingMenu:\">使用Fragment实现SlidingMenu:</h2>\n<ol>\n<li>首先Activity继承自SlidingMenu包下的SlidingFragmentActivity</li>\n<li>setContentView(R.layout.content_frame);//该layout为一个全屏的FrameLayout</li>\n<li>setBehindContentView(R.layout.menu_frame);//设置SlidingMenu使用的布局，同样是一个全屏的FrameLayout</li>\n<li>设置SlidingMenu左侧菜单的Fragment</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">setBehindContentView(R.layout.menu_frame);</div><div class=\"line\">FragmentTransaction t = <span class=\"keyword\">this</span>.getSupportFragmentManager().beginTransaction();  </div><div class=\"line\">leftMenuFragment = <span class=\"keyword\">new</span> MenuFragment();  </div><div class=\"line\">t.replace(R.id.menu_frame, leftMenuFragment);  </div><div class=\"line\">t.commit();</div></pre></td></tr></table></figure>\n\n<p>MenuFragment其实就是一个Fragment，显示一个ListView<br>然后点击ListView的每一项的时候，通知Activity切换不同的Fragment为了看清效果，我们新建5个Frament，分别是Fragment1, Fragment2, Fragment3, Fragment4, Fragment5,在SlidingMenu中用ListView显示。</p>\n<p>设置主页面显示的Fragment:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (savedInstanceState == <span class=\"keyword\">null</span>) {<span class=\"comment\">//== null的时候新建Fragment1  </span></div><div class=\"line\">contentFragment = <span class=\"keyword\">new</span> Fragment1();  </div><div class=\"line\">} <span class=\"keyword\">else</span> {<span class=\"comment\">//不等于null，直接get出来  </span></div><div class=\"line\"><span class=\"comment\">//不等于null，找出之前保存的当前Activity显示的Fragment  </span></div><div class=\"line\">contentFragment = getSupportFragmentManager().getFragment(savedInstanceState, <span class=\"string\">\"contentFragment\"</span>);  </div><div class=\"line\">}  </div><div class=\"line\"><span class=\"comment\">//设置内容Fragment  </span></div><div class=\"line\">getSupportFragmentManager()  </div><div class=\"line\">.beginTransaction()  </div><div class=\"line\">.replace(R.id.content_frame, contentFragment)  </div><div class=\"line\">.commit();</div></pre></td></tr></table></figure>\n\n<p>在Activity的onSaveInstanceState中保存当前显示的Fragment<br>getSupportFragmentManager().putFragment(outState, “contentFragment”, contentFragment);</p>\n<h2 id=\"设置ActionBar可以被点击\">设置ActionBar可以被点击</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">getSupportActionBar().setHomeButtonEnabled(<span class=\"keyword\">true</span>);<span class=\"comment\">//actionbar主按键可以被点击</span></div><div class=\"line\">getSupportActionBar().setDisplayHomeAsUpEnabled(<span class=\"keyword\">true</span>);<span class=\"comment\">//显示向左的图标</span></div><div class=\"line\">setSlidingActionBarEnabled(<span class=\"keyword\">false</span>);<span class=\"comment\">//左右两侧slidingmenu的fragment是否显示标题栏</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"切换主页面显示的Fragment\">切换主页面显示的Fragment</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">switchContent</span>(Fragment f) {</div><div class=\"line\"><span class=\"comment\">//给内容Fragment赋值，并在onSaveInstanceState时保存这个Fragment</span></div><div class=\"line\">contentFragment = f;</div><div class=\"line\">FragmentTransaction  t = getSupportFragmentManager().beginTransaction();</div><div class=\"line\">t.replace(R.id.content_frame, f);</div><div class=\"line\">t.commit();</div><div class=\"line\">sm.showContent();</div></pre></td></tr></table></figure>\n\n<h2 id=\"使用普通Activity实现SlidingMenu\">使用普通Activity实现SlidingMenu</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">slidingMenu menu = <span class=\"keyword\">new</span> SlidingMenu(<span class=\"keyword\">this</span>);<span class=\"comment\">//直接new，而不是getSlidingMenu  </span></div><div class=\"line\">menu.setMode(SlidingMenu.LEFT);  </div><div class=\"line\">menu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);  </div><div class=\"line\">menu.setShadowDrawable(R.drawable.shadow);  </div><div class=\"line\">menu.setShadowWidthRes(R.dimen.shadow_width);  </div><div class=\"line\">menu.setBehindOffsetRes(R.dimen.slidingmenu_offset);  </div><div class=\"line\">menu.setBehindWidth(<span class=\"number\">400</span>);<span class=\"comment\">//设置SlidingMenu菜单的宽度  </span></div><div class=\"line\">menu.setFadeDegree(<span class=\"number\">0.35</span>f);  </div><div class=\"line\">menu.attachToActivity(<span class=\"keyword\">this</span>, SlidingMenu.SLIDING_CONTENT);<span class=\"comment\">//必须调用  </span></div><div class=\"line\">menu.setMenu(R.layout.menu_layout_left);<span class=\"comment\">//就是普通的layout布局  </span></div><div class=\"line\">menu.setBehindCanvasTransformer(mTransformer);</div></pre></td></tr></table></figure>\n\n<blockquote>\n<p>相应SlidingMenu里的点击事件，因为SlidingMenu已经被包含在了Activity中了，所以直接findViewById(id),拿到view之后就可以进行相应的处理。</p>\n</blockquote>\n<h2 id=\"更换SlidingMenu的动画\">更换SlidingMenu的动画</h2>\n<p>SlidingMenu支持左滑或者右滑时定义不同的动画，包括拉伸，缩放，旋转等动画。就是在滑动的过程中，SlidingMenu如何出现的动画。<br>动画使用也很简单</p>\n<p>首先定义CanvasTransformer mTransformer变量:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">mTransformer = <span class=\"keyword\">new</span> CanvasTransformer() {  </div><div class=\"line\"><span class=\"annotation\">@Override</span>  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transformCanvas</span>(Canvas canvas, <span class=\"keyword\">float</span> percentOpen) {  </div><div class=\"line\">    <span class=\"keyword\">float</span> scale = (<span class=\"keyword\">float</span>) (percentOpen*<span class=\"number\">0.25</span> + <span class=\"number\">0.75</span>);  </div><div class=\"line\">    canvas.scale(scale, scale, canvas.getWidth()/<span class=\"number\">2</span>, canvas.getHeight()/<span class=\"number\">2</span>);  </div><div class=\"line\">    }  </div><div class=\"line\">};</div></pre></td></tr></table></figure>\n\n<p>然后将mTransformer对象设置给SlidingMenu即可，这个是缩放动画:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initSlidUpCanvasTransformer</span>() {  </div><div class=\"line\">    mTransformer = <span class=\"keyword\">new</span> CanvasTransformer() {  </div><div class=\"line\">    <span class=\"annotation\">@Override</span>  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transformCanvas</span>(Canvas canvas, <span class=\"keyword\">float</span> percentOpen) {  </div><div class=\"line\">        canvas.translate(<span class=\"number\">0</span>, canvas.getHeight()*(<span class=\"number\">1</span>-interp.getInterpolation(percentOpen)));  </div><div class=\"line\">    }};  </div><div class=\"line\">}  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Interpolator interp = <span class=\"keyword\">new</span> Interpolator() {  </div><div class=\"line\">    <span class=\"annotation\">@Override</span>  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getInterpolation</span>(<span class=\"keyword\">float</span> t) {  </div><div class=\"line\">    t -= <span class=\"number\">1.0</span>f;  </div><div class=\"line\">    <span class=\"keyword\">return</span> t * t * t + <span class=\"number\">1.0</span>f;  </div><div class=\"line\">    }  </div><div class=\"line\">};</div></pre></td></tr></table></figure>\n\n<h2 id=\"拉伸动画:\">拉伸动画:</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">mTransformer = <span class=\"keyword\">new</span> CanvasTransformer() {  </div><div class=\"line\">    <span class=\"annotation\">@Override</span>  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transformCanvas</span>(Canvas canvas, <span class=\"keyword\">float</span> percentOpen) {  </div><div class=\"line\">    canvas.scale(percentOpen, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  </div><div class=\"line\">    }  </div><div class=\"line\">});</div></pre></td></tr></table></figure>\n\n<h1 id=\"参考链接\">参考链接</h1>\n<p><a href=\"http://boroniatechnologies.com/installing-slidingmenu-android-library-and-example/\" target=\"_blank\" rel=\"external\">Installing SlidingMenu Android library and example</a></p>\n<p><a href=\"http://blog.csdn.net/t12x3456/article/details/12798157\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/t12x3456/article/details/12798157</a></p>\n","source":"_posts/Android侧拉菜单SlidingMenu的配置和使用.md","raw":"title: Android侧拉菜单SlidingMenu的配置和使用\ndate: 2014-09-25 18:17:00\ncategories: android\ntags: [android,SlidingMenu,ActionBarSherlock,侧拉菜单,UI]\ndesctiption: 使用开源项目SlidingMenu侧拉菜单\n\n---\n\n![demo]({{BASE_PATH}}/image/demo.gif)\n\n#前言\n很多**android菜单**都做的很炫，其中用的做多的就数**侧拉菜单**了，比如说唱吧，以前的人人，当然也有很多客户端改版后可能用其他的了，但是**SlidingMenu**的确是一个很强大的工具。\n\n<!--more-->\n\n#环境配置\n很多工具有炫丽的效果来吸引用户的眼球，但是这些炫丽的效果肯定需要一些代价，那就是很多代码的支持，这个项目页不例外，在配置环境时很有可能会遇到一系列问题，下面就写一下具体**配置的步骤**和**可能遇到的问题**。\n\n##准备工作\n- 首先去网上下载相应的依赖工程，这里主要下载在**github**上面的两个项目，一个是[**SlidingMenu**](https://github.com/jfeinstein10/SlidingMenu)，另外一个是[**ActionBarSherlock**](https://github.com/JakeWharton/ActionBarSherlock)。把这两个工程导入eclipse，其中在SlidingMenu导入eclipse后可以得到两个项目，一个是**exampleListActivity**，另外一个是**library**，这个library是作为前面一个工程的依赖包的。\n- 具体如何将一个项目作为另一个项目的依赖呢？可以右击这个项目，然后选择属性，在android那一栏有一个**is Library**选项，勾选以后这个项目就能作为其他项目的依赖了。\n- 然后将下载的**ActionBarSherlock**这个工程也添加到eclipse中来，将添加进来的工程也配置成一个**Library**，然后在**exampleListActivity**中添加这个依赖。\n\n##依赖和版本统一\n- 如果你的各个导入的项目的**API等级**不同的话在加载的时候就会报错，因此这时候最好将每个导入的文件的API等级换成一样的就行了。\n- 如果你的各个导入的项目的**android-support-v4.jar**的版本不同的话也会报错，这时就需要手动将各个版本的jar包换成统一的。\n\n##修改代码\n- 打开在**Library**项目中的**SlidingFragmentActivity**这个类，并且添加以下的代码来声明这个类\n\n```java\nimport com.actionbarsherlock.app.SherlockFragmentActivity;\n```\n- 然后进行替换代码，将这个文件内的\n\n```java\nclass SlidingFragmentActivity extends FragmentActivity implements SlidingActivityBase\n```\n- 替换成下面这行\n\n```java\npublic class SlidingFragmentActivity extends SherlockFragmentActivity implements SlidingActivityBase\n```\n\n##测试\n如果不出意外的话，现在就可以运行侧拉菜单的示例程序了，示例程序只是一个大体的轮廓，具体的配置需要你手动去调整，下面这幅图就是一个使用SlidingMenu的应用的截图\n\n![demo]({{BASE_PATH}}/image/android_demo.png)\n\n\n#使用方法\n\n##SlidingMenu常用属性设置\n```java\nmenu.setMode(SlidingMenu.LEFT);//设置左滑菜单\nmenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);//设置滑动的屏幕范围，该设置为全屏区域都可以滑动\nmenu.setShadowDrawable(R.drawable.shadow);//设置阴影图片\nmenu.setShadowWidthRes(R.dimen.shadow_width);//设置阴影图片的宽度\nmenu.setBehindOffsetRes(R.dimen.slidingmenu_offset);//SlidingMenu划出时主页面显示的剩余宽度\nmenu.setBehindWidth(400);//设置SlidingMenu菜单的宽度\nmenu.setFadeDegree(0.35f);//SlidingMenu滑动时的渐变程度\nmenu.attachToActivity(this, SlidingMenu.SLIDING_CONTENT);//使SlidingMenu附加在Activity上\nmenu.setMenu(R.layout.menu_layout);//设置menu的布局文件\nmenu.toggle();//动态判断自动关闭或开启SlidingMenu\nmenu.showMenu();//显示SlidingMenu\nmenu.showContent();//显示内容\nmenu.setOnOpenListener(onOpenListener);//监听slidingmenu打开\n//关于关闭menu有两个监听，简单的来说，对于menu close事件，一个是when,一个是after\nmenu.OnClosedListener(OnClosedListener);//监听slidingmenu关闭时事件\nmenu.OnClosedListener(OnClosedListener);//监听slidingmenu关闭后事件\n//左右都可以划出SlidingMenu菜单只需要设置\nmenu.setMode(SlidingMenu.LEFT_RIGHT);属性，然后设置右侧菜单的布局文件\nmenu.setSecondaryShadowDrawable(R.drawable.shadowright);//右侧菜单的阴影图片\n```\n\n##使用Fragment实现SlidingMenu:   \n1. 首先Activity继承自SlidingMenu包下的SlidingFragmentActivity\n2. setContentView(R.layout.content_frame);//该layout为一个全屏的FrameLayout\n3. setBehindContentView(R.layout.menu_frame);//设置SlidingMenu使用的布局，同样是一个全屏的FrameLayout\n4. 设置SlidingMenu左侧菜单的Fragment\n\n```java\nsetBehindContentView(R.layout.menu_frame);\nFragmentTransaction t = this.getSupportFragmentManager().beginTransaction();  \nleftMenuFragment = new MenuFragment();  \nt.replace(R.id.menu_frame, leftMenuFragment);  \nt.commit();  \n```\n\nMenuFragment其实就是一个Fragment，显示一个ListView\n然后点击ListView的每一项的时候，通知Activity切换不同的Fragment为了看清效果，我们新建5个Frament，分别是Fragment1, Fragment2, Fragment3, Fragment4, Fragment5,在SlidingMenu中用ListView显示。\n\n设置主页面显示的Fragment:\n```java\nif (savedInstanceState == null) {//== null的时候新建Fragment1  \ncontentFragment = new Fragment1();  \n} else {//不等于null，直接get出来  \n//不等于null，找出之前保存的当前Activity显示的Fragment  \ncontentFragment = getSupportFragmentManager().getFragment(savedInstanceState, \"contentFragment\");  \n}  \n//设置内容Fragment  \ngetSupportFragmentManager()  \n.beginTransaction()  \n.replace(R.id.content_frame, contentFragment)  \n.commit();  \n```\n\n在Activity的onSaveInstanceState中保存当前显示的Fragment\ngetSupportFragmentManager().putFragment(outState, \"contentFragment\", contentFragment);\n\n##设置ActionBar可以被点击\n```java\ngetSupportActionBar().setHomeButtonEnabled(true);//actionbar主按键可以被点击\ngetSupportActionBar().setDisplayHomeAsUpEnabled(true);//显示向左的图标\nsetSlidingActionBarEnabled(false);//左右两侧slidingmenu的fragment是否显示标题栏\n```\n\n##切换主页面显示的Fragment\n```java\npublic void switchContent(Fragment f) {\n//给内容Fragment赋值，并在onSaveInstanceState时保存这个Fragment\ncontentFragment = f;\nFragmentTransaction  t = getSupportFragmentManager().beginTransaction();\nt.replace(R.id.content_frame, f);\nt.commit();\nsm.showContent();\n```\n\n##使用普通Activity实现SlidingMenu\n```java\nslidingMenu menu = new SlidingMenu(this);//直接new，而不是getSlidingMenu  \nmenu.setMode(SlidingMenu.LEFT);  \nmenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);  \nmenu.setShadowDrawable(R.drawable.shadow);  \nmenu.setShadowWidthRes(R.dimen.shadow_width);  \nmenu.setBehindOffsetRes(R.dimen.slidingmenu_offset);  \nmenu.setBehindWidth(400);//设置SlidingMenu菜单的宽度  \nmenu.setFadeDegree(0.35f);  \nmenu.attachToActivity(this, SlidingMenu.SLIDING_CONTENT);//必须调用  \nmenu.setMenu(R.layout.menu_layout_left);//就是普通的layout布局  \nmenu.setBehindCanvasTransformer(mTransformer);  \n```\n>相应SlidingMenu里的点击事件，因为SlidingMenu已经被包含在了Activity中了，所以直接findViewById(id),拿到view之后就可以进行相应的处理。\n\n##更换SlidingMenu的动画\nSlidingMenu支持左滑或者右滑时定义不同的动画，包括拉伸，缩放，旋转等动画。就是在滑动的过程中，SlidingMenu如何出现的动画。\n动画使用也很简单\n\n首先定义CanvasTransformer mTransformer变量:\n```java\nmTransformer = new CanvasTransformer() {  \n@Override  \npublic void transformCanvas(Canvas canvas, float percentOpen) {  \n    float scale = (float) (percentOpen*0.25 + 0.75);  \n    canvas.scale(scale, scale, canvas.getWidth()/2, canvas.getHeight()/2);  \n    }  \n};  \n```\n然后将mTransformer对象设置给SlidingMenu即可，这个是缩放动画:\n```java\nprivate void initSlidUpCanvasTransformer() {  \n    mTransformer = new CanvasTransformer() {  \n    @Override  \n    public void transformCanvas(Canvas canvas, float percentOpen) {  \n        canvas.translate(0, canvas.getHeight()*(1-interp.getInterpolation(percentOpen)));  \n    }};  \n}  \n  \nprivate static Interpolator interp = new Interpolator() {  \n    @Override  \n    public float getInterpolation(float t) {  \n    t -= 1.0f;  \n    return t * t * t + 1.0f;  \n    }  \n};  \n```\n##拉伸动画:\n```java\nmTransformer = new CanvasTransformer() {  \n    @Override  \n    public void transformCanvas(Canvas canvas, float percentOpen) {  \n    canvas.scale(percentOpen, 1, 0, 0);  \n    }  \n});  \n```\n\n#参考链接\n[Installing SlidingMenu Android library and example](http://boroniatechnologies.com/installing-slidingmenu-android-library-and-example/)\n\nhttp://blog.csdn.net/t12x3456/article/details/12798157","slug":"Android侧拉菜单SlidingMenu的配置和使用","updated":1429716514000,"excerpt":"<p><img src=\"/image/demo.gif\" alt=\"demo\"></p>\n<h1 id=\"前言\">前言</h1>\n<p>很多<strong>android菜单</strong>都做的很炫，其中用的做多的就数<strong>侧拉菜单</strong>了，比如说唱吧，以前的人人，当然也有很多客户端改版后可能用其他的了，但是<strong>SlidingMenu</strong>的确是一个很强大的工具。</p>\n","_id":"yg1dltd0yhkyzxla","comments":true,"layout":"post","photos":[],"link":""},{"title":"android 编译调用C代码","date":1413986040000,"categories":["pmcyb6oshop5size"],"tags":["hf98yxietusc8sh7","sujnqa2jr6usmcos","2drwjavwcpb3394k","3zgjfof27f9p3nm9"],"desctiption":"在android平台执行由C编译出来的可执行文件","content":"<h1 id=\"前言\">前言</h1>\n<h2 id=\"需求来源\">需求来源</h2>\n<p>这几天帮别人做一个简单的android客户端，也没什么功能，主要就是调用C代码来对手机的Wifi网络进行设置，于是也就引出了技术难点所在，如何去调用<strong>C程序</strong>达到我们所需要的效果。</p>\n<h2 id=\"解决方案\">解决方案</h2>\n<p>对于这个，我想出了两种解决方案：</p>\n<p><a id=\"more\"></a></p>\n<ol>\n<li><p>第一种方案是利用<a href=\"http://baike.baidu.com/view/1272329.htm?fr=aladdin\" target=\"_blank\" rel=\"external\"><strong>JNI</strong></a>来进行本地调用。关于什么是JNI呢，JNI其实是<strong>Java Native Interface</strong>的简称，也就是java本地接口，它提供了若干API实现了java和其他语言的通信（主要是C和C++）。</p>\n</li>\n<li><p>第二种方法是将要执行的C代码编译成<strong>可执行文件</strong>，然后将这个可执行文件和程序一起打包成APK，在需要使用的时候调用这个可执行文件。</p>\n</li>\n</ol>\n<h2 id=\"最终选择\">最终选择</h2>\n<p>最后我选择了第二种方案，理由是第二种方法在我已经有了可执行文件的条件下总体来说比较简单，可操作性强。而第一种方案的话因为还要下载android的<a href=\"http://www.cnblogs.com/devinzhang/archive/2012/02/29/2373729.html\" target=\"_blank\" rel=\"external\">NDK</a>，NDK是一系列工具的集合，提供了帮助开发者快速开发C或则C++的动态库，并能自动将so和java应用一起打包成apk，十分方便。</p>\n<h1 id=\"技术实现\">技术实现</h1>\n<h2 id=\"可执行文件\">可执行文件</h2>\n<p>首先需要得到一个可执行文件，当然想要的到可执行文件并不是想象中的那么简单，不是在linux中直接<strong>gcc</strong>就能到的，这里需要对C代码进行<a href=\"http://baike.baidu.com/view/650389.htm?fr=aladdin\" target=\"_blank\" rel=\"external\"><strong>交叉编译</strong></a>获得可以在android机子上运行的可执行文件，具体如何对C文件进行交叉编译，这里就不再赘述，大家可以上网查找一下。另外，NDK也是个不错的工具。</p>\n<h2 id=\"资源存储\">资源存储</h2>\n<p>这里的资源存储页算是个小坑，平常我们在写java程序的时候，如果要打开一个文件的话就直接输入路径，比如如果所要使用的文件就在项目的目录下，直接输入文件名就可以调用了，但是这里的运行环境是嵌入式设备，不是PC，这就涉及到一个问题，资源如何存储了。</p>\n<p>这里先谈一下Android中的<strong>asset文件夹</strong>和<strong>res/raw文件夹</strong>的异同：</p>\n<ul>\n<li>相同点<ul>\n<li>两者目录下的文件在打包后都会<strong>原封不动</strong>的保存在apk包中，不会被编译成二进制。</li>\n</ul>\n</li>\n<li>不同点<ul>\n<li>res/raw中的文件会被映射到R.java中，访问的时候直接使用资源ID即可，而assets文件夹下的文件不会被映射到R.java。</li>\n<li>res/raw不可以有<strong>目录结构</strong>，而assets目录下可以再建立文件夹。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"资源获取\">资源获取</h2>\n<p>这里顺带说一下<strong>res/raw</strong>下的文件资源的读取方法，通过以下方式获取输入流来进行写操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">InputStream is =getResources().openRawResource(R.id.filename);</div></pre></td></tr></table></figure>\n\n<p>接下来才是我用到的读取<strong>assets</strong>下的方法，同样也是通过获取输入流的方式来进行写操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">AssetManager am = <span class=\"keyword\">null</span>; </div><div class=\"line\">am = getAssets(); </div><div class=\"line\">InputStream is = am.open(<span class=\"string\">\"filename\"</span>);</div></pre></td></tr></table></figure>\n\n<p><strong>注意点：</strong>据说Assert只能放单个文件不超过<strong>1M</strong>的文件，但是不是真的具体还没考证过，如果碰到问题了应该考虑一下这个注意点。</p>\n<p>虽然读取是成功了，但是要用<strong>shell</strong>脚本执行的话，应该在手机的存储上应该有这个文件，光是读取的话在手机里面是找不见的，所以我们需要一个存文件的操作。这里我写了一个存文件的函数，其中将获取assets中数据的方法也结合进去了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">copyDataToSD</span>(String outFileName)<span class=\"keyword\">throws</span> IOException</div><div class=\"line\">{</div><div class=\"line\">\tInputStream myInputStream;</div><div class=\"line\">\tOutputStream myOutputStream = <span class=\"keyword\">new</span> FileOutputStream(outFileName);</div><div class=\"line\">\tmyInputStream = <span class=\"keyword\">this</span>.getAssets().open(<span class=\"string\">\"a.out\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</div><div class=\"line\">\t<span class=\"keyword\">int</span> length = myInputStream.read(buffer);</div><div class=\"line\">\t<span class=\"keyword\">while</span> (length &gt; <span class=\"number\">0</span>) {</div><div class=\"line\">\t\tmyOutputStream.write(buffer, <span class=\"number\">0</span>, length);</div><div class=\"line\">\t\tlength = myInputStream.read(buffer);</div><div class=\"line\">\t}</div><div class=\"line\">\tmyOutputStream.flush();</div><div class=\"line\">\tmyInputStream.close();</div><div class=\"line\">\tmyOutputStream.close();</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>然后我定义的传入的outFileName是定义的文件路径加文件名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String EXE_PATH = <span class=\"string\">\"data/data/com.example.g3wifi/a.out\"</span>;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> File exe_file;</div></pre></td></tr></table></figure>\n\n<h2 id=\"shell命令执行\">shell命令执行</h2>\n<p>到这里的话就是“万事俱备，只欠东风”了，我们需要执行所得到的可执行文件，因为android是基于<strong>linux</strong>的，所以一些基本的命令还是支持的，在android中要执行shell命令的话就按如下格式即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">exeC</span>(String cmd)<span class=\"keyword\">throws</span> IOException</div><div class=\"line\">{</div><div class=\"line\">\tRuntime runtime =Runtime.getRuntime();</div><div class=\"line\">\tProcess process = runtime.exec(cmd);</div><div class=\"line\">    <span class=\"comment\">//Process process = runtime.exec(new String[]{\"su\",\"reboot\"});//可以执行两条命令</span></div><div class=\"line\">    <span class=\"comment\">//这可以得到执行shell命令后的结果</span></div><div class=\"line\">    BufferedReader ie = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(process.getErrorStream()));</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n","source":"_posts/Android编译执行C代码.md","raw":"title: android 编译调用C代码\ndate: 2014-10-22 21:54:00\ncategories: android\ntags: [android,交叉编译,C,assets]\ndesctiption: 在android平台执行由C编译出来的可执行文件\n\n---\n\n#前言\n##需求来源\n这几天帮别人做一个简单的android客户端，也没什么功能，主要就是调用C代码来对手机的Wifi网络进行设置，于是也就引出了技术难点所在，如何去调用**C程序**达到我们所需要的效果。\n\n##解决方案\n对于这个，我想出了两种解决方案：\n\n<!--  more -->\n1. 第一种方案是利用[**JNI**](http://baike.baidu.com/view/1272329.htm?fr=aladdin)来进行本地调用。关于什么是JNI呢，JNI其实是**Java Native Interface**的简称，也就是java本地接口，它提供了若干API实现了java和其他语言的通信（主要是C和C++）。\n\n2. 第二种方法是将要执行的C代码编译成**可执行文件**，然后将这个可执行文件和程序一起打包成APK，在需要使用的时候调用这个可执行文件。\n\n##最终选择\n最后我选择了第二种方案，理由是第二种方法在我已经有了可执行文件的条件下总体来说比较简单，可操作性强。而第一种方案的话因为还要下载android的[NDK](http://www.cnblogs.com/devinzhang/archive/2012/02/29/2373729.html)，NDK是一系列工具的集合，提供了帮助开发者快速开发C或则C++的动态库，并能自动将so和java应用一起打包成apk，十分方便。\n\n#技术实现\n\n##可执行文件\n首先需要得到一个可执行文件，当然想要的到可执行文件并不是想象中的那么简单，不是在linux中直接**gcc**就能到的，这里需要对C代码进行[**交叉编译**](http://baike.baidu.com/view/650389.htm?fr=aladdin)获得可以在android机子上运行的可执行文件，具体如何对C文件进行交叉编译，这里就不再赘述，大家可以上网查找一下。另外，NDK也是个不错的工具。\n\n##资源存储\n这里的资源存储页算是个小坑，平常我们在写java程序的时候，如果要打开一个文件的话就直接输入路径，比如如果所要使用的文件就在项目的目录下，直接输入文件名就可以调用了，但是这里的运行环境是嵌入式设备，不是PC，这就涉及到一个问题，资源如何存储了。\n\n\n这里先谈一下Android中的**asset文件夹**和**res/raw文件夹**的异同：\n\n- 相同点\n    - 两者目录下的文件在打包后都会**原封不动**的保存在apk包中，不会被编译成二进制。\n- 不同点\n    - res/raw中的文件会被映射到R.java中，访问的时候直接使用资源ID即可，而assets文件夹下的文件不会被映射到R.java。\n    - res/raw不可以有**目录结构**，而assets目录下可以再建立文件夹。\n\n\n##资源获取\n这里顺带说一下**res/raw**下的文件资源的读取方法，通过以下方式获取输入流来进行写操作\n```java\nInputStream is =getResources().openRawResource(R.id.filename);  \n```\n\n接下来才是我用到的读取**assets**下的方法，同样也是通过获取输入流的方式来进行写操作\n```java\nAssetManager am = null; \nam = getAssets(); \nInputStream is = am.open(\"filename\");  \n\n```\n**注意点：**据说Assert只能放单个文件不超过**1M**的文件，但是不是真的具体还没考证过，如果碰到问题了应该考虑一下这个注意点。\n\n虽然读取是成功了，但是要用**shell**脚本执行的话，应该在手机的存储上应该有这个文件，光是读取的话在手机里面是找不见的，所以我们需要一个存文件的操作。这里我写了一个存文件的函数，其中将获取assets中数据的方法也结合进去了。\n```java\npublic  void copyDataToSD(String outFileName)throws IOException\n{\n\tInputStream myInputStream;\n\tOutputStream myOutputStream = new FileOutputStream(outFileName);\n\tmyInputStream = this.getAssets().open(\"a.out\");\n\tbyte[] buffer = new byte[1024];\n\tint length = myInputStream.read(buffer);\n\twhile (length > 0) {\n\t\tmyOutputStream.write(buffer, 0, length);\n\t\tlength = myInputStream.read(buffer);\n\t}\n\tmyOutputStream.flush();\n\tmyInputStream.close();\n\tmyOutputStream.close();\n}\n```\n然后我定义的传入的outFileName是定义的文件路径加文件名\n```java\nprivate static String EXE_PATH = \"data/data/com.example.g3wifi/a.out\";\nprivate static File exe_file;\n```\n\n##shell命令执行\n到这里的话就是“万事俱备，只欠东风”了，我们需要执行所得到的可执行文件，因为android是基于**linux**的，所以一些基本的命令还是支持的，在android中要执行shell命令的话就按如下格式即可：\n```java\npublic  void exeC(String cmd)throws IOException\n{\n\tRuntime runtime =Runtime.getRuntime();\n\tProcess process = runtime.exec(cmd);\n    //Process process = runtime.exec(new String[]{\"su\",\"reboot\"});//可以执行两条命令\n    //这可以得到执行shell命令后的结果\n    BufferedReader ie = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n}\n```\n","slug":"Android编译执行C代码","updated":1413992768000,"excerpt":"<h1 id=\"前言\">前言</h1>\n<h2 id=\"需求来源\">需求来源</h2>\n<p>这几天帮别人做一个简单的android客户端，也没什么功能，主要就是调用C代码来对手机的Wifi网络进行设置，于是也就引出了技术难点所在，如何去调用<strong>C程序</strong>达到我们所需要的效果。</p>\n<h2 id=\"解决方案\">解决方案</h2>\n<p>对于这个，我想出了两种解决方案：</p>\n<p>","_id":"qiq6o8fv4kkxvp59","comments":true,"layout":"post","photos":[],"link":""},{"title":"Android自定义ActionBar","date":1429716420000,"categories":["pmcyb6oshop5size"],"tags":["hf98yxietusc8sh7","smya40ac1smcpulm","bmdj4v9n7r7bxuzf"],"desctiption":"Android自定义ActionBar","content":"<h2 id=\"简介\">简介</h2>\n<p>Action Bar是一种新增的导航栏功能，在Android 3.0以后加入到系统的API中，它标识了用户当前操作界面的位置，并提供了额外的用户动作，界面导航等功能。</p>\n<h2 id=\"优点\">优点</h2>\n<p>它提供了一种全局统一的UI界面，使得用户在使用任何一款软件时都懂得如何操作，并且ActionBar还可以自动适应各种不同大小的屏幕。<br>一般action提供了图标及overflow按钮。overflow按钮可以在actionbar中的组件放不下时收回overflow中，当让，也可以手动指定哪些不被收入overflow中。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"修改ActionBar\">修改ActionBar</h2>\n<p>详细的修改ActionBar中的图标，标题，添加按钮等操作见官方API，也可以看这一篇<a href=\"http://blog.csdn.net/yuzhiboyi/article/details/32709833\" target=\"_blank\" rel=\"external\">博客</a>，觉得写的挺不错的。里面几乎将官方网站关于ActionBar的内容全部解释了一遍。</p>\n<h2 id=\"自定义ActionBar\">自定义ActionBar</h2>\n<p>在用ActionBar时我总觉得按照官网上的修改方法太过于复杂麻烦，还不利于个性化。让人头疼。后来发现有一种方式能方便快捷的使用自己定义的ActionBar</p>\n<h3 id=\"创建样式文件\">创建样式文件</h3>\n<ul>\n<li>在values文件夹中创建一个theme.xml文件，里面定义自己的样式文件如下:</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">resources</span> <span class=\"attribute\">xmlns:android</span>=<span class=\"value\">\"http://schemas.android.com/apk/res/android\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">&lt;!-- ActionBar样式 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"title\">style</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"MyActionBar\"</span> <span class=\"attribute\">parent</span>=<span class=\"value\">\"android:Theme.Light\"</span>&gt;</span><span class=\"css\"></span></div><div class=\"line\">        &lt;<span class=\"tag\">item</span> <span class=\"tag\">name</span>=\"<span class=\"tag\">android</span><span class=\"pseudo\">:windowTitleSize\"</span>&gt;46<span class=\"tag\">dip</span>&lt;/<span class=\"tag\">item</span>&gt;</div><div class=\"line\">        &lt;<span class=\"tag\">item</span> <span class=\"tag\">name</span>=\"<span class=\"tag\">android</span><span class=\"pseudo\">:windowTitleBackgroundStyle\"</span>&gt;<span class=\"at_rule\">@<span class=\"keyword\">style/myActionBarBackground&lt;/item&gt;</span></span></div><div class=\"line\">        &lt;item name=<span class=\"string\">\"android:windowBackground\"</span>&gt;@color/white&lt;/item&gt;</div><div class=\"line\">    \t&lt;item name=<span class=\"string\">\"android:textColor\"</span>&gt;@color/white&lt;/item&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"title\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">resources</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<ul>\n<li>再在styles.xml文件中加入引用的样式:</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">style</span> <span class=\"attribute\">name</span> = \"<span class=\"attribute\">myActionBarBackground</span>\"&gt;</span><span class=\"css\"></span></div><div class=\"line\">        &lt;<span class=\"tag\">item</span> <span class=\"tag\">name</span>=\"<span class=\"tag\">android</span><span class=\"pseudo\">:background\"</span>&gt;<span class=\"at_rule\">@<span class=\"keyword\">color/this.green&lt;/item&gt;</span></span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h3 id=\"在系统中应用主题\">在系统中应用主题</h3>\n<ul>\n<li>然后在AndroidMainifest.xml文件中应用自己定义的xml:</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">application</span></span></div><div class=\"line\">        <span class=\"attribute\">android:allowBackup</span>=<span class=\"value\">\"true\"</span></div><div class=\"line\">        <span class=\"attribute\">android:icon</span>=<span class=\"value\">\"@drawable/ic_launcher\"</span></div><div class=\"line\">        <span class=\"attribute\">android:label</span>=<span class=\"value\">\"@string/app_name\"</span></div><div class=\"line\">        <span class=\"attribute\">android:theme</span>=<span class=\"value\">\"@style/MyActionBar\"</span> &gt;</div></pre></td></tr></table></figure>\n\n<ul>\n<li>这样，你自己定义的主题就产生了，里面包含你对ActionBar的一些配置。当然，现在还没有定制化自己的ActionBar，只是将主题中的颜色文字大小等风格制定了。要真正达到自定义的效果，还要自己写一个ActionBar的样式xml文件。我自己写的一个actionBar.xml文件如下：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"pi\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">RelativeLayout</span> <span class=\"attribute\">xmlns:android</span>=<span class=\"value\">\"http://schemas.android.com/apk/res/android\"</span></span></div><div class=\"line\">    <span class=\"attribute\">android:layout_width</span>=<span class=\"value\">\"fill_parent\"</span></div><div class=\"line\">    <span class=\"attribute\">android:layout_height</span>=<span class=\"value\">\"fill_parent\"</span> &gt;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"title\">Button</span></span></div><div class=\"line\">        <span class=\"attribute\">android:id</span>=<span class=\"value\">\"@+id/actionbar_back_button\"</span></div><div class=\"line\">        <span class=\"attribute\">android:layout_width</span>=<span class=\"value\">\"wrap_content\"</span></div><div class=\"line\">        <span class=\"attribute\">android:layout_height</span>=<span class=\"value\">\"wrap_content\"</span></div><div class=\"line\">        <span class=\"attribute\">android:layout_centerVertical</span>=<span class=\"value\">\"true\"</span></div><div class=\"line\">        <span class=\"attribute\">android:layout_alignParentLeft</span>=<span class=\"value\">\"true\"</span></div><div class=\"line\">        <span class=\"attribute\">android:background</span>=<span class=\"value\">\"@drawable/btn_back_normal\"</span>/&gt;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"title\">TextView</span></span></div><div class=\"line\">        <span class=\"attribute\">android:id</span>=<span class=\"value\">\"@+id/actionbar_title_textview\"</span></div><div class=\"line\">        <span class=\"attribute\">android:layout_width</span>=<span class=\"value\">\"wrap_content\"</span></div><div class=\"line\">        <span class=\"attribute\">android:layout_height</span>=<span class=\"value\">\"wrap_content\"</span></div><div class=\"line\">        <span class=\"attribute\">android:layout_centerInParent</span>=<span class=\"value\">\"true\"</span></div><div class=\"line\">        <span class=\"attribute\">android:text</span>=<span class=\"value\">\"title\"</span> /&gt;</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"title\">Button</span></span></div><div class=\"line\">        <span class=\"attribute\">android:id</span>=<span class=\"value\">\"@+id/actionbar_home_button\"</span></div><div class=\"line\">        <span class=\"attribute\">android:layout_width</span>=<span class=\"value\">\"wrap_content\"</span></div><div class=\"line\">        <span class=\"attribute\">android:layout_height</span>=<span class=\"value\">\"wrap_content\"</span></div><div class=\"line\">        <span class=\"attribute\">android:layout_centerVertical</span>=<span class=\"value\">\"true\"</span></div><div class=\"line\">        <span class=\"attribute\">android:layout_alignParentRight</span>=<span class=\"value\">\"true\"</span></div><div class=\"line\">        <span class=\"attribute\">android:background</span>=<span class=\"value\">\"@drawable/home\"</span> /&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<h3 id=\"在Activity中加载自定义ActionBar样式\">在Activity中加载自定义ActionBar样式</h3>\n<ul>\n<li>这里面定义了ActionBar中有两个按钮和一个标题文本。最后只要你在Activity中应用就可以显示你自己定义的ActionBar了,在Activity中的应用如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"annotation\">@Override</span></div><div class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span>(Bundle savedInstanceState) {</div><div class=\"line\">       <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">       </div><div class=\"line\">       requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);</div><div class=\"line\">       setContentView(R.layout.activity_login);</div><div class=\"line\">       getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.layout_actionbar);</div><div class=\"line\"></div><div class=\"line\">   }</div></pre></td></tr></table></figure>\n\n<ul>\n<li>最后就能显示出你自己定义的ActionBar了，对于里面的组件就像平常定义的组件一样使用即可。再上一张效果图，这里面我将左边和右边ActionBar的按钮设置为不可见了，所以只留了一个中间的登录文本显示框。</li>\n</ul>\n<p><img src=\"/image/ActionBar.png\" alt=\"ActionBar\"></p>\n","source":"_posts/Android自定义ActionBar.md","raw":"title: Android自定义ActionBar\ndate: 2015-04-22 23:27:00\ncategories: android\ntags: [android,actionBar,UI]\ndesctiption: Android自定义ActionBar\n\n---\n\n\n##简介\nAction Bar是一种新增的导航栏功能，在Android 3.0以后加入到系统的API中，它标识了用户当前操作界面的位置，并提供了额外的用户动作，界面导航等功能。\n\n##优点\n它提供了一种全局统一的UI界面，使得用户在使用任何一款软件时都懂得如何操作，并且ActionBar还可以自动适应各种不同大小的屏幕。\n一般action提供了图标及overflow按钮。overflow按钮可以在actionbar中的组件放不下时收回overflow中，当让，也可以手动指定哪些不被收入overflow中。\n\n<!--more-->\n\n##修改ActionBar\n详细的修改ActionBar中的图标，标题，添加按钮等操作见官方API，也可以看这一篇[博客](http://blog.csdn.net/yuzhiboyi/article/details/32709833)，觉得写的挺不错的。里面几乎将官方网站关于ActionBar的内容全部解释了一遍。\n\n##自定义ActionBar\n在用ActionBar时我总觉得按照官网上的修改方法太过于复杂麻烦，还不利于个性化。让人头疼。后来发现有一种方式能方便快捷的使用自己定义的ActionBar\n\n###创建样式文件\n\n- 在values文件夹中创建一个theme.xml文件，里面定义自己的样式文件如下:\n\n```xml\n<resources xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <!-- ActionBar样式 -->\n    <style name=\"MyActionBar\" parent=\"android:Theme.Light\">\n        <item name=\"android:windowTitleSize\">46dip</item>\n        <item name=\"android:windowTitleBackgroundStyle\">@style/myActionBarBackground</item>\n        <item name=\"android:windowBackground\">@color/white</item>\n    \t<item name=\"android:textColor\">@color/white</item>\n    </style>\n</resources>\n```\n\n- 再在styles.xml文件中加入引用的样式:\n\n```xml\n<style name = \"myActionBarBackground\">\n        <item name=\"android:background\">@color/this.green</item>\n</style>\n```\n\n###在系统中应用主题\n\n- 然后在AndroidMainifest.xml文件中应用自己定义的xml:\n\n```xml\n<application\n        android:allowBackup=\"true\"\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:theme=\"@style/MyActionBar\" >\n```\n\n- 这样，你自己定义的主题就产生了，里面包含你对ActionBar的一些配置。当然，现在还没有定制化自己的ActionBar，只是将主题中的颜色文字大小等风格制定了。要真正达到自定义的效果，还要自己写一个ActionBar的样式xml文件。我自己写的一个actionBar.xml文件如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\" >\n\n    <Button\n        android:id=\"@+id/actionbar_back_button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_centerVertical=\"true\"\n        android:layout_alignParentLeft=\"true\"\n        android:background=\"@drawable/btn_back_normal\"/>\n\n    <TextView\n        android:id=\"@+id/actionbar_title_textview\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_centerInParent=\"true\"\n        android:text=\"title\" />\n    \n    \n    <Button\n        android:id=\"@+id/actionbar_home_button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_centerVertical=\"true\"\n        android:layout_alignParentRight=\"true\"\n        android:background=\"@drawable/home\" />\n\n</RelativeLayout>\n```\n\n###在Activity中加载自定义ActionBar样式\n\n- 这里面定义了ActionBar中有两个按钮和一个标题文本。最后只要你在Activity中应用就可以显示你自己定义的ActionBar了,在Activity中的应用如下：\n\n```java\n @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);\n        setContentView(R.layout.activity_login);\n        getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.layout_actionbar);\n\n    }\n```\n\n- 最后就能显示出你自己定义的ActionBar了，对于里面的组件就像平常定义的组件一样使用即可。再上一张效果图，这里面我将左边和右边ActionBar的按钮设置为不可见了，所以只留了一个中间的登录文本显示框。\n\n\n![ActionBar]({{BASE_PATH}}/image/ActionBar.png)\n","slug":"Android自定义ActionBar","updated":1429717544000,"excerpt":"<h2 id=\"简介\">简介</h2>\n<p>Action Bar是一种新增的导航栏功能，在Android 3.0以后加入到系统的API中，它标识了用户当前操作界面的位置，并提供了额外的用户动作，界面导航等功能。</p>\n<h2 id=\"优点\">优点</h2>\n<p>它提供了一种全局统一的UI界面，使得用户在使用任何一款软件时都懂得如何操作，并且ActionBar还可以自动适应各种不同大小的屏幕。<br>一般action提供了图标及overflow按钮。overflow按钮可以在actionbar中的组件放不下时收回overflow中，当让，也可以手动指定哪些不被收入overflow中。</p>\n","_id":"nnpntx3oejvgfoso","comments":true,"layout":"post","photos":[],"link":""},{"title":"hibernate入门","date":1430046420000,"categories":["53ssokygss0ah155"],"tags":["3yu40szbp0iu23ln","5mmy83sdzsiks9nb","005v3spuoccq52su"],"desctiption":"hibernate基础入门篇","content":"<h2 id=\"hibernate基础语义\">hibernate基础语义</h2>\n<h3 id=\"1-Configuration\">1.Configuration</h3>\n<p>Configuration类负责管理Hibernate的配置信息。Hibernate运行时需要获取一些底层实现的基本信息。这些属性可以在Hibernate配置文件（hibernate.cfg.xml或hibernate.properties）中加以设定。</p>\n<a id=\"more\"></a>\n\n<p>当调用:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Configuration config = <span class=\"keyword\">new</span> Configuration().configure();</div></pre></td></tr></table></figure>\n\n<p>时，会自动在当前的CLASSPATH中寻找hibernate.cfg.xml文件并加载到内存中。</p>\n<p>Configuraton类一般只有在获取SessionFactory时需要涉及，当SessionFactory实例创建之后，由于配置信息已经绑定在返回的SessionFactory中了，所以一般无需在对其进行操作了。</p>\n<h3 id=\"2-SessionFactory\">2.SessionFactory</h3>\n<p>SessionFactory负责创建Session实例。可以通过Configuration实例构建SessionFactory：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Configuration config = <span class=\"keyword\">new</span> Configuration().configure();</div><div class=\"line\">SessionFactory sessionFactory = config,buildSessionFactory();</div></pre></td></tr></table></figure>\n\n<p>SessionFactory实例一旦构造完毕，就被赋予特定的配置信息，之后config的变更将不会影响到已经创建的SessionFactory实例。如果需要改动的话就需要重新建一个SessionFactory的实例。如果要访问多个数据库，那么针对每个数据库，应该分别为其创建对应的SessionFactory实例。</p>\n<p>SessionFactory中保存了对应当前数据库配置的所有映射关系，同时也负责维护当前的二级数据缓存和Statement Pool。由此可见，SessiongFactory的创建过程非常复杂，代价高昂。因此在系统设计中要考虑到SessionFactory的重用策略。</p>\n<p>SessionFactory采用了线程安全的设计，可由多个线程并发调用，大多情况下，一个应用中针对一个数据库共享一个SessionFactory实例即可。</p>\n<h3 id=\"3-Session\">3.Session</h3>\n<p>Session是hibernate持久化操作的基础。这里的session相当于JDBC中的Connection。</p>\n<p>Session提供了众多持久化方法，可以透明的完成对象的CURD。</p>\n<p>Session的设计是非线程安全的，一个Session只能由一个线程使用，多个线程使用一个Session将导致难以预知的错误。</p>\n<p>Session由SessionFactory创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Configuration config = <span class=\"keyword\">new</span> Configuration().configure();</div><div class=\"line\">SessionFactory sessionFactory = config,buildSessionFactory();</div><div class=\"line\">Session session =sessionFactory.openSession();</div></pre></td></tr></table></figure>\n\n<p>接下来就可以使用session的方法完成持久层操作了。</p>\n<ul>\n<li>Save</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//新增用户记录</span></div><div class=\"line\">TUser user = <span class=\"keyword\">new</span> TUser();</div><div class=\"line\">user.setName(<span class=\"string\">\"test\"</span>);</div><div class=\"line\">session.save(user);</div></pre></td></tr></table></figure>\n\n<ul>\n<li>Get</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//获取id=1的记录</span></div><div class=\"line\">TUser user = (TUser)session.get(TUser.class,<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div></pre></td></tr></table></figure>\n\n<ul>\n<li>delete</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//先取出，再删除</span></div><div class=\"line\">TUser user = (TUser)session.get(TUser.class,<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">session.delete(user);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过Query接口进行基于HQL的删除操作</span></div><div class=\"line\">String hql =<span class=\"string\">\"delete TUser where id =1\"</span></div><div class=\"line\">Query query = session.createQuery(hql);</div><div class=\"line\">query.executeUpdate();</div></pre></td></tr></table></figure>\n\n<ul>\n<li>查询</li>\n</ul>\n<p>1.通过Query接口进行数据查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">String hql = <span class=\"string\">\"from TUser user where user.name like ?\"</span>;</div><div class=\"line\">Query query =session.createQuery(hql);</div><div class=\"line\">query.setParameter(<span class=\"number\">0</span>,<span class=\"string\">\"Cartier\"</span>);</div><div class=\"line\"></div><div class=\"line\">List list = query.list();</div><div class=\"line\"></div><div class=\"line\">Iterator it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext()){</div><div class=\"line\">    TUser user = (TUser)it.next();</div><div class=\"line\">    System.out.println(user.getName);</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>2.通过Criteria接口进行数据查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Criteria criteria = session.createCriteria(TUser.class);</div><div class=\"line\">criteria.add(Expression.eq(<span class=\"string\">\"name\"</span>,<span class=\"string\">\"Cartier\"</span>));</div><div class=\"line\"></div><div class=\"line\">List list = criteria.list();</div><div class=\"line\"></div><div class=\"line\">Iterator it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext()){</div><div class=\"line\">    TUser user = (TUser)it.next();</div><div class=\"line\">    System.out.println(user.getName);</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>两种查询方式的不同之处在于Query面向HQL和Native SQL，而Criteria则提供面向对象的查询模式。</p>\n<h2 id=\"基础配置\">基础配置</h2>\n<h3 id=\"1-SessionFactory配置\">1.SessionFactory配置</h3>\n<p>配置方面就不作过多记录，很多文章都讲的很好了。</p>\n<ul>\n<li>数据库连接配置</li>\n<li>数据库连接池配置<ul>\n<li>默认数据库连接池</li>\n<li>C3P0</li>\n<li>dbcp</li>\n<li>Proxool</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"事务管理\">事务管理</h2>\n<p>为了使用Hibernate的Transaction API，我们必须通过hibernate.transaction.factory_class属性指定一个Transaction实例工厂类。Transaction API隐藏了底层的事务机制，允许Hibernate代码在受管制和非管制的环境下都可以运行。</p>\n<h3 id=\"1-使用JDBC的事务处理机制\">1.使用JDBC的事务处理机制</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hibernate.transaction.factory_class = net.sf.hibernate.transaction.JDBCTransactionFactory</div></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用JTA\">2.使用JTA</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hibernate.transaction.factory_class = net.sf.hibernate.transaction.JTATransactionFactory</div><div class=\"line\">jta.UserTransaction jta/usertransaction</div></pre></td></tr></table></figure>\n\n<p>可选的配置项很多就不一一记录了。</p>\n<h2 id=\"Hibernate_O/R_映射\">Hibernate O/R 映射</h2>\n<p>O/R映射是ORM框架中最为关键的组成部分。</p>\n<h3 id=\"1-Hibernate基本数据类型\">1.Hibernate基本数据类型</h3>\n<p>integer是Hibernate基本数据类型之一。Hibernate中提供了丰富的数据类型支持，其中包括了传统的Java数据类型，如String ,Integer，以及JDBC数据类型，如Clob，Blob等。除此之外，Hibernate还提供用户自定义的数据类型支持。</p>\n<p>Hibernate基本数据类型覆盖了日常开发中的绝大多数情况，它提供了传统数据库类型与Java数据类型之间的连接纽带。</p>\n<h3 id=\"2-实体映射\">2.实体映射</h3>\n<p>下面介绍了实体映射由浅入深的顺序，分为三个部分：</p>\n<ul>\n<li><p>实体映射基础：介绍Hibernate中类/表映射。属性/字段映射的基本技术</p>\n</li>\n<li><p>高级映射技术：<br>较少自定义数据类型，复合主键，特殊字段的相关映射技术</p>\n</li>\n<li><p>实体映射策略：<br>围绕实体映射中实体粒度，层次的设计思路进行探讨，对特殊情况下与实体逻辑结构，实体读写性能相关的一些通用设计策略介绍。</p>\n</li>\n</ul>\n<h4 id=\"2-1实体映射基础\">2.1实体映射基础</h4>\n<p>Hibernate中，类表映射主要包括三个部分：（1）类名-表名映射（2）主键映射（3）字段映射。具体配置现一般采用注解方式配置。</p>\n<h4 id=\"2-2高级映射技术\">2.2高级映射技术</h4>\n<ul>\n<li><strong>自定义数据类型：</strong>比如说一个用户可能需要保存多个Email地址信息，当然完全可以在一个String字段中保存一长串用;分割的字符串，但这样做起来不是很优雅，所以可以将email字段映射为一个List集合类型，但是Hibernate并没有提供原生的支持，这时候就需要实现自定义的数据类型了。</li>\n<li><strong>复合主键：</strong>在实际开发中，可能一开始要求用户名不能重复，但是由于需求变更导致可以允许用户名相同，这时候为了减少更改库表的工作量，需要映入复合主键来解决问题。</li>\n<li><strong>BLOB，CLOB字段的映射：</strong>例如在User表中，假设要为用户增加两个大型字段，其中image字段用于保存照片（Blog），resume字段用于保存建立（CLOB）。BLOB和CLOB的主要区别在于Blob字段采用单字节存储，适合保存二进制数据，如图片文件。Clob字段采用多字节存储，适合大型文本数据保存。</li>\n<li><strong>实体映射策略：</strong>就是通过设计将各个部分进一步细分，得到更加细粒度的对象。<ul>\n<li><strong><em>面向设计的粒度细分：</em></strong>通过对象细化，实现更加清晰的系统逻辑划分，体现出更加清晰合理的设计逻辑。</li>\n<li><strong><em>面向性能的粒度细分：</em></strong>针对业务逻辑，通过合理的细粒度对象，提高系统的能耗比。当一个对象中有一个Blob这种重量级的数据时，当我们加载对象时，Hibernate会从库表中读取所有的字段数据，并构造相应的类实例返回。这样对于Blob这种数据就对读取操作的代价提高，如何避免这个问题，Hibernate提供了属性的延迟加载功能，通过这个功能，我们可以在调用TUser.getImage时才真正从数据库中读取数据，</li>\n</ul>\n</li>\n<li><strong><em>实体层次设计：</em></strong> 继承关系是关系型数据库和面向对象数据结构之间的主要差异之一。Hibernate中支持3种类型的继承形式:<ul>\n<li><strong>Table per concrete class:</strong>表与子表之间的独立一对一关系。</li>\n<li><strong>Table per subclass:</strong> 每个子类对应一张子表，并与主类共享主表。</li>\n<li><strong>Table per class hierarchy:</strong> 表与类的一对多关系。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据关联\">数据关联</h2>\n<p>对于ORM而言，一个非常关键的特性就是对实体之间关联关系的管理。数据关联是ORM的一个重要特性，但往往也是导致系统性能低下的原因。</p>\n<h3 id=\"1-一对一关联\">1.一对一关联</h3>\n<p>一对一关联包括两种类型：</p>\n<ul>\n<li><strong><em>主键关联：</em></strong>即两张表通过主键形成一对一的映射关系。级联关系设置为all，级联（cascade）在Hibernate映射关系中是个非常重要的概念。它指的是当主控方执行操作时，关联对象（被动方）是否同步执行同一操作。如对主控对象调用save-update或delete方法时，是否同时对关联对象(被动方）进行save-update或delete，设定为all则代表无论主控方执行任何操作都对其关联类进行同样的操作。</li>\n<li><strong><em>唯一外键关联:</em></strong> 在一个假定的权限管理系统示例中，每个用户都从属于一个用户组，用户表T_User中包含一个group_id字段，此字段与T_Group的id字段相关联，这就是典型的“唯一外键关联”。</li>\n</ul>\n<h3 id=\"2-一对多关联\">2.一对多关联</h3>\n<p>比如每个用户(T_User)都关联到多个地址(TAddress),如一个用户可能有多个电话等等，这样的话就反应为“一对多关联”。分为单一对关系和双向一对多关系。</p>\n<ul>\n<li><strong><em>单向一对多关联：</em></strong> 单向一对多的实现相对比较简单，但是存在一个问题，由于是单向关联，为了保持关联关系，我们只鞥通过主控方对被动方进行级联更新，如果被关联方的关联字段为“NOT NULL”，当Hibernate创建或者更新关联关系时，可能出现约束违例。</li>\n<li><strong><em>双向一对多关联：</em></strong> 双向一对多关联实际上是一对多和多对一的组合，在主控方配置一对多，在被控方配置多对一。</li>\n</ul>\n<h3 id=\"3-多对多关联\">3.多对多关联</h3>\n<p>多对多关联需要借助中间表完成多对多映射信息的保存。但是多对多的性能不佳，应避免使用，应根据情况采用延迟加载机制来避免无谓的性能开销。</p>\n<h2 id=\"Hibernate数据检索\">Hibernate数据检索</h2>\n<h3 id=\"1-Criteria_Query\">1.Criteria Query</h3>\n<p>Criteria Query通过面向对象化的设计，将数据查询条件封装成一个对象。简单来讲，Criteria Query可以看作是传统SQL的对象化表示,如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Criteria criteria = session.createCriteria(TUser.class);</div><div class=\"line\">criteria.add(Expression.eq(<span class=\"string\">\"name\"</span>,<span class=\"string\">\"Erica\"</span>);</div><div class=\"line\">criteria.add(Expression.eq(<span class=\"string\">\"sex\"</span>,<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div></pre></td></tr></table></figure>\n\n<p>这里的criteria实例本质上是对SQL “Select * from t_user where name = ‘Erica’ and sex =1”的封装。Hibernate会在运行期间根据Criteria中指定的查询条件(criteria.add方法添加的查询表达式)生成相应的SQL语句。这种方式对于SQL了解有限的程序员比较方便。</p>\n<h4 id=\"Criteria查询表达式\">Criteria查询表达式</h4>\n<p>Criteria本身只是一个查询容器，具体的查询条件需要通过Criteria.add方法添加到Criteria实例中。</p>\n<h4 id=\"示例查询\">示例查询</h4>\n<p>Example类实现了Criterion接口，同样它也可以座位Criteria的查询条件，Example的作用是：根据已有对象，查找属性与之相符的其他对象。</p>\n<h3 id=\"复合查询\">复合查询</h3>\n<p>也就是查询多个条件的查询。</p>\n<p>这里就不详细记录了。</p>\n<h3 id=\"2-DetachedCriteria\">2.DetachedCriteria</h3>\n<p>在Hibernate2中，Criteria生命周期位于其宿主session生命周期之内，也就是所session销毁的话有它创建的Criteria实例也就失效了。</p>\n<p>在Hibernate3中，提供了新的Criteria实现：DetachedCriteria。</p>\n<p>DetachedCriteria可以脱离Session实例独立存在，这样我们就可以将某些通用的Criteria查询条件进行抽离，每次使用时再与当前Session实例绑定以获得更好的代码重用效果。</p>\n<h4 id=\"Criteria高级特性\">Criteria高级特性</h4>\n<ul>\n<li><strong>限定返回的记录范围:</strong> 通过criteria.setFirstResult/setMaxResult方法可以限制一次查询返回的记录范围。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Criteria criteria = session.createCriteria(TUser.class);</div><div class=\"line\"><span class=\"comment\">//限定查询返回检索结果中，从100条结果开始的20条记录</span></div><div class=\"line\">criteria.setFirstResult(<span class=\"number\">100</span>);</div><div class=\"line\">criteria.setMaxResults(<span class=\"number\">20</span>);</div></pre></td></tr></table></figure>\n\n<p>记录排序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//查询所有groupId=2的记录，并分别按照姓名（顺序）和groupId（逆序）排序</span></div><div class=\"line\">Criteria criteria = session.createCriteria(TUser.class);</div><div class=\"line\"></div><div class=\"line\">criteria.add(Expression.eq(<span class=\"string\">\"groupId\"</span>,<span class=\"keyword\">new</span> Integer(<span class=\"number\">2</span>)));</div><div class=\"line\"></div><div class=\"line\">criteria.addOrder(Order.asc(<span class=\"string\">\"name\"</span>));</div><div class=\"line\">criteria.addOrder(Order.desc(<span class=\"string\">\"groupId\"</span>));</div></pre></td></tr></table></figure>\n\n<h4 id=\"Criteria综述\">Criteria综述</h4>\n<p>虽然这个比较简单，但是由于Hibernate实现过程中更加集中在HQL查询语言上，因此在实际开发中还是用官方推荐的HQL语句。</p>\n<h3 id=\"3-Hibernate_Query_Language（HQL）\">3.Hibernate Query Language（HQL）</h3>\n<p>Criteria提供了符合面向对象编程风格的查询封装模式，不过HQL提供了更加丰富灵活的特性，它在涵盖了Criteria功能范围的前提下，提供了强大的查询能力。</p>\n<p>完整的HQL 语法结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[select|update|delete ...] [from ...] [where ...] [group by ... [having ...] ] [order by ...]</div></pre></td></tr></table></figure>\n\n<h2 id=\"HQL实用技术\">HQL实用技术</h2>\n<h3 id=\"1-实体查询\">1.实体查询</h3>\n<p>首先来一个最简单的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String hql = <span class=\"string\">\"from TUser\"</span>;</div><div class=\"line\">Query query = session.createQuery(hql);</div><div class=\"line\">List userList = query.list();</div></pre></td></tr></table></figure>\n\n<p>取出TUser的所有对应记录，其中在HQL中也可以采用全路径类名，特别在应用中有同类名但包名不同的情况。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"from com.zalezone.TUser\"</span></div></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>HQL子句本身大小写无关，但是区中出现的类名和属性名必须注意大小写区分。另外，需要注意的是，查询的目标实体存在着继承关系的判定， 如”from TUser”将返回所有TUser以及TUser子类的记录，假设系统中存在TUser的两个子类，TSysAdmin和TSysOperator，那么将返回包含两个子类的所有数据，即使两个子类的表分别对应了不同的库表。</p>\n<p>如我们所知，Java中所有类都继承自java.lang.Object，那么如果这样查”from java.lang.Object”就会返回库表中所有库表的记录。</p>\n<ul>\n<li><strong>Where子句</strong><br>如果我们需要取出指定名称的记录，类似SQL，我们可以通过HQL语句加以限定:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String hql = <span class=\"string\">\"from TUser as user where user.name = 'Erica'\"</span>;</div><div class=\"line\">Query query = session.createQuery(hql);</div><div class=\"line\">List userList = query.list();</div></pre></td></tr></table></figure>\n\n<p>这里的as为类名创建了一个别名,as可以忽略，而where子句指定了限定条件。where子句中可以加许多限定如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">from TUser user where user.age &gt;<span class=\"number\">20</span></div><div class=\"line\">from TUser user where user.age between <span class=\"number\">20</span> and <span class=\"number\">30</span></div><div class=\"line\">from TUser user where user.age in (<span class=\"number\">18</span>,<span class=\"number\">28</span>)</div><div class=\"line\">from TUser user where user.age is <span class=\"keyword\">null</span></div><div class=\"line\">from TUser user where user.name like <span class=\"string\">'er%'</span> </div><div class=\"line\"><span class=\"comment\">//也可求算术表达式的值</span></div><div class=\"line\">from TUser user where (user.age%<span class=\"number\">2</span>=<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"comment\">//可加and，or来连接各个表达式</span></div><div class=\"line\">from TUser user where (user.age &gt;<span class=\"number\">20</span>) and (user.name like <span class=\"string\">'er%'</span>)</div></pre></td></tr></table></figure>\n\n<h3 id=\"2-属性查询\">2.属性查询</h3>\n<p>有时候我们并不需要获取完整的实体对象，如在一个下拉框中显示用户名，我们可能只是需要某个属性就行，我们可以这样来完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">List list = session.createQuery(<span class=\"string\">\"select user.name from TUser user\"</span>).list();</div><div class=\"line\">Iterator it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())</div><div class=\"line\">{</div><div class=\"line\">    System.out.pringln(it.next());</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>这里我们只指定获取name属性一个String类型。如果要获取多个属性的话如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">List list = session.createQuery(<span class=\"string\">\"select user.name，user.age from TUser user\"</span>).list();</div><div class=\"line\">Iterator it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())</div><div class=\"line\">{</div><div class=\"line\">    Object[] results =(Object[])it.next();</div><div class=\"line\">    System.out.println(results[<span class=\"number\">0</span>]);</div><div class=\"line\">    System.out.println(results[<span class=\"number\">1</span>]);</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>如果觉得返回数组的方式不符合面向对象的风格，可以在HQL中动态的构造对象实例的方法对这些平面化的数据进行封装。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">List list = session.createQuery(<span class=\"string\">\"select new TUser(user.name,user.age) from TUser user\"</span>).list();</div><div class=\"line\">Iterator it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())</div><div class=\"line\">{</div><div class=\"line\">    TUser user = (TUser)it.next();</div><div class=\"line\">    System.out.pringtln(user.getName());</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>通过在HQL中动态的构造对象实例，我们实现了对查询结果的对象化封装。注意此时在查询结果中的TUser对象仅仅是一个普通的Java对象，仅用于对查询结果的封装，出了在构造是赋予的属性值外，其他属性均为未赋值的状态，这也就意味着我们无法通过Session对此对象进行更新，下面代码中，对user对象的更新将导致向数据库中插入一条新的记录，而不是更新原有的记录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">List list = session.createQuery(<span class=\"string\">\"select new TUser(user.name,user.age) from TUser user\"</span>).list();</div><div class=\"line\">Iterator it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())</div><div class=\"line\">{</div><div class=\"line\">    TUser user = (TUser)it.next();</div><div class=\"line\">    user.setName(“test”);</div><div class=\"line\">    session.saveOrUpdate(user);<span class=\"comment\">//这里将导致一次insert操作，而非update</span></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>另外，我们也可以在HQL中的Select子句中使用统计函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">List list = session.createQuery(<span class=\"string\">\"select count(*),min(user.age) from TUser user\"</span>).list();</div><div class=\"line\">Iterator it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())</div><div class=\"line\">{</div><div class=\"line\">    Object[] results =(Object[])it.next();</div><div class=\"line\">    System.out.println(results[<span class=\"number\">0</span>]);</div><div class=\"line\">    System.out.println(results[<span class=\"number\">1</span>]);</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>甚至原生SQL函数如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">select upper(user.name) from TUser user;</div><div class=\"line\">select distinct user.name from TUser user;</div></pre></td></tr></table></figure>\n\n<h3 id=\"3-实体更新与删除\">3.实体更新与删除</h3>\n<p>在Hibernate3中HQL具备了更加强大的功能，其中实体更新和删除是主要特性之一。在2中是先加载实体在更改保存，在hibernate3中的话HQL提供了更加灵活便捷的实现方式。（bulk delete/update）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Transaction tx = session.beginTransaction();</div><div class=\"line\">String hql = <span class=\"string\">\"update TUser set age =18 where id =1\"</span>;</div><div class=\"line\">Query query = session.createQuery(hql);</div><div class=\"line\">query.executeUpdate();</div><div class=\"line\">tx.commit();</div></pre></td></tr></table></figure>\n\n<p>虽然在对单个对象更新时代码没有减少多少，但是对与批量性更新操作时便捷性和性能提高就很可观。</p>\n<p>HQL的delete子句的使用同样非常简单，以下代码删除了所有年龄大于18的用户记录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Transaction tx = session.beginTransaction();</div><div class=\"line\">String hql = <span class=\"string\">\"update TUser set age =18 where age &gt;18\"</span>;</div><div class=\"line\">Query query = session.createQuery(hql);</div><div class=\"line\">query.executeUpdate();</div><div class=\"line\">tx.commit();</div></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong>在使用HQL的delte/update子句时，我们必须特别注意它们对缓存策略的影响，delete/update子句极有可能导致缓存同步上的障碍。</p>\n<p>总体来看，Hibernate3中的HQL功能已越来越全面，与SQL不同的是，SQL面向的是二维的结构化数据，而HQL则面向数据对象。在对象型数据库尚不成熟时，通过面向对象的查询语言对关系型数据库进行访问，既满足了上层结构中面向对象设计的需求，也充分利用了现有技术平台，这也是Hibernate的优势。</p>\n<h3 id=\"4-分组与排序\">4.分组与排序</h3>\n<ul>\n<li><p><strong>Order by子句</strong></p>\n<p>  与SQL类似，HQL通过order by子句对查询结果排序如：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">from TUser user order by user.name,user.age desc</div></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>Group by子句(having 子句)</strong></p>\n<p>  用Group by对子句进行分组统计,如下我们通过Group by子句实现了同龄用户的统计：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">List list = session.createQuery(<span class=\"string\">\"select count(user),user.age from TUser user group by user.age having count(user)&gt;10\"</span>).list();</div><div class=\"line\">Iterator it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())</div><div class=\"line\">{</div><div class=\"line\">    Object[] results =(Object[])it.next();</div><div class=\"line\">    System.out.println(results[<span class=\"number\">0</span>]);</div><div class=\"line\">    System.out.println(results[<span class=\"number\">1</span>]);</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<h3 id=\"5-参数绑定\">5.参数绑定</h3>\n<p>如上面的许多Hql语句我们可以看到里面的参数都是直接写在里面的，如果要求查询的参数是变量，直接用变量名代替变量如“from TUser user where user.age&gt;” + age;进行HQL拼接的话虽然能实现功能，但是会存在如下缺陷：</p>\n<ul>\n<li><strong>编码更加凌乱，可读性降低:</strong> 如果存在很多很多的查询参数将混乱无序。</li>\n<li><strong>难以进行性能优化:</strong>根据JDBC以及数据库的操作原理可知每次SQL执行时，数据库都将对SQL语句进行解析和优化，并将其处理结果保存在缓存中，如果以后有参数不同，语法相同的SQL命令，则直接以此缓存结果加以执行，从而避免了SQL解析和优化的开销，另外从Hibernate角度而言，它使用了PreparedStatement作为底层数据库访问手段，对于相同的SQL，也可以重用以及创建的PrepareStatement，这样如果将参数写在SQL中，将导致每次提交的SQL语句都不同，从系统角度而言不同参数将导致判断为是两个不同的SQL命令，（有些数据库相同内容的SQL大小写不同也视为是不同的SQL命令），从而会将其视为一个全新的SQL语法进行处理，缓存无法得到利用，导致了性能优化策略失效。</li>\n<li><strong>引入额外的安全风险：</strong>最常见的就是SQL 注入攻击了，就是针对这些SQL字符拼装造成的漏洞。</li>\n</ul>\n<p>参数的动态绑定机制可以妥善的处理好以上问题。类似JDBC的SQL操作，我们可以通过顺序占位符“？”对参数进行标识，并在之后对参数内容进行填充，如：</p>\n<ul>\n<li>在Session.find方法（Hibernate2）中填充参数：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">session.find(<span class=\"string\">\"from TUser user where user.name=?\"</span>,<span class=\"string\">\"Erica\"</span>,Hibernate.STRING);</div></pre></td></tr></table></figure>\n\n<p>多参数的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object[] args = <span class=\"keyword\">new</span> Object[]{<span class=\"string\">\"Erica\"</span>,<span class=\"keyword\">new</span> Integer(<span class=\"number\">20</span>)};</div><div class=\"line\">Type[] types = <span class=\"keyword\">new</span> Type[]{Hibernate,STRING,Hibernate.INTEGER};</div><div class=\"line\">session.find(<span class=\"string\">\"from TUser user where user.name=? and user.age &gt; ?\"</span>,args,types);</div></pre></td></tr></table></figure>\n\n<ul>\n<li>通过Query接口进行参数填充：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Query query = session.createQuery(<span class=\"string\">\"from TUser user where user.name =? and user.age&gt;?\"</span>);</div><div class=\"line\">query.setString(<span class=\"number\">0</span>,<span class=\"string\">\"Erica\"</span>);</div><div class=\"line\">query.setInteger(<span class=\"number\">1</span>,<span class=\"number\">20</span>);</div></pre></td></tr></table></figure>\n\n<p>除了用顺序占位符外，Hibernate还支持引用占位符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">String hql = <span class=\"string\">\"from TUser where name = :name\"</span>;</div><div class=\"line\">Query query = session.createQuery(hql);</div><div class=\"line\">query.setParameter(<span class=\"string\">\"name\"</span>,<span class=\"string\">\"Erica\"</span>);</div><div class=\"line\">Iterator it = query.iterate();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext()){</div><div class=\"line\">    TUser user = (TUser)it.next();</div><div class=\"line\">    System.out.pringln(user.getName());</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>以上的:name即所谓的引用占位符，它标识了一个名为“name”的查询参数，通过session.createQuery方法构造Query实例后，我们即可以根据此参数名进行参数填充。另外，我们也可以用一个JavaBean封装查询参数。</p>\n<p>参数绑定机制可以使得查询语法与具体的参数数值相互独立，这样，对于参数不同，查询语法相同的查询操作，数据库即可以实施性能优化策略，同时，参数绑定机制也杜绝了参数值对查询语法本身的影响，避免SQL注入。</p>\n<h3 id=\"6-引用查询\">6.引用查询</h3>\n<p>有时候会碰到如下编码规范，规定在代码中不允许出现SQL语句，总之，为了避免SQL语句混杂在代码之间，我们可以采取将SQL保存在配置文件中，需要调用的时候再进行读取。Hibernate提供了HQL可配置化的内置支持。</p>\n<h3 id=\"7-联合查询\">7.联合查询</h3>\n<p>SQL通过join子句实现多表之间的联合查询，HQL提供以下几种联合查询机制：</p>\n<ol>\n<li>inner join</li>\n<li>left outer join</li>\n<li>right outer join</li>\n<li>full join(not usually useful)</li>\n</ol>\n<p>这里的概念就是数据库中的连接问题，inner join类似于自然连接，对于Inner join：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">from TUser user inner join fetch user.address</div></pre></td></tr></table></figure>\n\n<p>等于执行了一下语句：select … from T_User user inner join TAddress addr on user.id =addr.userid</p>\n<p>注意到上面HQL语句中的“fetch”关键字表明TAddress对象读出后立即填充到对应的TUser对象中。如果忽略fetch关键字，则在得到的结果集中，每个条目都是一个Object数组，其中包括了一个TUser对象以及对应的TAddress对象。另外，SQL中的on user.id = addr.user_id对于关系在映射文件指定了，所以HQL并没有对应表现。注意fetch关键字只对inner join和left join有效，对于right join而言，由于作为对象容器的TUser对象可能为null，所以也就无法通过fetch关键字强制Hibernate进行集合填充操作。右连接的话就将对象取出然后进行操作。</p>\n<h3 id=\"8-子查询\">8.子查询</h3>\n<p>HQL同样支持子查询，假设我们需要从一个结果中提取出拥有两条及以上地址信息的TUser对象，那么我们可以这样写HQL：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">from TUser user where (select count(*) from user.addresses)&gt;<span class=\"number\">1</span></div></pre></td></tr></table></figure>\n\n<p>HQL中，子查询必须出现在where子句中，且必须以一对圆括号包围。</p>\n<h3 id=\"9-数据加载方式\">9.数据加载方式</h3>\n<p>Hibernate支持以下几种数据加载方式：</p>\n<ol>\n<li><p><strong>即时加载（Immediate Loading）</strong></p>\n<p> 当实体加载完成后，立即加载其关联数据。</p>\n</li>\n<li><p><strong>延迟加载（Lazy Loading）</strong></p>\n<p> 实体加载时，其关联数据并非即刻获取，而是当关联数据第一次被访问时再进行读取。</p>\n</li>\n<li><p><strong>预先加载（Eager Loading）</strong></p>\n<p> 预先加载时，实体及其关联对象同时读取，这与即时加载类似，不过实体及其关联数据是通过一条SQL语句（基于外连接[outer join]）同时读取。</p>\n</li>\n<li><p><strong>批量加载（Batch Loading）</strong></p>\n<p> 对于即时加载和延迟加载，可以采用批量加载的方式进行性能上的优化。就是通过批量提交多个限定条件，一次完成多个数据的读取。如果使用了批量加载机制，Hibernate在进行数据查询操作前，会自动在当前的session中寻找是否还有其他同类型待加载数据，如果有，则将其查询条件合并在当前的select语句中一并提交，这样，通过一次数据库操作即完成了多个读取任务。</p>\n</li>\n</ol>\n<h2 id=\"10-SQL查询\">10.SQL查询</h2>\n<p>由于SQL语法本身的庞杂，以及各种数据库原生功能的多样性，HQL不能涵盖所有查询特性，有时候我们不得不借助原生的SQL或存储过程来达到我们的目标。</p>\n<p>Hibernate提供了对原生SQL以及存储过程（Hibernate3）的支持，相对于基于JDBC的SQL操作，Hibernate提供了更为妥善的封装。在Hibernate SQL查询接口中，我们只需要指定别名，而ResultSet与实体的映射将由Hibernate自动完成。从一个简单的例子入手：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Select * from TUser where name = <span class=\"string\">'Erica'</span></div></pre></td></tr></table></figure>\n\n<p>上面的sql从表中返回特定名字的记录。如何通过HQL调用这条SQL语句，并返回对应的TUser对象？如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = <span class=\"string\">\"select {user.*} from TUser user\"</span>;</div><div class=\"line\">List list = session.createSQLQuery(sql,<span class=\"string\">\"usr\"</span>,TUser.class).list();</div><div class=\"line\">Iterator it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext){</div><div class=\"line\">    TUser user = (TUser)it.next();</div><div class=\"line\">    System.out.println(user.getName());</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>上面的SQL片段“select u.id as {usr.id}”,其中u是SQL中TUser表的别名，而usr是我们指定的实体对象别名。在session.createSQLQuery(sql,”usr”,TUser.class)方法中，我们将待执行的SQL传入，并指定其实体对象别名为usr，实体对象类型为TUser.class,这样，Hibernate就会根据在SQL中的别名配置，将返回的ResultSet映射到对应的实体对象实例返回。</p>\n<h2 id=\"11-自定义持久化实现\">11.自定义持久化实现</h2>\n<p>简单来说就是运行自己定义持久化的实现机制。</p>\n","source":"_posts/hibernate.md","raw":"title: hibernate入门\ndate: 2015-04-26 19:07:00\ncategories: 数据库\ntags: [数据库,hibernate,数据持久化]\ndesctiption: hibernate基础入门篇\n\n---\n\n##hibernate基础语义\n\n###1.Configuration\nConfiguration类负责管理Hibernate的配置信息。Hibernate运行时需要获取一些底层实现的基本信息。这些属性可以在Hibernate配置文件（hibernate.cfg.xml或hibernate.properties）中加以设定。\n\n<!--more-->\n\n当调用:\n```java\nConfiguration config = new Configuration().configure();\n```\n时，会自动在当前的CLASSPATH中寻找hibernate.cfg.xml文件并加载到内存中。\n\nConfiguraton类一般只有在获取SessionFactory时需要涉及，当SessionFactory实例创建之后，由于配置信息已经绑定在返回的SessionFactory中了，所以一般无需在对其进行操作了。\n\n\n###2.SessionFactory\nSessionFactory负责创建Session实例。可以通过Configuration实例构建SessionFactory：\n```java\nConfiguration config = new Configuration().configure();\nSessionFactory sessionFactory = config,buildSessionFactory();\n```\n\nSessionFactory实例一旦构造完毕，就被赋予特定的配置信息，之后config的变更将不会影响到已经创建的SessionFactory实例。如果需要改动的话就需要重新建一个SessionFactory的实例。如果要访问多个数据库，那么针对每个数据库，应该分别为其创建对应的SessionFactory实例。\n\nSessionFactory中保存了对应当前数据库配置的所有映射关系，同时也负责维护当前的二级数据缓存和Statement Pool。由此可见，SessiongFactory的创建过程非常复杂，代价高昂。因此在系统设计中要考虑到SessionFactory的重用策略。\n\nSessionFactory采用了线程安全的设计，可由多个线程并发调用，大多情况下，一个应用中针对一个数据库共享一个SessionFactory实例即可。\n\n###3.Session\nSession是hibernate持久化操作的基础。这里的session相当于JDBC中的Connection。\n\nSession提供了众多持久化方法，可以透明的完成对象的CURD。\n\nSession的设计是非线程安全的，一个Session只能由一个线程使用，多个线程使用一个Session将导致难以预知的错误。\n\nSession由SessionFactory创建：\n```java\nConfiguration config = new Configuration().configure();\nSessionFactory sessionFactory = config,buildSessionFactory();\nSession session =sessionFactory.openSession();\n```\n\n接下来就可以使用session的方法完成持久层操作了。\n\n- Save\n\n```java\n//新增用户记录\nTUser user = new TUser();\nuser.setName(\"test\");\nsession.save(user);\n```\n- Get\n\n```java\n//获取id=1的记录\nTUser user = (TUser)session.get(TUser.class,new Integer(1));\n\n```\n- delete\n\n```java\n//先取出，再删除\nTUser user = (TUser)session.get(TUser.class,new Integer(1));\nsession.delete(user);\n\n//通过Query接口进行基于HQL的删除操作\nString hql =\"delete TUser where id =1\"\nQuery query = session.createQuery(hql);\nquery.executeUpdate();\n```\n- 查询\n\n1.通过Query接口进行数据查询\n```java\nString hql = \"from TUser user where user.name like ?\";\nQuery query =session.createQuery(hql);\nquery.setParameter(0,\"Cartier\");\n\nList list = query.list();\n\nIterator it = list.iterator();\nwhile(it.hasNext()){\n    TUser user = (TUser)it.next();\n    System.out.println(user.getName);\n}\n```\n2.通过Criteria接口进行数据查询\n```java\nCriteria criteria = session.createCriteria(TUser.class);\ncriteria.add(Expression.eq(\"name\",\"Cartier\"));\n\nList list = criteria.list();\n\nIterator it = list.iterator();\nwhile(it.hasNext()){\n    TUser user = (TUser)it.next();\n    System.out.println(user.getName);\n}\n```\n\n两种查询方式的不同之处在于Query面向HQL和Native SQL，而Criteria则提供面向对象的查询模式。\n\n\n##基础配置\n\n###1.SessionFactory配置\n配置方面就不作过多记录，很多文章都讲的很好了。\n- 数据库连接配置\n- 数据库连接池配置\n    - 默认数据库连接池\n    - C3P0\n    - dbcp\n    - Proxool\n\n##事务管理\n为了使用Hibernate的Transaction API，我们必须通过hibernate.transaction.factory_class属性指定一个Transaction实例工厂类。Transaction API隐藏了底层的事务机制，允许Hibernate代码在受管制和非管制的环境下都可以运行。\n\n###1.使用JDBC的事务处理机制\n```java\nhibernate.transaction.factory_class = net.sf.hibernate.transaction.JDBCTransactionFactory\n```\n###2.使用JTA\n```java\nhibernate.transaction.factory_class = net.sf.hibernate.transaction.JTATransactionFactory\njta.UserTransaction jta/usertransaction\n```\n\n可选的配置项很多就不一一记录了。\n\n##Hibernate O/R 映射\nO/R映射是ORM框架中最为关键的组成部分。\n\n###1.Hibernate基本数据类型\ninteger是Hibernate基本数据类型之一。Hibernate中提供了丰富的数据类型支持，其中包括了传统的Java数据类型，如String ,Integer，以及JDBC数据类型，如Clob，Blob等。除此之外，Hibernate还提供用户自定义的数据类型支持。\n\nHibernate基本数据类型覆盖了日常开发中的绝大多数情况，它提供了传统数据库类型与Java数据类型之间的连接纽带。\n\n###2.实体映射\n下面介绍了实体映射由浅入深的顺序，分为三个部分：\n\n- 实体映射基础：介绍Hibernate中类/表映射。属性/字段映射的基本技术\n\n- 高级映射技术：\n较少自定义数据类型，复合主键，特殊字段的相关映射技术\n\n- 实体映射策略：\n围绕实体映射中实体粒度，层次的设计思路进行探讨，对特殊情况下与实体逻辑结构，实体读写性能相关的一些通用设计策略介绍。\n\n####2.1实体映射基础\nHibernate中，类表映射主要包括三个部分：（1）类名-表名映射（2）主键映射（3）字段映射。具体配置现一般采用注解方式配置。\n\n####2.2高级映射技术\n- **自定义数据类型：**比如说一个用户可能需要保存多个Email地址信息，当然完全可以在一个String字段中保存一长串用;分割的字符串，但这样做起来不是很优雅，所以可以将email字段映射为一个List集合类型，但是Hibernate并没有提供原生的支持，这时候就需要实现自定义的数据类型了。\n- **复合主键：**在实际开发中，可能一开始要求用户名不能重复，但是由于需求变更导致可以允许用户名相同，这时候为了减少更改库表的工作量，需要映入复合主键来解决问题。\n- **BLOB，CLOB字段的映射：**例如在User表中，假设要为用户增加两个大型字段，其中image字段用于保存照片（Blog），resume字段用于保存建立（CLOB）。BLOB和CLOB的主要区别在于Blob字段采用单字节存储，适合保存二进制数据，如图片文件。Clob字段采用多字节存储，适合大型文本数据保存。\n- **实体映射策略：**就是通过设计将各个部分进一步细分，得到更加细粒度的对象。\n    - ***面向设计的粒度细分：***通过对象细化，实现更加清晰的系统逻辑划分，体现出更加清晰合理的设计逻辑。\n    - ***面向性能的粒度细分：***针对业务逻辑，通过合理的细粒度对象，提高系统的能耗比。当一个对象中有一个Blob这种重量级的数据时，当我们加载对象时，Hibernate会从库表中读取所有的字段数据，并构造相应的类实例返回。这样对于Blob这种数据就对读取操作的代价提高，如何避免这个问题，Hibernate提供了属性的延迟加载功能，通过这个功能，我们可以在调用TUser.getImage时才真正从数据库中读取数据，\n- ***实体层次设计：*** 继承关系是关系型数据库和面向对象数据结构之间的主要差异之一。Hibernate中支持3种类型的继承形式:\n    - **Table per concrete class:**表与子表之间的独立一对一关系。\n    - **Table per subclass:** 每个子类对应一张子表，并与主类共享主表。\n    - **Table per class hierarchy:** 表与类的一对多关系。\n\n##数据关联\n对于ORM而言，一个非常关键的特性就是对实体之间关联关系的管理。数据关联是ORM的一个重要特性，但往往也是导致系统性能低下的原因。\n\n###1.一对一关联\n一对一关联包括两种类型：\n\n- ***主键关联：***即两张表通过主键形成一对一的映射关系。级联关系设置为all，级联（cascade）在Hibernate映射关系中是个非常重要的概念。它指的是当主控方执行操作时，关联对象（被动方）是否同步执行同一操作。如对主控对象调用save-update或delete方法时，是否同时对关联对象(被动方）进行save-update或delete，设定为all则代表无论主控方执行任何操作都对其关联类进行同样的操作。\n- ***唯一外键关联:*** 在一个假定的权限管理系统示例中，每个用户都从属于一个用户组，用户表T_User中包含一个group_id字段，此字段与T_Group的id字段相关联，这就是典型的“唯一外键关联”。\n\n###2.一对多关联\n比如每个用户(T_User)都关联到多个地址(TAddress),如一个用户可能有多个电话等等，这样的话就反应为“一对多关联”。分为单一对关系和双向一对多关系。\n\n- ***单向一对多关联：*** 单向一对多的实现相对比较简单，但是存在一个问题，由于是单向关联，为了保持关联关系，我们只鞥通过主控方对被动方进行级联更新，如果被关联方的关联字段为“NOT NULL”，当Hibernate创建或者更新关联关系时，可能出现约束违例。\n- ***双向一对多关联：*** 双向一对多关联实际上是一对多和多对一的组合，在主控方配置一对多，在被控方配置多对一。\n\n###3.多对多关联\n多对多关联需要借助中间表完成多对多映射信息的保存。但是多对多的性能不佳，应避免使用，应根据情况采用延迟加载机制来避免无谓的性能开销。\n\n##Hibernate数据检索\n\n###1.Criteria Query\nCriteria Query通过面向对象化的设计，将数据查询条件封装成一个对象。简单来讲，Criteria Query可以看作是传统SQL的对象化表示,如：\n```java\nCriteria criteria = session.createCriteria(TUser.class);\ncriteria.add(Expression.eq(\"name\",\"Erica\");\ncriteria.add(Expression.eq(\"sex\",new Integer(1));\n```\n这里的criteria实例本质上是对SQL “Select * from t_user where name = 'Erica' and sex =1”的封装。Hibernate会在运行期间根据Criteria中指定的查询条件(criteria.add方法添加的查询表达式)生成相应的SQL语句。这种方式对于SQL了解有限的程序员比较方便。\n\n####Criteria查询表达式\nCriteria本身只是一个查询容器，具体的查询条件需要通过Criteria.add方法添加到Criteria实例中。\n####示例查询\nExample类实现了Criterion接口，同样它也可以座位Criteria的查询条件，Example的作用是：根据已有对象，查找属性与之相符的其他对象。\n###复合查询\n也就是查询多个条件的查询。\n\n这里就不详细记录了。\n\n###2.DetachedCriteria\n在Hibernate2中，Criteria生命周期位于其宿主session生命周期之内，也就是所session销毁的话有它创建的Criteria实例也就失效了。\n\n在Hibernate3中，提供了新的Criteria实现：DetachedCriteria。\n\nDetachedCriteria可以脱离Session实例独立存在，这样我们就可以将某些通用的Criteria查询条件进行抽离，每次使用时再与当前Session实例绑定以获得更好的代码重用效果。\n\n####Criteria高级特性\n- **限定返回的记录范围:** 通过criteria.setFirstResult/setMaxResult方法可以限制一次查询返回的记录范围。\n\n```java\nCriteria criteria = session.createCriteria(TUser.class);\n//限定查询返回检索结果中，从100条结果开始的20条记录\ncriteria.setFirstResult(100);\ncriteria.setMaxResults(20);\n```\n记录排序：\n```java\n//查询所有groupId=2的记录，并分别按照姓名（顺序）和groupId（逆序）排序\nCriteria criteria = session.createCriteria(TUser.class);\n\ncriteria.add(Expression.eq(\"groupId\",new Integer(2)));\n\ncriteria.addOrder(Order.asc(\"name\"));\ncriteria.addOrder(Order.desc(\"groupId\"));\n```\n####Criteria综述\n虽然这个比较简单，但是由于Hibernate实现过程中更加集中在HQL查询语言上，因此在实际开发中还是用官方推荐的HQL语句。\n\n\n###3.Hibernate Query Language（HQL）\nCriteria提供了符合面向对象编程风格的查询封装模式，不过HQL提供了更加丰富灵活的特性，它在涵盖了Criteria功能范围的前提下，提供了强大的查询能力。\n\n完整的HQL 语法结构如下：\n```java\n[select|update|delete ...] [from ...] [where ...] [group by ... [having ...] ] [order by ...]\n```\n\n##HQL实用技术\n\n###1.实体查询\n首先来一个最简单的例子：\n```java\nString hql = \"from TUser\";\nQuery query = session.createQuery(hql);\nList userList = query.list();\n```\n取出TUser的所有对应记录，其中在HQL中也可以采用全路径类名，特别在应用中有同类名但包名不同的情况。如：\n```java\n\"from com.zalezone.TUser\"\n```\n**注意：**HQL子句本身大小写无关，但是区中出现的类名和属性名必须注意大小写区分。另外，需要注意的是，查询的目标实体存在着继承关系的判定， 如\"from TUser\"将返回所有TUser以及TUser子类的记录，假设系统中存在TUser的两个子类，TSysAdmin和TSysOperator，那么将返回包含两个子类的所有数据，即使两个子类的表分别对应了不同的库表。\n\n如我们所知，Java中所有类都继承自java.lang.Object，那么如果这样查\"from java.lang.Object\"就会返回库表中所有库表的记录。\n\n- **Where子句**\n如果我们需要取出指定名称的记录，类似SQL，我们可以通过HQL语句加以限定:\n\n```java\nString hql = \"from TUser as user where user.name = 'Erica'\";\nQuery query = session.createQuery(hql);\nList userList = query.list();\n```\n这里的as为类名创建了一个别名,as可以忽略，而where子句指定了限定条件。where子句中可以加许多限定如下所示：\n```java\nfrom TUser user where user.age >20\nfrom TUser user where user.age between 20 and 30\nfrom TUser user where user.age in (18,28)\nfrom TUser user where user.age is null\nfrom TUser user where user.name like 'er%' \n//也可求算术表达式的值\nfrom TUser user where (user.age%2=1)\n//可加and，or来连接各个表达式\nfrom TUser user where (user.age >20) and (user.name like 'er%')\n```\n\n###2.属性查询\n有时候我们并不需要获取完整的实体对象，如在一个下拉框中显示用户名，我们可能只是需要某个属性就行，我们可以这样来完成。\n```java\nList list = session.createQuery(\"select user.name from TUser user\").list();\nIterator it = list.iterator();\nwhile(it.hasNext())\n{\n    System.out.pringln(it.next());\n}\n```\n这里我们只指定获取name属性一个String类型。如果要获取多个属性的话如下：\n```java\nList list = session.createQuery(\"select user.name，user.age from TUser user\").list();\nIterator it = list.iterator();\nwhile(it.hasNext())\n{\n    Object[] results =(Object[])it.next();\n    System.out.println(results[0]);\n    System.out.println(results[1]);\n}\n```\n如果觉得返回数组的方式不符合面向对象的风格，可以在HQL中动态的构造对象实例的方法对这些平面化的数据进行封装。\n```java\nList list = session.createQuery(\"select new TUser(user.name,user.age) from TUser user\").list();\nIterator it = list.iterator();\nwhile(it.hasNext())\n{\n    TUser user = (TUser)it.next();\n    System.out.pringtln(user.getName());\n}\n```\n通过在HQL中动态的构造对象实例，我们实现了对查询结果的对象化封装。注意此时在查询结果中的TUser对象仅仅是一个普通的Java对象，仅用于对查询结果的封装，出了在构造是赋予的属性值外，其他属性均为未赋值的状态，这也就意味着我们无法通过Session对此对象进行更新，下面代码中，对user对象的更新将导致向数据库中插入一条新的记录，而不是更新原有的记录：\n```java\nList list = session.createQuery(\"select new TUser(user.name,user.age) from TUser user\").list();\nIterator it = list.iterator();\nwhile(it.hasNext())\n{\n    TUser user = (TUser)it.next();\n    user.setName(“test”);\n    session.saveOrUpdate(user);//这里将导致一次insert操作，而非update\n}\n```\n另外，我们也可以在HQL中的Select子句中使用统计函数：\n```java\nList list = session.createQuery(\"select count(*),min(user.age) from TUser user\").list();\nIterator it = list.iterator();\nwhile(it.hasNext())\n{\n    Object[] results =(Object[])it.next();\n    System.out.println(results[0]);\n    System.out.println(results[1]);\n}\n```\n甚至原生SQL函数如：\n```java\nselect upper(user.name) from TUser user;\nselect distinct user.name from TUser user;\n```\n\n###3.实体更新与删除\n在Hibernate3中HQL具备了更加强大的功能，其中实体更新和删除是主要特性之一。在2中是先加载实体在更改保存，在hibernate3中的话HQL提供了更加灵活便捷的实现方式。（bulk delete/update）：\n```java\nTransaction tx = session.beginTransaction();\nString hql = \"update TUser set age =18 where id =1\";\nQuery query = session.createQuery(hql);\nquery.executeUpdate();\ntx.commit();\n```\n虽然在对单个对象更新时代码没有减少多少，但是对与批量性更新操作时便捷性和性能提高就很可观。\n\nHQL的delete子句的使用同样非常简单，以下代码删除了所有年龄大于18的用户记录：\n```java\nTransaction tx = session.beginTransaction();\nString hql = \"update TUser set age =18 where age >18\";\nQuery query = session.createQuery(hql);\nquery.executeUpdate();\ntx.commit();\n```\n**注意:**在使用HQL的delte/update子句时，我们必须特别注意它们对缓存策略的影响，delete/update子句极有可能导致缓存同步上的障碍。\n\n总体来看，Hibernate3中的HQL功能已越来越全面，与SQL不同的是，SQL面向的是二维的结构化数据，而HQL则面向数据对象。在对象型数据库尚不成熟时，通过面向对象的查询语言对关系型数据库进行访问，既满足了上层结构中面向对象设计的需求，也充分利用了现有技术平台，这也是Hibernate的优势。\n\n###4.分组与排序\n- **Order by子句**\n\n    与SQL类似，HQL通过order by子句对查询结果排序如：\n\n    ```java\n    from TUser user order by user.name,user.age desc\n    ```\n- **Group by子句(having 子句)**\n    \n    用Group by对子句进行分组统计,如下我们通过Group by子句实现了同龄用户的统计：\n    \n   ```java\n    List list = session.createQuery(\"select count(user),user.age from TUser user group by user.age having count(user)>10\").list();\n    Iterator it = list.iterator();\n    while(it.hasNext())\n    {\n        Object[] results =(Object[])it.next();\n        System.out.println(results[0]);\n        System.out.println(results[1]);\n    }\n    ```\n\n###5.参数绑定\n如上面的许多Hql语句我们可以看到里面的参数都是直接写在里面的，如果要求查询的参数是变量，直接用变量名代替变量如“from TUser user where user.age>” + age;进行HQL拼接的话虽然能实现功能，但是会存在如下缺陷：\n\n- **编码更加凌乱，可读性降低:** 如果存在很多很多的查询参数将混乱无序。\n- **难以进行性能优化:**根据JDBC以及数据库的操作原理可知每次SQL执行时，数据库都将对SQL语句进行解析和优化，并将其处理结果保存在缓存中，如果以后有参数不同，语法相同的SQL命令，则直接以此缓存结果加以执行，从而避免了SQL解析和优化的开销，另外从Hibernate角度而言，它使用了PreparedStatement作为底层数据库访问手段，对于相同的SQL，也可以重用以及创建的PrepareStatement，这样如果将参数写在SQL中，将导致每次提交的SQL语句都不同，从系统角度而言不同参数将导致判断为是两个不同的SQL命令，（有些数据库相同内容的SQL大小写不同也视为是不同的SQL命令），从而会将其视为一个全新的SQL语法进行处理，缓存无法得到利用，导致了性能优化策略失效。\n- **引入额外的安全风险：**最常见的就是SQL 注入攻击了，就是针对这些SQL字符拼装造成的漏洞。\n\n参数的动态绑定机制可以妥善的处理好以上问题。类似JDBC的SQL操作，我们可以通过顺序占位符“？”对参数进行标识，并在之后对参数内容进行填充，如：\n\n- 在Session.find方法（Hibernate2）中填充参数：\n\n```java\nsession.find(\"from TUser user where user.name=?\",\"Erica\",Hibernate.STRING);\n```\n多参数的情况\n```java\nObject[] args = new Object[]{\"Erica\",new Integer(20)};\nType[] types = new Type[]{Hibernate,STRING,Hibernate.INTEGER};\nsession.find(\"from TUser user where user.name=? and user.age > ?\",args,types);\n```\n\n- 通过Query接口进行参数填充：\n\n```java\nQuery query = session.createQuery(\"from TUser user where user.name =? and user.age>?\");\nquery.setString(0,\"Erica\");\nquery.setInteger(1,20);\n```\n\n除了用顺序占位符外，Hibernate还支持引用占位符：\n```java\nString hql = \"from TUser where name = :name\";\nQuery query = session.createQuery(hql);\nquery.setParameter(\"name\",\"Erica\");\nIterator it = query.iterate();\nwhile(it.hasNext()){\n    TUser user = (TUser)it.next();\n    System.out.pringln(user.getName());\n}\n```\n以上的:name即所谓的引用占位符，它标识了一个名为“name”的查询参数，通过session.createQuery方法构造Query实例后，我们即可以根据此参数名进行参数填充。另外，我们也可以用一个JavaBean封装查询参数。\n\n参数绑定机制可以使得查询语法与具体的参数数值相互独立，这样，对于参数不同，查询语法相同的查询操作，数据库即可以实施性能优化策略，同时，参数绑定机制也杜绝了参数值对查询语法本身的影响，避免SQL注入。\n\n###6.引用查询\n有时候会碰到如下编码规范，规定在代码中不允许出现SQL语句，总之，为了避免SQL语句混杂在代码之间，我们可以采取将SQL保存在配置文件中，需要调用的时候再进行读取。Hibernate提供了HQL可配置化的内置支持。\n\n###7.联合查询\nSQL通过join子句实现多表之间的联合查询，HQL提供以下几种联合查询机制：\n\n1. inner join\n2. left outer join\n3. right outer join\n4. full join(not usually useful)\n\n这里的概念就是数据库中的连接问题，inner join类似于自然连接，对于Inner join：\n```java\nfrom TUser user inner join fetch user.address\n```\n等于执行了一下语句：select ... from T_User user inner join TAddress addr on user.id =addr.userid\n\n注意到上面HQL语句中的“fetch”关键字表明TAddress对象读出后立即填充到对应的TUser对象中。如果忽略fetch关键字，则在得到的结果集中，每个条目都是一个Object数组，其中包括了一个TUser对象以及对应的TAddress对象。另外，SQL中的on user.id = addr.user_id对于关系在映射文件指定了，所以HQL并没有对应表现。注意fetch关键字只对inner join和left join有效，对于right join而言，由于作为对象容器的TUser对象可能为null，所以也就无法通过fetch关键字强制Hibernate进行集合填充操作。右连接的话就将对象取出然后进行操作。\n\n###8.子查询\nHQL同样支持子查询，假设我们需要从一个结果中提取出拥有两条及以上地址信息的TUser对象，那么我们可以这样写HQL：\n```java\nfrom TUser user where (select count(*) from user.addresses)>1\n```\nHQL中，子查询必须出现在where子句中，且必须以一对圆括号包围。\n\n###9.数据加载方式\nHibernate支持以下几种数据加载方式：\n\n1. **即时加载（Immediate Loading）**\n\n    当实体加载完成后，立即加载其关联数据。\n    \n2. **延迟加载（Lazy Loading）**\n\n    实体加载时，其关联数据并非即刻获取，而是当关联数据第一次被访问时再进行读取。\n    \n3. **预先加载（Eager Loading）**\n\n    预先加载时，实体及其关联对象同时读取，这与即时加载类似，不过实体及其关联数据是通过一条SQL语句（基于外连接[outer join]）同时读取。\n    \n4. **批量加载（Batch Loading）**\n\n    对于即时加载和延迟加载，可以采用批量加载的方式进行性能上的优化。就是通过批量提交多个限定条件，一次完成多个数据的读取。如果使用了批量加载机制，Hibernate在进行数据查询操作前，会自动在当前的session中寻找是否还有其他同类型待加载数据，如果有，则将其查询条件合并在当前的select语句中一并提交，这样，通过一次数据库操作即完成了多个读取任务。\n    \n##10.SQL查询\n由于SQL语法本身的庞杂，以及各种数据库原生功能的多样性，HQL不能涵盖所有查询特性，有时候我们不得不借助原生的SQL或存储过程来达到我们的目标。\n\nHibernate提供了对原生SQL以及存储过程（Hibernate3）的支持，相对于基于JDBC的SQL操作，Hibernate提供了更为妥善的封装。在Hibernate SQL查询接口中，我们只需要指定别名，而ResultSet与实体的映射将由Hibernate自动完成。从一个简单的例子入手：\n```java\nSelect * from TUser where name = 'Erica'\n```\n上面的sql从表中返回特定名字的记录。如何通过HQL调用这条SQL语句，并返回对应的TUser对象？如下所示：\n\n```java\nString sql = \"select {user.*} from TUser user\";\nList list = session.createSQLQuery(sql,\"usr\",TUser.class).list();\nIterator it = list.iterator();\nwhile(it.hasNext){\n    TUser user = (TUser)it.next();\n    System.out.println(user.getName());\n}\n```\n上面的SQL片段“select u.id as {usr.id}”,其中u是SQL中TUser表的别名，而usr是我们指定的实体对象别名。在session.createSQLQuery(sql,\"usr\",TUser.class)方法中，我们将待执行的SQL传入，并指定其实体对象别名为usr，实体对象类型为TUser.class,这样，Hibernate就会根据在SQL中的别名配置，将返回的ResultSet映射到对应的实体对象实例返回。\n\n##11.自定义持久化实现\n简单来说就是运行自己定义持久化的实现机制。\n","slug":"hibernate","updated":1430046788000,"excerpt":"<h2 id=\"hibernate基础语义\">hibernate基础语义</h2>\n<h3 id=\"1-Configuration\">1.Configuration</h3>\n<p>Configuration类负责管理Hibernate的配置信息。Hibernate运行时需要获取一些底层实现的基本信息。这些属性可以在Hibernate配置文件（hibernate.cfg.xml或hibernate.properties）中加以设定。</p>\n","_id":"9e0l1uhesy65jzcu","comments":true,"layout":"post","photos":[],"link":""},{"title":"Hibernate高级特性","date":1431526800000,"categories":["ul6daxntcjqe0xkn"],"tags":["yzou6ohxuwbhfjes","ipfbpmhrfb8nwyeh"],"desctiption":"Hibernate高级特性","content":"<h2 id=\"1-Hibernate持久化实现\">1.Hibernate持久化实现</h2>\n<h3 id=\"1-1实体对象生命周期\">1.1实体对象生命周期</h3>\n<ul>\n<li>实体对象的3种状态<ul>\n<li><strong>Transient（自由状态）：</strong>实体对象在内存中自由存在，与数据库的记录无关。</li>\n<li><strong>Persistent（持久状态）：</strong>实体对象处于Hibernate框架管理中。</li>\n<li><strong>Detached（游离状态）：</strong>处于Persistent状态的对象，其对应的Session实例关闭后，就处于游离状态。</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>VO与PO</p>\n<ul>\n<li>我们把处于Detached和Transient的称为VO（Value Object），而处于Persistent状态的对象称为持久对象PO（Persistence Object）</li>\n</ul>\n</li>\n<li><p>VO与PO的区别：</p>\n<ul>\n<li>VO是相对独立的实体对象，处于非管理状态。</li>\n<li>PO是由Hibernate纳入其实体管理容器的对象，它代表了数据库中某条记录对应的实体，PO的变化在事物提交时将反映到实际数据库中。</li>\n<li>如果一个PO与其对应的Session实例分离，那么它将变成一个VO。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-实体对象识别\">1.2.实体对象识别</h3>\n<ul>\n<li><p>实体身份识别</p>\n<ol>\n<li>引用比较（==）：判断两个变量是否引用了同一个对象实例。</li>\n<li>内容比较（equals）：判断两个对象的内容。</li>\n<li>在持久层角度而言，对于两个加载出来的实体对象，只要它们的主键值相同，则这两个等同。</li>\n</ol>\n</li>\n<li><p>脏数据检查</p>\n<ul>\n<li>这里的脏数据并非指废弃或无用的数据，而是指一个数据对象所携带的信息发生改变之后的状态。比如在数据库中Load出一个实体对象然后对数据进行设置或者改变数值以后的话就称为所谓的脏数据。，事务提交以后，Hibernate会对session中的PO进检测，将变化的数据更新到数据库中。</li>\n</ul>\n</li>\n<li><p>脏数据检查策略一般两种</p>\n<ol>\n<li><strong>数据对象监控：</strong>实现方式大体是通过拦截器对数据对象设置值的方法进行拦截，一旦数据对象的设置值方法被调用，则将其标志位待更新状态，之后数据库操作时将对其更新到对应数据库表。</li>\n<li><p><strong>数据库版本比对：</strong>在持久层框架中维持数据对象最近的读取版本，当数据提交时与此版本进行对比，如果发生变化则将其同步到数据库对应的库表。</p>\n<p>Hibernate采取的是第二种检查策略。</p>\n</li>\n</ol>\n</li>\n<li><p>unsaved-value</p>\n<ul>\n<li>数据保存时，Hibernate将根据这个值来判断对象是否需要保存。首先Hibernate会取出目标对象的id，之后将与unsaved-value进行比对，如果相等，则认为目标对象尚未保存。如：user对象是之前由Hibernate从数据库中获取，同时，此user对象的若干个关联对象address也被加载，此时我们向user对象新增一个address对象，此时调用session.save(user)，Hibernate会根据unsaved-value判断user对象的数个address关联对象中，哪些需要执行save操作，哪些不需要。</li>\n<li>对于新加入的address对象来说，由于id尚未赋值，因此为null，与我们设定的unsaved-value（null）相同，因此Hibernate视其为一个未保存对象，将其生成insert语句并执行。</li>\n<li>对于save操作而言，如果对象已经和session对象关联，则不需要进行具体的操作，因为之后的session.flush过程中，Hibernate会对此实体容器中的对象进行遍历，查处发生变化的实体，生成并执行相应的update语句。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3数据缓存\">1.3数据缓存</h3>\n<ul>\n<li><p>数据缓存概述</p>\n<ul>\n<li>对于ORM实现而言，缓存显得比较重要，因为ORM实现往往需要借助更加复杂的机制，以实现内部状态的管理，OR关系的映射。所以需要弥补这些性能差距。</li>\n<li>缓存是数据库数据在内存中的临时容器，它处于数据库和数据访问层之间。ORM在进行数据读取时，会根据缓存管理策略，首先在缓存中查询。</li>\n</ul>\n</li>\n<li><p>数据缓存策略</p>\n<ul>\n<li><strong>事务级缓存：</strong>事务可能是一个数据库事务，也可能是某个应用级事务，对于Hibernate来说，这里的事务级缓存是基于Session生命周期实现的，每个Session会在内部维持一个数据缓存，此缓存随着Session的创建而存在，也称内部缓存。</li>\n<li><strong>应用级缓存：</strong>此缓存可由多个事务共享。在Hibernate中，应用级缓存在SessionFactory层实现，所有由此SessionFactory创建的Session实例共享此缓存，但是在多实例并发运行的环境中，应用级缓存无法使用，所以引入了分布式缓存。</li>\n<li><strong>分布式缓存：</strong>在多个应用实例，多个JVM之间共享的缓存模式。分布式缓存由多个应用级缓存实例组成集群，通过某种远程机制（RMI，JMS）实现各个缓存实例之间的数据同步，但是性能方面开销大，实际使用有待考证。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-4Hibernate数据缓存\">1.4Hibernate数据缓存</h3>\n<ul>\n<li><p>Hibernate数据缓存分为两个层次：</p>\n<ol>\n<li>内部缓存（Session Level，也成为一级缓存）</li>\n<li>二级缓存（SessionFactory Level，也称二级缓存）</li>\n</ol>\n</li>\n<li><p>第三方缓存实现：</p>\n<ul>\n<li>Hibernate本身并未提供二级缓存的产品化实现（只是提供了一个基于Hashtable的简单缓存以供调试），为众多第三方缓存组件提供了接入接口。如EHCache，OSCache，JBoss Cache，SwarmCache等等。</li>\n</ul>\n</li>\n<li><p>缓存同步策略：</p>\n<ol>\n<li><strong>read-only：</strong> 只读，对于不会发生改变的数据，可使用只读型缓存。</li>\n<li><strong>nonstrict-read-write：</strong> 如果程序对并发访问的同步要求不严格，且数据更新频率较低，可采用此选项获得较好的性能。</li>\n<li><strong>read-write：</strong>严格可读写缓存，基于时间戳判断，实现了“read committed”事务隔离登记，可用于对数据同步要求严格的情况，但不支持分布式缓存。</li>\n<li><strong>transactional：</strong> 事务型缓存，必须运行在JTA事务环境中。缓存相关的操作也被添加到了事务之中（此时的缓存类似于一个内存数据库），如果由于某种原因导致事务失败，则可以连缓冲池中的数据一起回滚，适用于对关键数据进行缓存。</li>\n</ol>\n</li>\n<li><p>事务管理概述</p>\n<ul>\n<li>事务包含四个特性：即ACID<ol>\n<li>Atomic（原子性）：操作要么成功，要么失败。</li>\n<li>Consistency（一致性）：只有合法数据才能写入。</li>\n<li>Isolation（隔离性）：事务允许多个用户对同一个数据的并发访问，而不破坏正确性和完整性。</li>\n<li>Durability（持久性）：事务结束后，数据能持久化。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p>———to be continued</p>\n","source":"_posts/hibernate高级特性.md","raw":"title: Hibernate高级特性\ndate: 2015-05-13 22:20:00\ncategories: java\ntags: [java,Hibernate]\ndesctiption: Hibernate高级特性\n\n---\n\n##1.Hibernate持久化实现\n\n###1.1实体对象生命周期\n- 实体对象的3种状态\n    - **Transient（自由状态）：**实体对象在内存中自由存在，与数据库的记录无关。\n    - **Persistent（持久状态）：**实体对象处于Hibernate框架管理中。\n    - **Detached（游离状态）：**处于Persistent状态的对象，其对应的Session实例关闭后，就处于游离状态。\n\n<!-- more -->\n\n- VO与PO\n    - 我们把处于Detached和Transient的称为VO（Value Object），而处于Persistent状态的对象称为持久对象PO（Persistence Object）\n\n- VO与PO的区别：\n\n    - VO是相对独立的实体对象，处于非管理状态。\n    - PO是由Hibernate纳入其实体管理容器的对象，它代表了数据库中某条记录对应的实体，PO的变化在事物提交时将反映到实际数据库中。\n    - 如果一个PO与其对应的Session实例分离，那么它将变成一个VO。\n\n###1.2.实体对象识别\n- 实体身份识别\n    1. 引用比较（==）：判断两个变量是否引用了同一个对象实例。\n    2. 内容比较（equals）：判断两个对象的内容。\n    3. 在持久层角度而言，对于两个加载出来的实体对象，只要它们的主键值相同，则这两个等同。\n\n- 脏数据检查\n    - 这里的脏数据并非指废弃或无用的数据，而是指一个数据对象所携带的信息发生改变之后的状态。比如在数据库中Load出一个实体对象然后对数据进行设置或者改变数值以后的话就称为所谓的脏数据。，事务提交以后，Hibernate会对session中的PO进检测，将变化的数据更新到数据库中。\n    \n- 脏数据检查策略一般两种\n    1. **数据对象监控：**实现方式大体是通过拦截器对数据对象设置值的方法进行拦截，一旦数据对象的设置值方法被调用，则将其标志位待更新状态，之后数据库操作时将对其更新到对应数据库表。\n    2. **数据库版本比对：**在持久层框架中维持数据对象最近的读取版本，当数据提交时与此版本进行对比，如果发生变化则将其同步到数据库对应的库表。\n\n    Hibernate采取的是第二种检查策略。\n\n- unsaved-value\n    - 数据保存时，Hibernate将根据这个值来判断对象是否需要保存。首先Hibernate会取出目标对象的id，之后将与unsaved-value进行比对，如果相等，则认为目标对象尚未保存。如：user对象是之前由Hibernate从数据库中获取，同时，此user对象的若干个关联对象address也被加载，此时我们向user对象新增一个address对象，此时调用session.save(user)，Hibernate会根据unsaved-value判断user对象的数个address关联对象中，哪些需要执行save操作，哪些不需要。\n    - 对于新加入的address对象来说，由于id尚未赋值，因此为null，与我们设定的unsaved-value（null）相同，因此Hibernate视其为一个未保存对象，将其生成insert语句并执行。\n    - 对于save操作而言，如果对象已经和session对象关联，则不需要进行具体的操作，因为之后的session.flush过程中，Hibernate会对此实体容器中的对象进行遍历，查处发生变化的实体，生成并执行相应的update语句。\n\n###1.3数据缓存\n\n- 数据缓存概述\n    - 对于ORM实现而言，缓存显得比较重要，因为ORM实现往往需要借助更加复杂的机制，以实现内部状态的管理，OR关系的映射。所以需要弥补这些性能差距。\n    - 缓存是数据库数据在内存中的临时容器，它处于数据库和数据访问层之间。ORM在进行数据读取时，会根据缓存管理策略，首先在缓存中查询。\n\n- 数据缓存策略\n    - **事务级缓存：**事务可能是一个数据库事务，也可能是某个应用级事务，对于Hibernate来说，这里的事务级缓存是基于Session生命周期实现的，每个Session会在内部维持一个数据缓存，此缓存随着Session的创建而存在，也称内部缓存。\n    - **应用级缓存：**此缓存可由多个事务共享。在Hibernate中，应用级缓存在SessionFactory层实现，所有由此SessionFactory创建的Session实例共享此缓存，但是在多实例并发运行的环境中，应用级缓存无法使用，所以引入了分布式缓存。\n    - **分布式缓存：**在多个应用实例，多个JVM之间共享的缓存模式。分布式缓存由多个应用级缓存实例组成集群，通过某种远程机制（RMI，JMS）实现各个缓存实例之间的数据同步，但是性能方面开销大，实际使用有待考证。\n\n###1.4Hibernate数据缓存\n\n- Hibernate数据缓存分为两个层次：\n    1. 内部缓存（Session Level，也成为一级缓存）\n    2. 二级缓存（SessionFactory Level，也称二级缓存）\n\n- 第三方缓存实现：\n    - Hibernate本身并未提供二级缓存的产品化实现（只是提供了一个基于Hashtable的简单缓存以供调试），为众多第三方缓存组件提供了接入接口。如EHCache，OSCache，JBoss Cache，SwarmCache等等。\n    \n- 缓存同步策略：\n    1. **read-only：** 只读，对于不会发生改变的数据，可使用只读型缓存。\n    2. **nonstrict-read-write：** 如果程序对并发访问的同步要求不严格，且数据更新频率较低，可采用此选项获得较好的性能。\n    3. **read-write：**严格可读写缓存，基于时间戳判断，实现了“read committed”事务隔离登记，可用于对数据同步要求严格的情况，但不支持分布式缓存。\n    4. **transactional：** 事务型缓存，必须运行在JTA事务环境中。缓存相关的操作也被添加到了事务之中（此时的缓存类似于一个内存数据库），如果由于某种原因导致事务失败，则可以连缓冲池中的数据一起回滚，适用于对关键数据进行缓存。\n\n- 事务管理概述\n    - 事务包含四个特性：即ACID\n        1. Atomic（原子性）：操作要么成功，要么失败。\n        2. Consistency（一致性）：只有合法数据才能写入。\n        3. Isolation（隔离性）：事务允许多个用户对同一个数据的并发访问，而不破坏正确性和完整性。\n        4. Durability（持久性）：事务结束后，数据能持久化。\n\n------to be continued","slug":"hibernate高级特性","updated":1431526942000,"excerpt":"<h2 id=\"1-Hibernate持久化实现\">1.Hibernate持久化实现</h2>\n<h3 id=\"1-1实体对象生命周期\">1.1实体对象生命周期</h3>\n<ul>\n<li>实体对象的3种状态<ul>\n<li><strong>Transient（自由状态）：</strong>实体对象在内存中自由存在，与数据库的记录无关。</li>\n<li><strong>Persistent（持久状态）：</strong>实体对象处于Hibernate框架管理中。</li>\n<li><strong>Detached（游离状态）：</strong>处于Persistent状态的对象，其对应的Session实例关闭后，就处于游离状态。</li>\n</ul>\n</li>\n</ul>\n","_id":"51mm5v9ltr4k45mk","comments":true,"layout":"post","photos":[],"link":""},{"title":"Android NDK 入门","date":1431763320000,"categories":["pmcyb6oshop5size"],"tags":["hf98yxietusc8sh7","z83meftizl2jbogq"],"desctiption":"Android NDK 入门","content":"<h1 id=\"Android_NDK_入门\">Android NDK 入门</h1>\n<h2 id=\"简介\">简介</h2>\n<p>NDK是一系列工具的集合：</p>\n<ul>\n<li>NDK提供一系列帮助开发者开发C，C++的动态库，并能自动将so和java应用一起打包成apk。</li>\n<li>NDK继承了交叉编译器，并提供了相应的mk文件隔离CPU，平台，ABI等差异，开发人员只要简单修改mk文件，就可以创建出so。</li>\n<li>NDK提供了一份稳定功能有限的API头文件声明。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"开发环境搭建\">开发环境搭建</h2>\n<ol>\n<li>下载NDK压缩包。</li>\n<li>配置NDK环境变量。</li>\n<li>运行ndk-build 测试环境是否安装成功。</li>\n<li>测试需要的环境是否具备：make -v ，gcc -v，其中make的版本要在3.81以上。</li>\n</ol>\n<h2 id=\"编写JAVA代码\">编写JAVA代码</h2>\n<ol>\n<li><strong>建立一个工程，创建一个主Activity，我们要实现一个用本地代码写的加法运算。</strong></li>\n</ol>\n<p><strong>MainActivity.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>{</div><div class=\"line\"></div><div class=\"line\">    Button jniTestButton;</div><div class=\"line\">\tTextView showTextview;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"annotation\">@Override</span></div><div class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span>(Bundle savedInstanceState) {</div><div class=\"line\">\t\t<span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">\t\tsetContentView(R.layout.activity_main);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tjniTestButton = (Button)findViewById(R.id.button1);</div><div class=\"line\">\t\tshowTextview = (TextView)findViewById(R.id.textView1);</div><div class=\"line\">        </div><div class=\"line\">\t\tjniTestButton.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() {</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\t<span class=\"annotation\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span>(View v) {</div><div class=\"line\">\t\t\t\tJNITest jniTest = <span class=\"keyword\">new</span> JNITest();</div><div class=\"line\">\t\t\t\tshowTextview.setText(String.valueOf(jniTest.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>)));</div><div class=\"line\">\t\t\t}</div><div class=\"line\">\t\t});</div><div class=\"line\">\t\t</div><div class=\"line\">\t}</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>JNITest.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JNITest</span> </span>{</div><div class=\"line\">    </div><div class=\"line\">\t<span class=\"comment\">//静态方法表明程序开始运行时就会加载jnitest,static区的方法会先于onCreate方法执行如果程序中有多个类，而且如果JNITest这个类不是你应用程序的入口，那么JNITest（完整的名字是lib JNITest.so）这个库会在第一次使用JNITest这个类的时候加载。</span></div><div class=\"line\">\t<span class=\"keyword\">static</span>{</div><div class=\"line\">\t\t<span class=\"comment\">//加载自定义的so库</span></div><div class=\"line\">\t\tSystem.loadLibrary(<span class=\"string\">\"jnitest\"</span>);</div><div class=\"line\">\t}</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">//本地方法，是通过(C/C++)实现的，这里只是声明</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span>(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b);</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong><em>这两个java文件的功能就是创建一个按钮，在按钮按下时进行加法运算。具体的说明已经在代码中解释了，参照以上代码</em></strong></p>\n<p>2.<strong> 生成.h文件</strong></p>\n<p>在C/C++文件编写之前，需要用javah这个工具生成相应的.h文件，然后根据生成的这个文件编写相应的C/C++代码。</p>\n<p>在工程目录下执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">javah -classpath cpath <span class=\"operator\">-d</span> dir com.example.ndktest.JNITest</div></pre></td></tr></table></figure>\n\n<p>其中-classpath 表示类路径， -d 表示生成的.h文件存放目录，输入完成后我们会发现生成了一个.h文件：com<em> example</em> ndktest_JNITest.h</p>\n<p>打开这个文件可以看到如下的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* DO NOT EDIT THIS FILE - it is machine generated */</span></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> &lt;jni.h&gt;</span></div><div class=\"line\"><span class=\"comment\">/* Header for class com_example_ndktest_JNITest */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#ifndef _Included_com_example_ndktest_JNITest</span></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> _Included_com_example_ndktest_JNITest</span></div><div class=\"line\"><span class=\"preprocessor\">#ifdef __cplusplus</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> {</div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">endif</span></span></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * Class:     com_example_ndktest_JNITest</div><div class=\"line\"> * Method:    add</div><div class=\"line\"> * Signature: (II)I</div><div class=\"line\"> */</div><div class=\"line\">JNIEXPORT jint JNICALL Java_com_example_ndktest_JNITest_add</div><div class=\"line\">  (JNIEnv *, jobject, jint, jint);</div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#ifdef __cplusplus</span></div><div class=\"line\">}</div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">endif</span></span></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">endif</span></span></div></pre></td></tr></table></figure>\n\n<p><strong>说明：</strong></p>\n<p>上面代码中的JNIEXPORT 和 JNICALL 是jni的宏，在android的jni中不需要，当然写上去也不会有错。<br>函数名比较长但是完全按照：java_pacakege_class_mathod 形式来命名。</p>\n<p>也就是说：</p>\n<p>TestNDK.java中stringTestNdk() 方法对应于 C/C++中的<br>Java<em>com_blueeagle_example_testNDK</em> stringTestNdk() 方法</p>\n<p>这里为空是指除了JNIEnv <em>, jobject 这两个参数之外没有其他参数，JNIEnv</em>, jobject是所有jni函数必有的两个参数，分别表示jni环境和对应的java类（或对象）本身</p>\n<h2 id=\"编写C/C++文件\">编写C/C++文件</h2>\n<p>直接用.h文件然后实现相应的方法就行了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* DO NOT EDIT THIS FILE - it is machine generated */</span></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> &lt;jni.h&gt;</span></div><div class=\"line\"><span class=\"comment\">/* Header for class com_example_ndktest_JNITest */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#ifndef _Included_com_example_ndktest_JNITest</span></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> _Included_com_example_ndktest_JNITest</span></div><div class=\"line\"><span class=\"preprocessor\">#ifdef __cplusplus</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> {</div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">endif</span></span></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * Class:     com_example_ndktest_JNITest</div><div class=\"line\"> * Method:    add</div><div class=\"line\"> * Signature: (II)I</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//需要自己给参数取名字，然后把方法实现,其余不动</span></div><div class=\"line\">JNIEXPORT jint JNICALL Java_com_example_ndktest_JNITest_add(JNIEnv *env,</div><div class=\"line\">    \tjobject jo, jint ji1, jint ji2) {</div><div class=\"line\">\t<span class=\"keyword\">return</span> ji1 + ji2;</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#ifdef __cplusplus</span></div><div class=\"line\">}</div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">endif</span></span></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">endif</span></span></div></pre></td></tr></table></figure>\n\n<h2 id=\"编译生成相应的库\">编译生成相应的库</h2>\n<ol>\n<li>首先需要编写Android.mk的文件：在.c文件的同级目录下新建一个android.mk文件。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"preprocessor\">#一个Android.mk文件首先必须定义好LOCAL_PATH变量，它用于在开发树中查找源文件。这里的宏函数由编译系统提供，用于返回当前包含</span></div><div class=\"line\"><span class=\"preprocessor\">#Android.mk文件的路径</span></div><div class=\"line\">LOCAL_PATH:=$(call my-dir)</div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#CLEAR_VARS由编译系统提供，指定让GUN MAKEFILE为你清除许多LOCAL_xxx变量，除了LOCAL_PATH.这是必要的，</span></div><div class=\"line\"><span class=\"preprocessor\">#因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。</span></div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#库文件名,编译的目标对象，自己定义，编译系统会自动产生合适的前缀和后缀，生成.so文件</span></div><div class=\"line\">LOCAL_MODULE := jnitest</div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#原文件名称，要编译打包进模块中的C或C++源代码文件。不用在这里列出头文件和包含文件，</span></div><div class=\"line\"><span class=\"preprocessor\">#因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好</span></div><div class=\"line\">LOCAL_SRC_FILES := com_example_ndktest_JNITest.c</div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#BUILD_SHARED_LIBRARY表示编译生成共享库，是编译系统提供的变量，指向一个GNU Makefile脚本，负责收集自从上次调</span></div><div class=\"line\"><span class=\"preprocessor\">#用'include $(CLEAR_VARS)'以来，定义在LOCAL_XXX变量中的所有信息，并且决定编译什么，如何正确地去做。</span></div><div class=\"line\"><span class=\"preprocessor\">#还有 BUILD_STATIC_LIBRARY变量表示生成静态库：lib$(LOCAL_MODULE).a， BUILD_EXECUTABLE 表示生成可执行文件。</span></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n\n<p>2.进行编译，进入到工程根目录，输入ndk-build即可生成相应的库libs/armeabi/libjnitest.so</p>\n<h2 id=\"在eclipse中重新编译工程，生成apk\">在eclipse中重新编译工程，生成apk</h2>\n<p>重新编译工程，将so包导入工程apk包，即可以看到结果。</p>\n","source":"_posts/Android-NDK入门.md","raw":"title: Android NDK 入门\ndate: 2015-05-16 16:02:00\ncategories: android\ntags: [android,NDK]\ndesctiption: Android NDK 入门\n\n---\n\n#Android NDK 入门\n\n##简介\nNDK是一系列工具的集合：\n\n- NDK提供一系列帮助开发者开发C，C++的动态库，并能自动将so和java应用一起打包成apk。\n- NDK继承了交叉编译器，并提供了相应的mk文件隔离CPU，平台，ABI等差异，开发人员只要简单修改mk文件，就可以创建出so。\n- NDK提供了一份稳定功能有限的API头文件声明。\n\n\n<!--more-->\n\n##开发环境搭建\n\n1. 下载NDK压缩包。\n2. 配置NDK环境变量。\n3. 运行ndk-build 测试环境是否安装成功。\n4. 测试需要的环境是否具备：make -v ，gcc -v，其中make的版本要在3.81以上。\n\n##编写JAVA代码\n1. **建立一个工程，创建一个主Activity，我们要实现一个用本地代码写的加法运算。**\n\n**MainActivity.java**\n```java\npublic class MainActivity extends Activity {\n\n    Button jniTestButton;\n\tTextView showTextview;\n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\t\n\t\tjniTestButton = (Button)findViewById(R.id.button1);\n\t\tshowTextview = (TextView)findViewById(R.id.textView1);\n        \n\t\tjniTestButton.setOnClickListener(new OnClickListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tJNITest jniTest = new JNITest();\n\t\t\t\tshowTextview.setText(String.valueOf(jniTest.add(1, 2)));\n\t\t\t}\n\t\t});\n\t\t\n\t}\n}\n```\n\n**JNITest.java**\n```java\npublic class JNITest {\n    \n\t//静态方法表明程序开始运行时就会加载jnitest,static区的方法会先于onCreate方法执行如果程序中有多个类，而且如果JNITest这个类不是你应用程序的入口，那么JNITest（完整的名字是lib JNITest.so）这个库会在第一次使用JNITest这个类的时候加载。\n\tstatic{\n\t\t//加载自定义的so库\n\t\tSystem.loadLibrary(\"jnitest\");\n\t}\n\t\n\t//本地方法，是通过(C/C++)实现的，这里只是声明\n\tpublic native int add(int a,int b);\n}\n\n```\n\n***这两个java文件的功能就是创建一个按钮，在按钮按下时进行加法运算。具体的说明已经在代码中解释了，参照以上代码***\n\n2.** 生成.h文件**\n\n在C/C++文件编写之前，需要用javah这个工具生成相应的.h文件，然后根据生成的这个文件编写相应的C/C++代码。\n\n在工程目录下执行：\n\n```shell\njavah -classpath cpath -d dir com.example.ndktest.JNITest\n```\n\n其中-classpath 表示类路径， -d 表示生成的.h文件存放目录，输入完成后我们会发现生成了一个.h文件：com_ example_ ndktest_JNITest.h\n\n打开这个文件可以看到如下的代码：\n\n```c\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class com_example_ndktest_JNITest */\n\n#ifndef _Included_com_example_ndktest_JNITest\n#define _Included_com_example_ndktest_JNITest\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     com_example_ndktest_JNITest\n * Method:    add\n * Signature: (II)I\n */\nJNIEXPORT jint JNICALL Java_com_example_ndktest_JNITest_add\n  (JNIEnv *, jobject, jint, jint);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\n\n**说明：**\n\n上面代码中的JNIEXPORT 和 JNICALL 是jni的宏，在android的jni中不需要，当然写上去也不会有错。\n函数名比较长但是完全按照：java_pacakege_class_mathod 形式来命名。\n\n也就是说：\n\nTestNDK.java中stringTestNdk() 方法对应于 C/C++中的 \nJava_com_blueeagle_example_testNDK_ stringTestNdk() 方法\n\n这里为空是指除了JNIEnv *, jobject 这两个参数之外没有其他参数，JNIEnv*, jobject是所有jni函数必有的两个参数，分别表示jni环境和对应的java类（或对象）本身\n\n##编写C/C++文件\n直接用.h文件然后实现相应的方法就行了。\n\n```c\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class com_example_ndktest_JNITest */\n\n#ifndef _Included_com_example_ndktest_JNITest\n#define _Included_com_example_ndktest_JNITest\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     com_example_ndktest_JNITest\n * Method:    add\n * Signature: (II)I\n */\n\n//需要自己给参数取名字，然后把方法实现,其余不动\nJNIEXPORT jint JNICALL Java_com_example_ndktest_JNITest_add(JNIEnv *env,\n    \tjobject jo, jint ji1, jint ji2) {\n\treturn ji1 + ji2;\n}\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n\n```\n\n##编译生成相应的库\n1. 首先需要编写Android.mk的文件：在.c文件的同级目录下新建一个android.mk文件。\n\n```c\n#一个Android.mk文件首先必须定义好LOCAL_PATH变量，它用于在开发树中查找源文件。这里的宏函数由编译系统提供，用于返回当前包含\n#Android.mk文件的路径\nLOCAL_PATH:=$(call my-dir)\n\n#CLEAR_VARS由编译系统提供，指定让GUN MAKEFILE为你清除许多LOCAL_xxx变量，除了LOCAL_PATH.这是必要的，\n#因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。\ninclude $(CLEAR_VARS)\n\n#库文件名,编译的目标对象，自己定义，编译系统会自动产生合适的前缀和后缀，生成.so文件\nLOCAL_MODULE := jnitest\n\n#原文件名称，要编译打包进模块中的C或C++源代码文件。不用在这里列出头文件和包含文件，\n#因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好\nLOCAL_SRC_FILES := com_example_ndktest_JNITest.c\n\n#BUILD_SHARED_LIBRARY表示编译生成共享库，是编译系统提供的变量，指向一个GNU Makefile脚本，负责收集自从上次调\n#用'include $(CLEAR_VARS)'以来，定义在LOCAL_XXX变量中的所有信息，并且决定编译什么，如何正确地去做。\n#还有 BUILD_STATIC_LIBRARY变量表示生成静态库：lib$(LOCAL_MODULE).a， BUILD_EXECUTABLE 表示生成可执行文件。\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\n2.进行编译，进入到工程根目录，输入ndk-build即可生成相应的库libs/armeabi/libjnitest.so\n\n##在eclipse中重新编译工程，生成apk\n重新编译工程，将so包导入工程apk包，即可以看到结果。","slug":"Android-NDK入门","updated":1431763580000,"excerpt":"<h1 id=\"Android_NDK_入门\">Android NDK 入门</h1>\n<h2 id=\"简介\">简介</h2>\n<p>NDK是一系列工具的集合：</p>\n<ul>\n<li>NDK提供一系列帮助开发者开发C，C++的动态库，并能自动将so和java应用一起打包成apk。</li>\n<li>NDK继承了交叉编译器，并提供了相应的mk文件隔离CPU，平台，ABI等差异，开发人员只要简单修改mk文件，就可以创建出so。</li>\n<li>NDK提供了一份稳定功能有限的API头文件声明。</li>\n</ul>\n","_id":"krm3cu349djz2wjw","comments":true,"layout":"post","photos":[],"link":""},{"title":"翻墙攻略（二）","date":1436785740000,"categories":["klheiemw6tkdcymi"],"tags":["6eb5q39369ylrcw0","3kgyc0lh77g5w4wm","1gd179n4toen98lm","4qnntf6fxvp34rx6"],"desctiption":"使用VPS主机和shadowsocks搭建代理服务器翻墙","content":"<h2 id=\"简介\">简介</h2>\n<p>近日买了个VPS主机，经推荐买了个便宜的VPS主机，刚刚将所有服务都搭好，自己进行了测试，发现速度挺好，还能在线观看youtube的视频。</p>\n<h2 id=\"起步\">起步</h2>\n<p>说道，经过我本人发现，网上的教程大都都没有讲清楚或者讲的太乱，对于我这种新兴用户来说难免有些晕。接下来我就把我个人摸索出来的搭建步骤简单整理一下供大家参考，尽量让大家少走弯路。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"机器环境\">机器环境</h2>\n<ul>\n<li>VPS 主机：ubuntu 12.04</li>\n<li>客户端：windows，linux，android手机，ipad</li>\n</ul>\n<h2 id=\"搭建步骤\">搭建步骤</h2>\n<h3 id=\"VPS主机\">VPS主机</h3>\n<ul>\n<li>首先，你得有一台VPS主机，我买的是HOST1Plus网上的主机，这个是国外的，一般只要用作翻墙的话买最便宜的配置的VPS主机一般足够用了，当然你是土豪你随意。另外，如果你有关于主机选择方面的问题的话你也可以联系在线客服，可惜是歪国人，英语不是很好的比如我准备好百度翻译以备不时只需。</li>\n</ul>\n<h3 id=\"VPS主机配置\">VPS主机配置</h3>\n<ul>\n<li>然后，你得配置你的主机，让你的主机具有代理的功能服务。这里我使用的一个软件叫shadowsocks，中文名好像叫“影梭”。关于在ubuntu下的安装也是十分的简单，概括一下就是先安装shadowsocks软件。命令如下：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-<span class=\"built_in\">get</span> install <span class=\"keyword\">python</span>-gevent <span class=\"keyword\">python</span>-pip</div><div class=\"line\">pip install shadowsocks</div></pre></td></tr></table></figure>\n\n<ul>\n<li>接着，对这个软件的配置也很简单，自己找个目录，然后新建一个config.json文件，名字可以自己取。如下：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">{</div><div class=\"line\">  \"<span class=\"attribute\">server</span>\":<span class=\"value\"><span class=\"string\">\"my_server_ip\"</span></span>,</div><div class=\"line\">  \"<span class=\"attribute\">server_port</span>\":<span class=\"value\"><span class=\"number\">8388</span></span>,</div><div class=\"line\">  \"<span class=\"attribute\">local_port</span>\":<span class=\"value\"><span class=\"number\">1080</span></span>,</div><div class=\"line\">  \"<span class=\"attribute\">password</span>\":<span class=\"value\"><span class=\"string\">\"password\"</span></span>,</div><div class=\"line\">  \"<span class=\"attribute\">timeout</span>\":<span class=\"value\"><span class=\"number\">600</span></span>,</div><div class=\"line\">  \"<span class=\"attribute\">method</span>\":<span class=\"value\"><span class=\"string\">\"table\"</span></span></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<ul>\n<li><p>这里面也是非常直观的，一般只要该server和password，其中服务器端的server的地址就是服务器的IP地址。还有method是传输的加密方式，一般也要改。可选择“bf-cfb”,“aes-256-cfb”,“des-cfb”,“rc4″,等等。默认是一种不安全的加密，推荐用“aes-256-cfb”</p>\n</li>\n<li><p>配置完以后就在这个文件的目录下执行，就能启动服务了，当然也可选择后台服务运行</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"preprocessor\">#在终端中启动服务</span></div><div class=\"line\">ssserver -c /etc/shadowsocks/config.json</div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#在后台启动服务，如果在终端中启动服务的话如果退出当前终端的话服务就被杀死了，所以为了保持服务的继续存在，需要将服务在后台运行。</span></div><div class=\"line\">nohup ssserver -c /usr/local/lib/python2<span class=\"number\">.7</span>/dist-packages/shadowsocks/config.json &gt; log &</div></pre></td></tr></table></figure>\n\n<h3 id=\"客户端配置\">客户端配置</h3>\n<ul>\n<li>客户端中的配置看具体情况了，向Ipad或者android都有比较方便的客户端，直接改一下地址就行。</li>\n<li>但是在PC端 的话除了运行客户端软件外，当你在浏览器中浏览网页时还需要配置一下浏览器，这里我用的谷歌浏览器，用了SwitchyOmega这个插件，总体感觉挺好用，就是在新建一个代理，IP地址填本地主机127.0.0.1就行，端口为本地的那个文件的本地端口。</li>\n<li>说道本地文件，这里作为客户端依旧需要服务器的那个文件，新建配置文件，然后在相应的目录执行这个命令就能将客户端与服务器连接起来。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"input\"><span class=\"prompt\">#后台执行命令</span></span></div><div class=\"line\"> nohup sslocal -s IP地址 -p 服务器端口号 -k 密码 &gt; logs &</div></pre></td></tr></table></figure>\n\n<ul>\n<li>另外，加入你比较懒的话，不想每次都开机时都重新手动去执行一次这个命令的话，你可以创建一个shell脚本，然后写入/etc/rc.local 这个文件中去，让它开机自动启动。</li>\n<li>在浏览器插件中设置相应的过滤规则就能方便的翻墙了。其中浏览器设置方式为sock5方式。</li>\n</ul>\n","source":"_posts/翻墙攻略（二）.md","raw":"title: 翻墙攻略（二）\ndate: 2015-07-13 19:09:00\ncategories: linux\ntags: [VPS主机,shadowsocks,代理服务器,翻墙]\ndesctiption: 使用VPS主机和shadowsocks搭建代理服务器翻墙\n\n---\n\n##简介\n近日买了个VPS主机，经推荐买了个便宜的VPS主机，刚刚将所有服务都搭好，自己进行了测试，发现速度挺好，还能在线观看youtube的视频。\n\n##起步\n说道，经过我本人发现，网上的教程大都都没有讲清楚或者讲的太乱，对于我这种新兴用户来说难免有些晕。接下来我就把我个人摸索出来的搭建步骤简单整理一下供大家参考，尽量让大家少走弯路。\n\n<!--more-->\n\n##机器环境\n- VPS 主机：ubuntu 12.04\n- 客户端：windows，linux，android手机，ipad\n\n\n##搭建步骤\n\n###VPS主机\n- 首先，你得有一台VPS主机，我买的是HOST1Plus网上的主机，这个是国外的，一般只要用作翻墙的话买最便宜的配置的VPS主机一般足够用了，当然你是土豪你随意。另外，如果你有关于主机选择方面的问题的话你也可以联系在线客服，可惜是歪国人，英语不是很好的比如我准备好百度翻译以备不时只需。\n\n###VPS主机配置\n- 然后，你得配置你的主机，让你的主机具有代理的功能服务。这里我使用的一个软件叫shadowsocks，中文名好像叫“影梭”。关于在ubuntu下的安装也是十分的简单，概括一下就是先安装shadowsocks软件。命令如下：\n\n```shell\napt-get install python-gevent python-pip\npip install shadowsocks\n```\n- 接着，对这个软件的配置也很简单，自己找个目录，然后新建一个config.json文件，名字可以自己取。如下：\n\n```shell\n{\n  \"server\":\"my_server_ip\",\n  \"server_port\":8388,\n  \"local_port\":1080,\n  \"password\":\"password\",\n  \"timeout\":600,\n  \"method\":\"table\"\n}\n```\n\n- 这里面也是非常直观的，一般只要该server和password，其中服务器端的server的地址就是服务器的IP地址。还有method是传输的加密方式，一般也要改。可选择“bf-cfb”,“aes-256-cfb”,“des-cfb”,“rc4″,等等。默认是一种不安全的加密，推荐用“aes-256-cfb”\n\n- 配置完以后就在这个文件的目录下执行，就能启动服务了，当然也可选择后台服务运行\n\n```shell\n#在终端中启动服务\nssserver -c /etc/shadowsocks/config.json\n\n#在后台启动服务，如果在终端中启动服务的话如果退出当前终端的话服务就被杀死了，所以为了保持服务的继续存在，需要将服务在后台运行。\nnohup ssserver -c /usr/local/lib/python2.7/dist-packages/shadowsocks/config.json > log &\n```\n\n###客户端配置\n- 客户端中的配置看具体情况了，向Ipad或者android都有比较方便的客户端，直接改一下地址就行。\n- 但是在PC端 的话除了运行客户端软件外，当你在浏览器中浏览网页时还需要配置一下浏览器，这里我用的谷歌浏览器，用了SwitchyOmega这个插件，总体感觉挺好用，就是在新建一个代理，IP地址填本地主机127.0.0.1就行，端口为本地的那个文件的本地端口。\n- 说道本地文件，这里作为客户端依旧需要服务器的那个文件，新建配置文件，然后在相应的目录执行这个命令就能将客户端与服务器连接起来。\n```shell\n#后台执行命令\n nohup sslocal -s IP地址 -p 服务器端口号 -k 密码 > logs &\n```\n- 另外，加入你比较懒的话，不想每次都开机时都重新手动去执行一次这个命令的话，你可以创建一个shell脚本，然后写入/etc/rc.local 这个文件中去，让它开机自动启动。\n- 在浏览器插件中设置相应的过滤规则就能方便的翻墙了。其中浏览器设置方式为sock5方式。","slug":"翻墙攻略（二）","updated":1436785769000,"excerpt":"<h2 id=\"简介\">简介</h2>\n<p>近日买了个VPS主机，经推荐买了个便宜的VPS主机，刚刚将所有服务都搭好，自己进行了测试，发现速度挺好，还能在线观看youtube的视频。</p>\n<h2 id=\"起步\">起步</h2>\n<p>说道，经过我本人发现，网上的教程大都都没有讲清楚或者讲的太乱，对于我这种新兴用户来说难免有些晕。接下来我就把我个人摸索出来的搭建步骤简单整理一下供大家参考，尽量让大家少走弯路。</p>\n","_id":"0frszdnyftyf1c1i","comments":true,"layout":"post","photos":[],"link":""}],"Tag":[{"name":"AngularJS","_id":"zaq9qstgoet3ih8y","posts":["hm2mdjiqborgqld7"]},{"name":"web前端","_id":"pudrsj74uscdx0d5","posts":["hm2mdjiqborgqld7"]},{"name":"javascript","_id":"v92q5ck2huq96atw","posts":["hm2mdjiqborgqld7"]},{"name":"NIO","_id":"8900a8x8zwmzl3ur","posts":["v0iex2kn3q70aeyg"]},{"name":"java","_id":"yzou6ohxuwbhfjes","posts":["v0iex2kn3q70aeyg","08s984skupwf687w","8ybnrk1eedp9pvlg","5ya2xti44vlx3etz","51mm5v9ltr4k45mk"]},{"name":"非阻塞","_id":"vvkvm2peee13ln7r","posts":["v0iex2kn3q70aeyg"]},{"name":"linux","_id":"9f9y6vaw8hxic410","posts":["socbgx7zyq5msdh5","x4dxwqu7l30yd6wo"]},{"name":"git","_id":"lsp9noqi7o40u9is","posts":["socbgx7zyq5msdh5"]},{"name":"代码管理","_id":"37ipdvrpy8kllo3s","posts":["socbgx7zyq5msdh5"]},{"name":"垃圾回收","_id":"o0v31j4s662upxe2","posts":["08s984skupwf687w"]},{"name":"内存管理","_id":"hwhqb4elsoskerku","posts":["08s984skupwf687w"]},{"name":"线程池","_id":"4j3aiolvlxo6aorc","posts":["8ybnrk1eedp9pvlg"]},{"name":"JDK","_id":"23ole3glifkru081","posts":["8ybnrk1eedp9pvlg"]},{"name":"性能","_id":"v84gnje2wesl3tnm","posts":["8ybnrk1eedp9pvlg"]},{"name":"DIY","_id":"ba7y88r56j7guybp","posts":["8ybnrk1eedp9pvlg"]},{"name":"goagent","_id":"u7clg3k5aw2o5rtt","posts":["x4dxwqu7l30yd6wo"]},{"name":"GFW","_id":"9tdtm2q014xhqy6l","posts":["x4dxwqu7l30yd6wo"]},{"name":"翻墙","_id":"4qnntf6fxvp34rx6","posts":["x4dxwqu7l30yd6wo","0frszdnyftyf1c1i"]},{"name":"不公平","_id":"i0y36d03vky1k3b6","posts":["dvul5yz7lg9zdglr"]},{"name":"心态","_id":"woo957svw5n66n1y","posts":["dvul5yz7lg9zdglr"]},{"name":"设计模式","_id":"bjlcejhx2acoinoo","posts":["1ola4tvw75ou1nwh","mukwirk7jsh2805p"]},{"name":"创建类模式","_id":"xlmff9lxnv3ufe2j","posts":["1ola4tvw75ou1nwh"]},{"name":"单例模式","_id":"wzlv8caqikjwx6ww","posts":["1ola4tvw75ou1nwh"]},{"name":"life","_id":"m97v9igubxl9plss","posts":["rdjztuauarfhs0h9"]},{"name":"正则表达式","_id":"cvtl2cvj7tzlad6o","posts":["5ya2xti44vlx3etz"]},{"name":"观察者模式","_id":"j5aukb7bzf04bxzu","posts":["mukwirk7jsh2805p"]},{"name":"行为类模式","_id":"jz5lf65dm6fm5m8x","posts":["mukwirk7jsh2805p"]},{"name":"设计模式，适配器模式","_id":"odb22aticq9sihxn","posts":["m5c3vnkf5ukpo1yz"]},{"name":"结构性模式","_id":"glqtgamciem49e61","posts":["m5c3vnkf5ukpo1yz"]},{"name":"android","_id":"hf98yxietusc8sh7","posts":["yg1dltd0yhkyzxla","qiq6o8fv4kkxvp59","nnpntx3oejvgfoso","krm3cu349djz2wjw"]},{"name":"SlidingMenu","_id":"ygr0yetsrvmoz7ig","posts":["yg1dltd0yhkyzxla"]},{"name":"ActionBarSherlock","_id":"mr5es4hbw6jf08st","posts":["yg1dltd0yhkyzxla"]},{"name":"侧拉菜单","_id":"rqmwgs849rzhlauj","posts":["yg1dltd0yhkyzxla"]},{"name":"UI","_id":"bmdj4v9n7r7bxuzf","posts":["yg1dltd0yhkyzxla","nnpntx3oejvgfoso"]},{"name":"交叉编译","_id":"sujnqa2jr6usmcos","posts":["qiq6o8fv4kkxvp59"]},{"name":"C","_id":"2drwjavwcpb3394k","posts":["qiq6o8fv4kkxvp59"]},{"name":"assets","_id":"3zgjfof27f9p3nm9","posts":["qiq6o8fv4kkxvp59"]},{"name":"actionBar","_id":"smya40ac1smcpulm","posts":["nnpntx3oejvgfoso"]},{"name":"数据库","_id":"3yu40szbp0iu23ln","posts":["9e0l1uhesy65jzcu"]},{"name":"hibernate","_id":"5mmy83sdzsiks9nb","posts":["9e0l1uhesy65jzcu"]},{"name":"数据持久化","_id":"005v3spuoccq52su","posts":["9e0l1uhesy65jzcu"]},{"name":"Hibernate","_id":"ipfbpmhrfb8nwyeh","posts":["51mm5v9ltr4k45mk"]},{"name":"NDK","_id":"z83meftizl2jbogq","posts":["krm3cu349djz2wjw"]},{"name":"VPS主机","_id":"6eb5q39369ylrcw0","posts":["0frszdnyftyf1c1i"]},{"name":"shadowsocks","_id":"3kgyc0lh77g5w4wm","posts":["0frszdnyftyf1c1i"]},{"name":"代理服务器","_id":"1gd179n4toen98lm","posts":["0frszdnyftyf1c1i"]}]}