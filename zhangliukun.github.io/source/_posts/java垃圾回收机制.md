title: java垃圾回收机制
date: 2015-03-15 20:45:00
categories: java
tags: [java,垃圾回收,内存管理]
desctiption: java来及回收机制与内存管理

---

##简介
垃圾回收机制主要完成下面两件事情。

- 跟踪并监控每个java对象，当某个对象处于不可达状态是，回收所占用内存
- 清理内存分配，回收过程中产生的内存碎片


<!--more -->
垃圾回收机制需要完成以上两个工作，所以工作量不算太小，因此垃圾回收算法成为限制java程序运行效率的重要因素。一个高效的垃圾回收机制既能保证垃圾回收的快速运行，避免内存的分配回收成为性能瓶颈以及导致应用程序产生停顿。


##垃圾回收器的基本算法

###可供选择的设计
- ***串行(Serial)回收和并向(Parallel)回收***：串行回收就是不管有多少个CPU，都只用一个CPU来执行垃圾回收操作，而并行回收就是吧整个工作拆分给多个CPU进行回收。效率高但是复杂度增加，另有一些副作用入内存碎片增加。
- ***并发执行(Concurrent)和应用程序停止(Stop-the-world)***：(S)这种方式在回收时会导致应用程序暂停。并发执行的垃圾回收虽然不会导致应用程序暂停，但是由于并发执行垃圾回收需要解决和应用程序的执行冲突，因此并发执行的开销要高并且也需要更多的堆内存。
- ***压缩(Compacting)/不压缩(Non-compacting)和复制(Copying)***：为了减少内存碎片，支持压缩的垃圾回收器会吧所有的活的对象搬到一起，然后将之前占用的内存全部回收，不要锁的垃圾回收器只是回收内存，这样回收来的内存不可能是连续的，会有较多的内存碎片，不压缩的机制回收快但分配内存时就会慢，而且不能解决内存碎片的问题。复制垃圾回收机制会将所有可达的对象复制到另一块内存中，这种方式的优点是垃圾回收时不会产生内存碎片，缺点是需要复制数据和额外的内存。

###具体的回收方式

- ***复制***：将对内存分为两份，从根处开始遍历每个关联的可达对象，将空间A中的可达对象复制到B中，然后回收整个A。这种方式遍历空间的成本小，但是需要巨大的空间和内存
- ***标记清除***：也就是不压缩回收方式，垃圾回收器先从根开始访问所有的可达对象，并将它们标记为可达状态，然后遍历一次整个内存区域，对所有的没有标记为可达对象进行回收处理。这种方式无需大规模复制操作，且内存利用率高。但是需要两次遍历内存空间，遍历成本大，造成应用程序暂停的时间随着堆空间的大小线性增大。而且容易产生内存碎片。
- ***标记压缩***：压缩的回收方式，这种方式在上一种的基础上会另外将标记的活动对象搬迁到一起，也称为内存压缩，减少了内存碎片。

##堆内存的分代回收
可以看出上述的方式都各有利弊，现行的来及回收器采用分代的方式来采用不同的回收设计。分代的基本思路是根据对象生存的时间长短，把堆内存分为三个代：Young,Old,Permanent

这种“分代回收“基于如下两个事实：

1. 绝大多数的对象不会被长时间引用，这些对象在其Young期间就会被回收。
2. 生存时间长的对象和短的对象之间很少存在相互引用的情况。

上面两种情况不仅在java中如此，在其他面向对象的编程语言中也是这样。

下面介绍一下三个代：

- ***Young代***: 对于Young代采用复制算法只需遍历那些处于可达状态的对象，而这些对象的数量比较少，复制成本也不大，因此能充分发挥复制算法的优点。
- ***Old代***: 如果Young代中的对象经过数次垃圾回收依然没有被回收掉，就会被转移到Old代，Old代的空间比Young代的空间更大。
- ***Permanent代***: Permanent代主要用于装载Class，方法等信息，默认为64M，垃圾回收器通常不会回收这里面的对象。


##常见的垃圾回收器
这里列举一些常见的垃圾回收器，考虑到篇幅就只列一下名字好了。

- ***串行回收器(Serial Collector)***
- ***并行回收器(Parallel Collector)***
- ***并行压缩回收器(Parallel Compacting Collector)***
- ***并发标识-清理(Mark-Sweep)回收器(CMS)***


##内存管理小技巧
更好的管理java虚拟机的内存才能提高java程序的运行性能。下面列出一些小技巧：

- ***尽量使用直接量***  ：当需要使用基本类型的数据时，不应该采用new的方式来创建对象，而应该用直接量来创建，如String str = ”test“,这样的话JVM会将这个字符串放在缓冲池中，如果用new的话不仅会放在缓冲池中还会在堆内存中开辟一个数组来保存它。
- ***使用StirngBuilder和StringBuffer进行字符串连接***  : 这个的话就是减少运行时生成的临时变量。
- ***尽早释放无用的对象的引用***  ： 大部分时候方法的局部变量是不需要手动去设置为null的，但是在一些方法后还要运行耗时操作时可能就需要手动去释放了。
- ***尽量少的使用静态变量***  ： 静态变量很有肯能会存入Permanent代，可能会使垃圾回收器不能回收此对象。
- ***避免在经常调用的方法，循环中创建java对象***  ：可能会导致不断地分配内存空间导致程序的性能受到影响。
- ***缓存经常使用的对象***  ：比如缓存一些数据库连接啊之类的。
- ***尽量不要使用finalize方法***  ：这样会家中垃圾回收器的负担，造成程序暂停之类的。
- ***考虑使用SoftReference*** ：当内存足够时，它的功能等同与普通引用，当内存不够时，他会牺牲自己，释放引用所引用的对象。
