title: Hibernate高级特性
date: 2015-05-13 22:20:00
categories: java
tags: [java,Hibernate]
desctiption: Hibernate高级特性

---

##1.Hibernate持久化实现

###1.1实体对象生命周期
- 实体对象的3种状态
    - **Transient（自由状态）：**实体对象在内存中自由存在，与数据库的记录无关。
    - **Persistent（持久状态）：**实体对象处于Hibernate框架管理中。
    - **Detached（游离状态）：**处于Persistent状态的对象，其对应的Session实例关闭后，就处于游离状态。

<!-- more -->

- VO与PO
    - 我们把处于Detached和Transient的称为VO（Value Object），而处于Persistent状态的对象称为持久对象PO（Persistence Object）

- VO与PO的区别：

    - VO是相对独立的实体对象，处于非管理状态。
    - PO是由Hibernate纳入其实体管理容器的对象，它代表了数据库中某条记录对应的实体，PO的变化在事物提交时将反映到实际数据库中。
    - 如果一个PO与其对应的Session实例分离，那么它将变成一个VO。

###1.2.实体对象识别
- 实体身份识别
    1. 引用比较（==）：判断两个变量是否引用了同一个对象实例。
    2. 内容比较（equals）：判断两个对象的内容。
    3. 在持久层角度而言，对于两个加载出来的实体对象，只要它们的主键值相同，则这两个等同。

- 脏数据检查
    - 这里的脏数据并非指废弃或无用的数据，而是指一个数据对象所携带的信息发生改变之后的状态。比如在数据库中Load出一个实体对象然后对数据进行设置或者改变数值以后的话就称为所谓的脏数据。，事务提交以后，Hibernate会对session中的PO进检测，将变化的数据更新到数据库中。
    
- 脏数据检查策略一般两种
    1. **数据对象监控：**实现方式大体是通过拦截器对数据对象设置值的方法进行拦截，一旦数据对象的设置值方法被调用，则将其标志位待更新状态，之后数据库操作时将对其更新到对应数据库表。
    2. **数据库版本比对：**在持久层框架中维持数据对象最近的读取版本，当数据提交时与此版本进行对比，如果发生变化则将其同步到数据库对应的库表。

    Hibernate采取的是第二种检查策略。

- unsaved-value
    - 数据保存时，Hibernate将根据这个值来判断对象是否需要保存。首先Hibernate会取出目标对象的id，之后将与unsaved-value进行比对，如果相等，则认为目标对象尚未保存。如：user对象是之前由Hibernate从数据库中获取，同时，此user对象的若干个关联对象address也被加载，此时我们向user对象新增一个address对象，此时调用session.save(user)，Hibernate会根据unsaved-value判断user对象的数个address关联对象中，哪些需要执行save操作，哪些不需要。
    - 对于新加入的address对象来说，由于id尚未赋值，因此为null，与我们设定的unsaved-value（null）相同，因此Hibernate视其为一个未保存对象，将其生成insert语句并执行。
    - 对于save操作而言，如果对象已经和session对象关联，则不需要进行具体的操作，因为之后的session.flush过程中，Hibernate会对此实体容器中的对象进行遍历，查处发生变化的实体，生成并执行相应的update语句。

###1.3数据缓存

- 数据缓存概述
    - 对于ORM实现而言，缓存显得比较重要，因为ORM实现往往需要借助更加复杂的机制，以实现内部状态的管理，OR关系的映射。所以需要弥补这些性能差距。
    - 缓存是数据库数据在内存中的临时容器，它处于数据库和数据访问层之间。ORM在进行数据读取时，会根据缓存管理策略，首先在缓存中查询。

- 数据缓存策略
    - **事务级缓存：**事务可能是一个数据库事务，也可能是某个应用级事务，对于Hibernate来说，这里的事务级缓存是基于Session生命周期实现的，每个Session会在内部维持一个数据缓存，此缓存随着Session的创建而存在，也称内部缓存。
    - **应用级缓存：**此缓存可由多个事务共享。在Hibernate中，应用级缓存在SessionFactory层实现，所有由此SessionFactory创建的Session实例共享此缓存，但是在多实例并发运行的环境中，应用级缓存无法使用，所以引入了分布式缓存。
    - **分布式缓存：**在多个应用实例，多个JVM之间共享的缓存模式。分布式缓存由多个应用级缓存实例组成集群，通过某种远程机制（RMI，JMS）实现各个缓存实例之间的数据同步，但是性能方面开销大，实际使用有待考证。

###1.4Hibernate数据缓存

- Hibernate数据缓存分为两个层次：
    1. 内部缓存（Session Level，也成为一级缓存）
    2. 二级缓存（SessionFactory Level，也称二级缓存）

- 第三方缓存实现：
    - Hibernate本身并未提供二级缓存的产品化实现（只是提供了一个基于Hashtable的简单缓存以供调试），为众多第三方缓存组件提供了接入接口。如EHCache，OSCache，JBoss Cache，SwarmCache等等。
    
- 缓存同步策略：
    1. **read-only：** 只读，对于不会发生改变的数据，可使用只读型缓存。
    2. **nonstrict-read-write：** 如果程序对并发访问的同步要求不严格，且数据更新频率较低，可采用此选项获得较好的性能。
    3. **read-write：**严格可读写缓存，基于时间戳判断，实现了“read committed”事务隔离登记，可用于对数据同步要求严格的情况，但不支持分布式缓存。
    4. **transactional：** 事务型缓存，必须运行在JTA事务环境中。缓存相关的操作也被添加到了事务之中（此时的缓存类似于一个内存数据库），如果由于某种原因导致事务失败，则可以连缓冲池中的数据一起回滚，适用于对关键数据进行缓存。

- 事务管理概述
    - 事务包含四个特性：即ACID
        1. Atomic（原子性）：操作要么成功，要么失败。
        2. Consistency（一致性）：只有合法数据才能写入。
        3. Isolation（隔离性）：事务允许多个用户对同一个数据的并发访问，而不破坏正确性和完整性。
        4. Durability（持久性）：事务结束后，数据能持久化。

------to be continued